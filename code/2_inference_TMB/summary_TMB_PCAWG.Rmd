---
title: "Summary of TMB runs"
author: "Lena Morrill"
date: "24/05/2021"
output: pdf_document
header-includes:
   - \usepackage{array}
   - \setlength{\textwidth}{6.7in}
   - \setlength{\oddsidemargin}{-0.1in}
   - \setlength{\textheight}{8.6in}
   - \setlength{\topmargin}{-0.4in}
   - \newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
   - \newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
   - \newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache=TRUE)
```

```{r libraries, echo=FALSE, message=FALSE, cache=TRUE, results='hide'}

library(Ternary)
library(MCMCpack)
library(TMB)
library(dplyr)
library(parallel)
library(umap)
library(gridExtra)
library(pheatmap)
library(ggplot2)
library(ggrepel)
library(RColorBrewer)

source("../2_inference_TMB/helper_TMB.R")
source("../../../CDA_in_Cancer/code/functions/meretricious/pretty_plots/prettySignatures.R")

TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda2.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda2"))
TMB::compile("../2_inference_TMB/mm_multinomial/diagRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/diagRE_dirichletmultinomial_single_lambda"))
TMB::compile("../2_inference_TMB/mm_multinomial/diagRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/diagRE_ME_dirichletmultinomial"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda2.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda2"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial_singlecov.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial_singlecov"))
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_halfdirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_halfdirichletmultinomial"))
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_dirichletmultinomial"))
TMB::compile("../2_inference_TMB/mm_multinomial/diagRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/diagRE_ME_dirichletmultinomial"))
TMB::compile("../2_inference_TMB/mm_multinomial/diagRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/diagRE_ME_multinomial"))
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))


```

```{r,, load_functions, cache=FALSE, echo=FALSE}

source("../2_inference_TMB/helper_TMB.R")
source("../../../CDA_in_Cancer/code/functions/meretricious/pretty_plots/prettySignatures.R")
source("../1_create_ROO/roo_functions.R")
source("../3_analysis/helper/pcawg.colour.palette.R")

## additional libraries
# library(tikzDevice) ## for computer modern font
# library(extrafont) ## for computer modern font
# font_import(pattern = "lmodern*")
```

```{r, read_ct, echo=FALSE, warning=FALSE, message=FALSE, cache=F}
enough_samples = read.table("../../data/restricted/pcawg/CT_sufficient_samples.txt", comment.char='#')[,1]
nonexogenous = read.table("../../data/cosmic/exogenous_signatures_SBS.txt", sep = "\t",
                          comment.char = "#", fill = F)
subset_sigs_sparse_cov_idx_nonexo <- read.table("../../current/subset_sigs_sparse_cov_idx_nonexo.txt", stringsAsFactors = F, fill = T)
fles_roo <- list.files("../../data/roo/", full.names = T)

```

```{r, dimensionality_reduction, echo=FALSE}
signature_roo <- sapply(fles_roo[grepl('_signatures_', fles_roo)], readRDS)
signature_mutsigextractor_roo <- sapply(fles_roo[grepl('_signaturesmutSigExtractor_', fles_roo)], readRDS)

signature_roo <- sapply(signature_roo, function(i) try(slot(i, 'count_matrices_all')))
names(signature_roo) <- gsub("_signatures_ROO.RDS", "", basename(fles_roo[grepl('_signatures_', fles_roo)]))
signature_roo <- signature_roo[match(enough_samples, names(signature_roo))]
signature_roo <- signature_roo[sapply(signature_roo, typeof) == "list"]

signature_mutsigextractor_roo <- sapply(signature_mutsigextractor_roo, function(i) try(slot(i, 'count_matrices_all')))
names(signature_mutsigextractor_roo) <- gsub("_signaturesmutSigExtractor_ROO.RDS", "", basename(fles_roo[grepl('_signaturesmutSigExtractor_', fles_roo)]))
signature_mutsigextractor_roo <- signature_mutsigextractor_roo[match(enough_samples, names(signature_mutsigextractor_roo))]
signature_mutsigextractor_roo <- signature_mutsigextractor_roo[sapply(signature_mutsigextractor_roo, typeof) == "list"]


signature_roo_all <- do.call('rbind', lapply(signature_roo, function(i) rbind(i[[1]], i[[2]])))
signature_roo_all <- normalise_rw(signature_roo_all)
signature_roo_all_umap <- umap(signature_roo_all)

signature_roo_all_mutsigextractor <- do.call('rbind', lapply(signature_mutsigextractor_roo, function(i) rbind(i[[1]], i[[2]])))
signature_roo_all_mutsigextractor <- normalise_rw(signature_roo_all_mutsigextractor)
signature_roo_all_mutsigextractor_umap <- umap(signature_roo_all_mutsigextractor)


n <- length(signature_roo)
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
names(col_vector) = names(signature_roo)

ggplot(cbind.data.frame(umap=signature_roo_all_umap$layout[,1:2], ct=rep(names(signature_roo), unlist(sapply(signature_roo, function(i) nrow(i[[1]])*2)))),
     aes(x=umap.1, y=umap.2, col=ct))+facet_wrap(.~ct)+
  geom_point(data=do.call('rbind', lapply(names(signature_roo), function(i) cbind.data.frame(umap=signature_roo_all_umap$layout[,1:2], ct=i))),
             col='gray', alpha=0.2)+
  geom_point()+
  scale_color_manual(values = col_vector)+guides(col=FALSE)+theme_bw()+labs(x='UMAP dimension #1',
                                                                            y='UMAP dimension #2')
# ggsave("../../../results/exploratory/umap_exposures.pdf", height = 9, width = 9)


ggplot(cbind.data.frame(umap=signature_roo_all_mutsigextractor_umap$layout[,1:2], ct=rep(names(signature_mutsigextractor_roo), unlist(sapply(signature_mutsigextractor_roo, function(i) nrow(i[[1]])*2)))),
       aes(x=umap.1, y=umap.2, col=ct))+facet_wrap(.~ct)+
  geom_point(data=do.call('rbind', lapply(names(signature_mutsigextractor_roo), function(i) cbind.data.frame(umap=signature_roo_all_mutsigextractor_umap$layout[,1:2], ct=i))),
             col='gray', alpha=0.2)+
  geom_point()+
  scale_color_manual(values = col_vector)+guides(col=FALSE)+theme_bw()+labs(x='UMAP dimension #1',
                                                                            y='UMAP dimension #2')
# ggsave("../../../results/exploratory/umap_exposures_mutsigextractor.pdf", height = 9, width = 9)

```

```{r, read_tmb_runs, warning=FALSE, echo=FALSE, message=FALSE, error=FALSE, results='hide'}
diagRE_DMSL <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/diagRE_DMSL_", ct, "_signatures.RDS")))
}, simplify = F)

diagRE_DMDL <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/optim/diagRE_DM_", ct, "_signatures.RDS")))
}, simplify = F)

fullRE_DMDL <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/optim/fullRE_DM_", ct, "_signatures.RDS")))
}, simplify = F)

fullRE_M_nonexo <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullRE_nonexo_M_", ct, "_signatures.RDS")))
}, simplify = F)

fullRE_M <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/optim/fullRE_M_", ct, "_signatures.RDS")))
}, simplify = F)

diagRE_M <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/optim/diagRE_M_", ct, "_signatures.RDS")))
}, simplify = F)

sparseRE_DMSL <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/sparseRE_DMSL2_", ct, "_signatures.RDS")))
}, simplify = F)

fullRE_DMDL_nonexo <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fulLRE_nonexo_DM_", ct, "_signatures.RDS")))
}, simplify = F)

fullRE_DMDL_sortednonexo <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fulLRE_sortednonexo_DM_", ct, "_signatures.RDS")))
}, simplify = F)

fullRE_DMSL_nonexo <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullRE_nonexo_DMSL_", ct, "_signatures.RDS")))
}, simplify = F)

diagRE_DMSL_nonexo <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/diagRE_nonexo_DMSL_", ct, "_signatures.RDS")))
}, simplify = F)

fullRE_DMSL_SBS1 <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullRE_SBS1baseline_DMSL_", ct, "signatures.RDS")))
}, simplify = F)

fullRE_halfDM <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullRE_halfDM_", ct, "signatures.RDS")))
}, simplify = F)

fullRE_DMSL <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullRE_DMSL_", ct, "_signatures.RDS")))
}, simplify = F)

diagRE_DMSL <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/diagRE_DMSL_", ct, "_signatures.RDS")))
}, simplify = F)

sparseRE_DMSL_nonexo <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/sparseRE_nonexo_DMSL_", ct, "_signatures.RDS")))
}, simplify = F)

```

\newpage

\section{Information about models}

\subsection{Default order of categories for each model}
\begin{tabular}{llL{1.3in}l}
Name model & Extension & Sorted & File in which they were created\\\hline\hline
\verb|fullREDMsinglelambda| &	\verb|fullRE_DMSL_|	& Not sorted &	\verb|run_TMB_PCAWG.R|\\\hline
\verb|fullREDMsinglelambda2|	& \verb|fullRE_DMSL2_|	& Sorted	& \verb|run_TMB_PCAWG.R|\\\hline
\verb|diagREDMsinglelambda| & 	\verb|diagRE_DMSL_|	& Unknown	& \verb|run_TMB_PCAWG.R|\\\hline
\verb|fullRE_M|	& \verb|fullRE_M_| & Sorted in previous version of \verb|wrapper_run_TMB|& \verb|run_TMB_PCAWG.R|\\\hline
\verb|diagRE_DM|	& \verb|diagRE_DM_| & Sorted in previous version of \verb|wrapper_run_TMB|& \verb|run_TMB_PCAWG.R|\\\hline
\verb|fullRE_DM|	& \verb|fullRE_DM_| & Sorted in previous version of \verb|wrapper_run_TMB|& \verb|run_TMB_PCAWG.R|\\\hline
\verb|sparseRE_DMSL2|	& \verb|sparseRE_nonexo_DMSL_| & Sorted & 	\verb|find_subset_signatures.R|\\\hline
\verb|fullREDMsinglelambda| &	\verb|fullRE_nonexo_DMSL_| &	Not sorted &	\verb|find_subset_signatures.R| \\\hline
\verb|fullRE_M| &	\verb|fullRE_nonexo_M_|	& Not sorted &	\verb|find_subset_signatures.R| \\\hline
\verb|diagREDMsinglelambda|	& \verb|diagRE_nonexo_DMSL_| &	Not sorted &	\verb|find_subset_signatures.R| \\\hline
\verb|fullRE_DM| &	\verb|fulLRE_nonexo_DM_| &	Not sorted &	\verb|find_subset_signatures.R| \\\hline
\verb|diagREDMsinglelambda| &	\verb|diagRE_DMSL_| &	Not sorted &	\verb|find_subset_signatures.R|\\\hline
\verb|fullREDMsinglelambda| for SP &	\verb|fullREDMsinglelambda_..._signaturesPCAWG| &	Not sorted (it was commented out) &	\verb|run_TMB_PCAWG.R on 2 August|\\\hline
\verb|fullREM| for SP &	\verb|fullREM_..._signaturesPCAWG| &	Not sorted (it was commented out) &	\verb|run_TMB_PCAWG.R on 2 August|\\\hline
\end{tabular}

```{r, initialise_betas, echo=FALSE}
## for names of betas
colnames_all_sorted <- list()
logR_all_sorted <- list()
colnames_nonexo_sorted <- list()
logR_nonexo_sorted <- list()
colnames_nonexo_notsorted <- list()
logR_nonexo_notsorted <- list()
```


```{r, names_betas, echo=FALSE, warning=FALSE}

                                                                          for(ct in enough_samples){

  colnames_all_sorted[[ct]] <- colnames(sort_columns_TMB(load_PCAWG(ct = ct, typedata = "signatures",
                                     path_to_data = "../../data/"))$Y)
  logR_all_sorted[[ct]] <- vector_cats_to_logR(colnames_all_sorted[[ct]])
  colnames_nonexo_sorted[[ct]] <- colnames(sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                     path_to_data = "../../data/"), nonexogenous$V1))$Y)
  logR_nonexo_sorted[[ct]] <- vector_cats_to_logR(colnames_nonexo_sorted[[ct]])
  colnames_nonexo_notsorted[[ct]] <- colnames(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                     path_to_data = "../../data/"), nonexogenous$V1)$Y)
  logR_nonexo_notsorted[[ct]] <- vector_cats_to_logR(colnames_nonexo_notsorted[[ct]])
}
```

\section{General results of all models}
Check the results of all of the models

```{r, summary_convergence, dependson=c('read_tmb_runs'), fig.height=4.2, fig.width=7, echo=FALSE, dependson=c('read_tmb_runs')}
list_models <- c( 'diagRE_M', 'fullRE_M',
                  'diagRE_DMDL','fullRE_halfDM', 'fullRE_DMDL', 
                  'diagRE_DMSL','sparseRE_DMSL', 'fullRE_DMSL', 'fullRE_DMSL_SBS1',
                  'fullRE_M_nonexo','diagRE_DMSL_nonexo','sparseRE_DMSL_nonexo', 'fullRE_DMSL_nonexo',
                  'fullRE_DMDL_nonexo', 'fullRE_DMDL_sortednonexo')

all_summaries <- lapply(lapply(list_models, get), function(i){
    give_summary_of_runs2(i, long_return = T)})
names(all_summaries) <- list_models

ggplot(melt(all_summaries), aes(x=factor(L1, levels=list_models), y=value, fill=L2))+geom_tile()+
  theme(axis.text.x=element_text(angle = 45, hjust = 1, vjust=1))+
  # theme(legend.position = "bottom")+
  labs(x='')

```

\subsection{P-values for all cancer types}

```{r, all_pvals, echo=FALSE, results='hide', warning=FALSE, message=FALSE}
pvals_fullRE_M <- sapply(fullRE_M, function(i) try(wald_TMB_wrapper(i)))
pvals_fullRE_M <- p.adjust(pvals_fullRE_M)
pvals_diagRE_DM <- sapply(diagRE_DMSL, function(i) try(wald_TMB_wrapper(i)))
pvals_diagRE_DM <- p.adjust(pvals_diagRE_DM)
pvals_DM <- sapply(sparseRE_DMSL, function(i) try(wald_TMB_wrapper(i)))
pvals_DM <- p.adjust(pvals_DM)
pvals_DMnonexo <- sapply(sparseRE_DMSL_nonexo, function(i) try(wald_TMB_wrapper(i)))
pvals_DMnonexo <- p.adjust(pvals_DMnonexo)
```

```{r, all_pvals_analysis, echo=FALSE, results='hide', dependson=c('all_pvals')}
num_samples <- sapply(enough_samples, function(ct){
    .xx <- try(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures"),
                                       sigs_to_remove = unique(nonexogenous$V1)))
    try(nrow(.xx$Y)/2)
})
names(num_samples) <- enough_samples

```

```{r, all_pvals_analysis_plots, echo=FALSE, dependson=c('all_pvals_analysis'), warning=FALSE, fig.height=4}

grid.arrange(ggplot(cbind.data.frame(pvals_DM=pvals_DM, pvals_DMnonexo=pvals_DMnonexo,
                        num_samples=as.numeric(num_samples),
                        ct=enough_samples),
       aes(x=log(pvals_DM), y=log(pvals_DMnonexo), col=num_samples,
           label=ct))+geom_point()+
  geom_hline(yintercept = log(0.05))+geom_vline(xintercept = log(0.05))+
  geom_label_repel()+theme(legend.position = "bottom"),
ggplot(cbind.data.frame(pvals_DM=pvals_DM, pvals_DMnonexo=pvals_DMnonexo,
                        num_samples=as.numeric(num_samples),
                        ct=enough_samples),
       aes(x=(pvals_DM), y=(pvals_DMnonexo), col=num_samples,
           label=ct))+geom_point()+
  geom_hline(yintercept = (0.05))+geom_vline(xintercept = (0.05))+
  geom_label_repel()+theme(legend.position = "bottom"), ncol=2)

# 
# plot(pvals_fullRE_M, pvals_DM)
# 
```

```{r, all_pvals_analysis_plots_2, echo=FALSE, dependson=c('all_pvals_analysis'), warning=FALSE, fig.height=8,  dev='tikz'}

ggplot(cbind.data.frame(pvals_DM=pvals_DM, pvals_DMnonexo=pvals_DMnonexo,
                        num_samples=as.numeric(num_samples),
                        ct=enough_samples,
                        pvals_DM_censored=sapply(-log(pvals_DM),
                                                 function(i) min(i, 25)),
                        pvals_DMnonexo_censored=sapply(-log(pvals_DMnonexo), 
                                                       function(i) min(i, 25))),
       aes(x=pvals_DM_censored, y=pvals_DMnonexo_censored,
           size=num_samples, col=ct,
           label=ct))+geom_point()+
  geom_hline(yintercept = -log(0.05))+geom_vline(xintercept = -log(0.05))+
  geom_label_repel(size=3.2, alpha=0.6)+  theme_bw()+
  theme(legend.position = "bottom", legend.text=element_text(size=8))+
  labs(x='- Log p-value all signatures', y='- Log p-value nonexogenous signatures')+
  guides(size=FALSE, col=guide_legend(ncol=4))

```

\subsection{All betas with SBS1 as baseline}
```{r, SBS1_betas, echo=FALSE, warning=FALSE, message=FALSE, results='hide',fig.height=6,  dev='tikz'}
fullRE_DMSL_SBS1_betas <- lapply(fullRE_DMSL_SBS1, function(i){
  .x <- try(give_betas(i)[2,])
  if((typeof(.x) == 'character')){
    .x <- NA
  }else{
    .sum_i = summary(i)
    .x <- t(python_like_select_rownames(.sum_i, 'beta')[c(F,T),])
  }
  .x
})
for(i in 1:length(fullRE_DMSL_SBS1)){
  if(!(typeof(fullRE_DMSL_SBS1[[i]]) == 'character')){
    .nmes <- colnames(sort_columns_TMB_SBS1(load_PCAWG(ct = enough_samples[i], typedata = "signatures", path_to_data = "../../data/"))$Y)
    colnames(fullRE_DMSL_SBS1_betas[[i]]) = paste0(.nmes[-length(.nmes)], '/', .nmes[length(.nmes)])
      
  }
}

fullRE_DMSL_SBS1_betas_all <- lapply(1:length(fullRE_DMSL_SBS1_betas), function(i) try(data.frame(ct=names(fullRE_DMSL_SBS1_betas[i]), beta=t(fullRE_DMSL_SBS1_betas[[i]]),
                                                                                                               logR=colnames(fullRE_DMSL_SBS1_betas[[i]]))))
fullRE_DMSL_SBS1_betas_all <- do.call('rbind', fullRE_DMSL_SBS1_betas_all[sapply(fullRE_DMSL_SBS1_betas_all, typeof) == 'list'])

# fullRE_DMSL_SBS1_betas_all[!grepl("/SBS1$", fullRE_DMSL_SBS1_betas_all$logR),]
## select only those with SBS1 as baseline
fullRE_DMSL_SBS1_betas_all <- fullRE_DMSL_SBS1_betas_all[grepl("/SBS1$", fullRE_DMSL_SBS1_betas_all$logR),]

fullRE_DMSL_SBS1_betas_all$phHess <- sapply(fullRE_DMSL_SBS1, function(i) try(i$pdHess))[match(fullRE_DMSL_SBS1_betas_all$ct, names(fullRE_DMSL_SBS1))]

```

```{r, SBS1_betas_plots, echo=FALSE, warning=FALSE, message=FALSE, fig.height=12, fig.width=9,  dev='tikz'}

fullRE_DMSL_SBS1_betas_all$row_idx = factor(paste0(substr(fullRE_DMSL_SBS1_betas_all$ct, 1, 1) < 'h', substr(fullRE_DMSL_SBS1_betas_all$ct, 1, 1) < 'p'))
table(fullRE_DMSL_SBS1_betas_all$row_idx)
ggplot(fullRE_DMSL_SBS1_betas_all, aes(x=ct, col=logR, y=beta.Estimate))+geom_point()+
  facet_grid(rows=vars(row_idx), cols=vars(logR), scales = "free_x", space = "free_x")+ # scales = "free_x", space = "free_x",
  geom_errorbar(aes(ymin=`beta.Estimate`-`beta.Std..Error`, ymax=`beta.Estimate`+`beta.Std..Error`), width=.1)+
  geom_hline(yintercept = 0, col='blue', lty='dashed')+
  theme(axis.text.x = element_text(angle = 25, vjust = 1.0, hjust=1), legend.position = "bottom")+
  guides(col=FALSE)
```

```{r, SBS1_betas_plotsb, echo=FALSE, warning=FALSE, message=FALSE, fig.height=9, fig.width=9,  dev='tikz'}

sort_with_letters <- function(i){
  .order <- order(as.numeric(gsub("[a-z]", "", i)))
  i[.order]
}

multiple_obs_SBS1_betas <- fullRE_DMSL_SBS1_betas_all %>% dplyr::select(logR) %>% table > 3
ggplot(fullRE_DMSL_SBS1_betas_all %>% filter(logR %in% names(multiple_obs_SBS1_betas[multiple_obs_SBS1_betas])),
       aes(x=ct,
           col=ct, y=beta.Estimate))+geom_point()+
  facet_wrap(.~factor(logR, levels=paste0('SBS', sort_with_letters(unique(gsub('SBS', '', gsub('/.*', '', logR)))), '/SBS1')), scales = "free_x", nrow=4)+
  geom_errorbar(aes(ymin=`beta.Estimate`-`beta.Std..Error`, ymax=`beta.Estimate`+`beta.Std..Error`), width=.1)+
  geom_hline(yintercept = 0, col='blue', lty='dashed')+
  theme_bw()+
  theme(#axis.text.x = element_text(angle = 45, vjust = 1.0, hjust=1),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(), legend.position = "bottom",
        text = element_text(size=20), legend.text=element_text(size=8))
  
ggplot(fullRE_DMSL_SBS1_betas_all %>% filter(logR %in% names(multiple_obs_SBS1_betas[multiple_obs_SBS1_betas])),
       aes(x=ct,
           col=ct, y=beta.Estimate))+geom_point()+
  facet_wrap(.~logR, scales = "free_x", nrow=4)+
  geom_errorbar(aes(ymin=`beta.Estimate`-`beta.Std..Error`, ymax=`beta.Estimate`+`beta.Std..Error`), width=.1)+
  geom_hline(yintercept = 0, col='blue', lty='dashed')+
  theme_bw()+
  theme(#axis.text.x = element_text(angle = 45, vjust = 1.0, hjust=1),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(), legend.position = "bottom",
        text = element_text(size=20), legend.text=element_text(size=8))
  
# ggsave("../../../results/results_TMB/pcawg/all_betas_all_ct.pdf", width = 25, height = 15)
```

```{r, SBS1_betas_plots2, echo=FALSE, warning=FALSE, message=FALSE, fig.height=10, fig.width=8,  dev='tikz'}

fullRE_DMSL_SBS1_betas_all$exogenous = (gsub("/.*", "", fullRE_DMSL_SBS1_betas_all$logR) %in% nonexogenous$V1)
ggplot(fullRE_DMSL_SBS1_betas_all, aes(x=logR, y=beta.Estimate, col=exogenous))+geom_point()+
  facet_wrap(.~ct, scales = "free_x", nrow=5)+
  geom_errorbar(aes(ymin=`beta.Estimate`-`beta.Std..Error`, ymax=`beta.Estimate`+`beta.Std..Error`), width=.1)+
  geom_hline(yintercept = 0, col='blue', lty='dashed')+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 45, vjust = 1.0, hjust=1))
# ggsave("../../../results/results_TMB/pcawg/all_betas_all_ct_byct.pdf", width = 12, height = 12)
```
\newpage


How many signatures so we have in total and how many nonexogenous ones?
```{r, num_cats_sigs, echo=FALSE, warning=FALSE, message=FALSE,  dev='tikz'}
signature_roo0 <- sapply(fles_roo[grepl('_signatures_', fles_roo)], readRDS)
signature_roo_active <- sapply(signature_roo0, function(i) try(slot(i, 'count_matrices_active')))
names(signature_roo_active) <- gsub("_signatures_ROO.RDS", "", basename(fles_roo[grepl('_signatures_', fles_roo)]))

num_cats_nonexo <- lapply(names(signature_roo_active), function(j){
  .nonexoncol <- try(ncol(signature_roo_active[[j]][[1]][,!(colnames(signature_roo_active[[j]][[1]]) %in% nonexogenous$V1)]))
  try(c(ifelse(is.null(ncol(signature_roo_active[[j]][[1]])), yes = NA, no = ncol(signature_roo_active[[j]][[1]])),
        ifelse(is.null(.nonexoncol), NA, .nonexoncol)))})
names(num_cats_nonexo) <- names(signature_roo_active)
num_cats_nonexo <- num_cats_nonexo[ (typeof(num_cats_nonexo) != "character") & sapply(num_cats_nonexo, function(i) typeof(i[[1]]) != "character")]
ggplot(cbind.data.frame(ct=names(num_cats_nonexo),
                      do.call('rbind', num_cats_nonexo)), aes(x=`1`, y=`2`, label=ct))+
  geom_abline(slope = 1, intercept = 0, lty='dashed')+
  geom_point()+
  geom_label_repel(size=3)+labs(x='Number of active signatures', y='Number of nonexogenous active signatures')+theme_bw()
```


\section{Analysis per cancer type}

\subsection{Bone osteosarcoma}

\subsubsection{Barplot and general statistics}
```{r BoneOsteosarc1, echo=FALSE}
ct <- "Bone-Osteosarc"
obj_Bone_Osteosarc <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Bone_Osteosarc, legend_on = TRUE, verbose=F)
```

The number of samples and signatures is:
```{r BoneOsteosarc1b, echo=FALSE}
dim(obj_Bone_Osteosarc$Y)
```

The signatures are:
```{r BoneOsteosarc1c, echo=FALSE}
colnames(obj_Bone_Osteosarc$Y)
```

\subsubsection{Convergence table}

We only have converged results for the multinomial with full RE, and the DM with a single lambda (diag and full RE). It is the same for nonexogenous signatures.

```{r BoneOsteosarc2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Bone-Osteosarc"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}

```{r BoneOsteosarc3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
ct <- "Bone-Osteosarc"

obj <- sort_columns_TMB(load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/"))
sortedM <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj)
sortedM

## use params from ME M for ME DM
dmin1 <- ncol(obj$Y)-1

sortedDM <- wrapper_run_TMB(model = "fullRE_DM",
                           object = obj,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM$par.fixed, 'cov_par_RE'),
                             log_lambda = matrix(c(2,2))))
sortedDM

```

If we use the values of the fullRE M as initial values for the fullRE DM, we also don't get convergence:
```{r BoneOsteosarc3b, echo=FALSE, message=FALSE, dependson=c('BoneOsteosarc3')}
sortedDM$pdHess
```

\subsubsection{Potentially problematic signatures}

We notice that we have several signatures with low exposures, and many zero exposures
```{r, BoneOsteosarc1d}
colSums(obj_Bone_Osteosarc$Y == 0)/nrow(obj_Bone_Osteosarc$Y)
colSums(obj_Bone_Osteosarc$Y)/sum(obj_Bone_Osteosarc$Y)
```

E.g.

\begin{itemize}
\item SBS17b is 0 in `r round( (colSums(obj_Bone_Osteosarc$Y == 0)/nrow(obj_Bone_Osteosarc$Y))['SBS17b'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Bone_Osteosarc$Y)/sum(obj_Bone_Osteosarc$Y))['SBS17b'], digits=3)*100`\%
\item SBS30 is 0 in `r round( (colSums(obj_Bone_Osteosarc$Y == 0)/nrow(obj_Bone_Osteosarc$Y))['SBS30'], digits=3)*100`\% of cases and overal has an exposure of only `r round((colSums(obj_Bone_Osteosarc$Y)/sum(obj_Bone_Osteosarc$Y))['SBS30'], digits=3)*100`\%
\item SBS5 is 0 in `r round( (colSums(obj_Bone_Osteosarc$Y == 0)/nrow(obj_Bone_Osteosarc$Y))['SBS5'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Bone_Osteosarc$Y)/sum(obj_Bone_Osteosarc$Y))['SBS5'], digits=3)*100`\%
\end{itemize}

\subsubsection{Betas}

```{r, BoneOsteosarc_betas, echo=FALSE, fig.height=3.5}
ct <- "Bone-Osteosarc"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
             plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
             plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
             plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]],
names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]],
names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
  plot_betas(diagRE_DMSL_nonexo[[ct]],
names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')), nrow=2)
```


```{r, BoneOsteosarc_DA, echo=FALSE, message=FALSE, results='hide'}
pval_bone_osteosarc <- wald_TMB_wrapper(diagRE_DMSL_nonexo[["Bone-Osteosarc"]])
```
We use the results from the diagonal single lambda DM to test for differential abundance, giving a p-value of `r pval_bone_osteosarc`.

\clearpage
\subsubsection{Covariance matrices}

```{r, echo=FALSE}
ct <- "Bone-Osteosarc"
additional_sortedM <- list()
additional_sortedDM <- list()
additional_sortedM[[ct]] <- sortedM
additional_sortedDM[[ct]] <- sortedDM
```

Note that sortedDM did not convergence.

Nevertheless, both versions of fullRE M -- both of which converged and use the same baseline -- give very different covariances matrices.

```{r, BoneOsteosarc_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7}

ct <- "Bone-Osteosarc"
# models_it_bone_osteosarc <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_bone_osteosarc <- c('fullRE_M', 'fullRE_M_nonexo', 'additional_sortedM', 'additional_sortedDM')
covmats_bone_osteosarc <- lapply(models_it_bone_osteosarc,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_bone_osteosarc) <- models_it_bone_osteosarc
## because it's fullRE_M, it's sorted
colnames(covmats_bone_osteosarc[['fullRE_M']]) <- rownames(covmats_bone_osteosarc[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Bone_Osteosarc)$Y))
colnames(covmats_bone_osteosarc[['additional_sortedM']]) <- rownames(covmats_bone_osteosarc[['additional_sortedM']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Bone_Osteosarc)$Y))
colnames(covmats_bone_osteosarc[['additional_sortedDM']]) <- rownames(covmats_bone_osteosarc[['additional_sortedDM']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Bone_Osteosarc)$Y))
## because it's fullRE_M_nonexo, it's not sorted
colnames(covmats_bone_osteosarc[['fullRE_M_nonexo']]) <- rownames(covmats_bone_osteosarc[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Bone_Osteosarc, nonexogenous$V1)$Y))

for(i in 1:length(covmats_bone_osteosarc)){pheatmap(covmats_bone_osteosarc[[i]], cluster_rows = F, cluster_cols = F, main = models_it_bone_osteosarc[i])}

```

\subsubsection{Simulation under inferred data}
Simulating with diagRE DMSL nonexo.

```{r, create_obj_Bone_Osteosarc_nonexo, echo=FALSE}
## not sorting columns because they were not sorted
obj_Bone_Osteosarc_nonexo <- give_subset_sigs_TMBobj(load_PCAWG(ct = ct,
typedata = "signatures",path_to_data = "../../data/"), sigs_to_remove= nonexogenous$V1)
```

```{r, BoneOsteosarc_sim, echo=FALSE, fig.height=3.5, fig.width=4.5}
sim_Bone_Osteosarc <- give_sim_from_estimates("Bone-Osteosarc", "signatures",
                                              sigs_to_remove=unique(nonexogenous$V1),
                                              bool_give_PCA = T, path_to_data= "../../data/",
                                              model="diagRE_DMSL", bool_nonexo = T,
                                              obj_data=obj_Bone_Osteosarc_nonexo,
                                              tmb_object=diagRE_DMSL_nonexo[["Bone-Osteosarc"]])

sim_Bone_Osteosarc[[2]]+ggtitle('Simulation of Bone osteosarcoma samples')

```

\subsubsection{Ranked plot for coverage}

Note that fullRE DMSL nonexo has not converged!

```{r, BoneOsteosarc_ranked_plot, echo=FALSE, fig.height=3.5, fig.width=7, dev='png'}
ct <- "Bone-Osteosarc"
integer_overdispersion_param_DMSL <- 1
# obj_Bone_Osteosarc_nonexo <- give_subset_sigs_TMBobj(obj_Bone_Osteosarc, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Bone_Osteosarc_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Bone_Osteosarc_nonexo,
                 loglog = F, title = 'obj_Bone_Osteosarc\n (M nonexo)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_Bone_Osteosarc_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Bone_Osteosarc_nonexo,
                 loglog = F, title = 'obj_Bone_Osteosarc\n (DMSL nonexo)'), ncol=2)
```

73/359=20\% of values are not included in the confidence interval of the DMSL.

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are a bit more chaotic:
```{r, BoneOsteosarc_mutsigextractor, echo=FALSE, fig.height=4, warning=FALSE}
obj_Bone_Osteosarc_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Bone_Osteosarc_mutSigExtractor, legend_on = FALSE, verbose=F)
```

Exposures sorted by increasing number of mutations: there is no trend

```{r, BoneOsteosarc_sortedbynummuts, echo=FALSE, fig.height=2, fig.width=3}
createBarplot(normalise_rw(non_duplicated_rows(obj_Bone_Osteosarc$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Bone_Osteosarc$Y)),
                                        decreasing = F)), remove_labels=T, verbose=F)+
  theme(legend.position = "bottom")
```

\clearpage
\subsubsection{Correlations of signatures}

```{r, BoneOsteosarc_correlations, echo=FALSE, fig.height=3.5}

BoneOsteosarc_correlations_df <- rbind.data.frame(
  cbind.data.frame(melt(give_all_correlations(obj_Bone_Osteosarc_nonexo$Y)), dataset='Observed nonexo'),
  cbind.data.frame(melt(give_all_correlations(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[["Bone-Osteosarc"]],
                 data_object = obj_Bone_Osteosarc_nonexo,
                 print_plot = F, nreps = 2, model = "M")[[1]])), dataset='fullRE M nonexo'),
cbind.data.frame(melt(give_all_correlations(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[["Bone-Osteosarc"]],
                 data_object = obj_Bone_Osteosarc_nonexo,
                 print_plot = F, nreps = 2, model = "DMSL", integer_overdispersion_param=1)[[1]])), dataset='diagRE DMSL nonexo'))

```

```{r, BoneOsteosarc_correlations_norm, echo=FALSE, fig.height=3.5}

BoneOsteosarc_correlations_df_normalise_rw <- rbind.data.frame(
  cbind.data.frame(melt(give_all_correlations(normalise_rw(obj_Bone_Osteosarc_nonexo$Y))), dataset='Observed nonexo'),
  cbind.data.frame(melt(give_all_correlations(normalise_rw(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[["Bone-Osteosarc"]],
                 data_object = obj_Bone_Osteosarc_nonexo,
                 print_plot = F, nreps = 2, model = "M")[[1]]))), dataset='fullRE M nonexo'),
cbind.data.frame(melt(give_all_correlations(normalise_rw(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[["Bone-Osteosarc"]],
                 data_object = obj_Bone_Osteosarc_nonexo,
                 print_plot = F, nreps = 2, model = "DMSL", integer_overdispersion_param=1)[[1]]))), dataset='diagRE DMSL nonexo'))

```

```{r, BoneOsteosarc_correlations_2, echo=FALSE, fig.height=3.5,  dev='tikz',  dependson=c('BoneOsteosarc_correlations', 'BoneOsteosarc_correlations_norm')}

BoneOsteosarc_correlations_df_both <- rbind.data.frame(cbind.data.frame(BoneOsteosarc_correlations_df, normalisation_bool='Raw exposures'),
                                                       cbind.data.frame(BoneOsteosarc_correlations_df_normalise_rw, normalisation_bool='Normalised exposures'))

ggplot(BoneOsteosarc_correlations_df_both, aes(x=value, col=dataset))+geom_density()+
  # ggtitle('Correlations of fitted values (Bone Osteosarcoma))')+
  theme_bw()+
  theme(legend.position = "bottom")+
  labs(x='Correlations of fitted values')+
  scale_color_manual(name = "Dataset",values = c('red', 'blue', 'green'))+
  facet_wrap(.~normalisation_bool)
```

\clearpage
\subsection{Breast-AdenoCA}
\subsubsection{Barplot and general statistics}
```{r BreastAdenoCA1, echo=FALSE}
obj_Breast_AdenoCA <- load_PCAWG(ct = "Breast-AdenoCA", typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Breast_AdenoCA, legend_on = TRUE, verbose=F)
```

There are many signatures, and also many samples.


The number of samples and signatures is:
```{r BreastAdenoCA1b, echo=FALSE}
dim(obj_Breast_AdenoCA$Y)
```

The signatures are:
```{r BreastAdenoCA1c, echo=FALSE}
colnames(obj_Breast_AdenoCA$Y)
```

\subsubsection{Convergence table}

We only have converged results for the diagRE_DMSL, with diagonal or sparse covariance structure, and diagonal M.
 This is probably due to the very high number of signatures, which make it impossible to infer the whole covariance structure.

```{r BreastAdenoCA2, echo=FALSE, dependson=c('summary_convergence')}
melt(all_summaries) %>% filter(value=="Breast-AdenoCA")
```

\subsubsection{Re-running of fitting}

```{r obj_Breast_AdenoCA3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
ct <- "Breast-AdenoCA"

obj_Breast_Adeno_sorted <- sort_columns_TMB(load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/"))
sortedM_Breast_Adeno <- wrapper_run_TMB(model = "diagRE_M",
                           object = obj_Breast_Adeno_sorted)
sortedM_Breast_Adeno

## use params from diagME M for diagME DM
sortedDM_Breast_Adeno <- wrapper_run_TMB(model = "diagRE_DM",
                           object = obj_Breast_Adeno_sorted,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_Breast_Adeno$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_Breast_Adeno$par.random, ncol=ncol(obj_Breast_Adeno_sorted$Y)-1),
                             logs_sd_RE=python_like_select_name(sortedM_Breast_Adeno$par.fixed, 'logs_sd_RE'),
                             log_lambda = matrix(c(2,2))))
sortedDM_Breast_Adeno
```

If we use the values of the diagRE M as initial values for the diagRE DM, we that it has converged. This is probably due to a combination of things: we are using the optimiser nlminb (better in general than the alternative, optim) and we are starting with these - better - values, and we are sorting the columns so that the category with highest total value is the baseline.
```{r obj_Breast_AdenoCA3b, echo=FALSE, message=FALSE, dependson=c('BoneOsteosarc3')}
sortedDM_Breast_Adeno$pdHess
```


```{r, echo=FALSE}
ct <- "Breast-AdenoCA"
additional_sorteddiagM <- list()
additional_sorteddiagDM <- list()
additional_sorteddiagM[[ct]] <- sortedM_Breast_Adeno
additional_sorteddiagDM[[ct]] <- sortedDM_Breast_Adeno
```

\subsubsection{Potentially problematic signatures}

We notice that we have several signatures with low exposures, and many zero exposures
```{r, obj_Breast_AdenoCA3d}
colSums(obj_Breast_AdenoCA$Y == 0)/nrow(obj_Breast_AdenoCA$Y)
colSums(obj_Breast_AdenoCA$Y)/sum(obj_Breast_AdenoCA$Y)
```

E.g.

\begin{itemize}
\item SBS9 is 0 in `r round( (colSums(obj_Breast_AdenoCA$Y == 0)/nrow(obj_Breast_AdenoCA$Y))['SBS9'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Breast_AdenoCA$Y)/sum(obj_Breast_AdenoCA$Y))['SBS9'], digits=3)*100`\%
\item SBS12 is 0 in `r round( (colSums(obj_Breast_AdenoCA$Y == 0)/nrow(obj_Breast_AdenoCA$Y))['SBS12'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Breast_AdenoCA$Y)/sum(obj_Breast_AdenoCA$Y))['SBS12'], digits=3)*100`\%
\item SBS17a is 0 in `r round( (colSums(obj_Breast_AdenoCA$Y == 0)/nrow(obj_Breast_AdenoCA$Y))['SBS17a'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Breast_AdenoCA$Y)/sum(obj_Breast_AdenoCA$Y))['SBS17a'], digits=3)*100`\%
\item SBS17b is 0 in `r round( (colSums(obj_Breast_AdenoCA$Y == 0)/nrow(obj_Breast_AdenoCA$Y))['SBS17b'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Breast_AdenoCA$Y)/sum(obj_Breast_AdenoCA$Y))['SBS17b'], digits=3)*100`\%
\item SBS37 is 0 in `r round( (colSums(obj_Breast_AdenoCA$Y == 0)/nrow(obj_Breast_AdenoCA$Y))['SBS37'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Breast_AdenoCA$Y)/sum(obj_Breast_AdenoCA$Y))['SBS37'], digits=3)*100`\%
\item SBS39 is 0 in `r round( (colSums(obj_Breast_AdenoCA$Y == 0)/nrow(obj_Breast_AdenoCA$Y))['SBS39'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Breast_AdenoCA$Y)/sum(obj_Breast_AdenoCA$Y))['SBS39'], digits=3)*100`\%
\end{itemize}

<!-- \clearpage -->
\subsubsection{Betas}

```{r, Breast_AdenoCA_betas, echo=FALSE, fig.height=10, warning=FALSE}
ct <- "Breast-AdenoCA"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')),
plot_betas(additional_sorteddiagM[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n additional_sorteddiagM')),
plot_betas(additional_sorteddiagDM[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n additional_sorteddiagDM')),
  plot_betas(fullRE_M_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
  plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
  plot_betas(sparseRE_DMSL_nonexo[[ct]], names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=5)

```

```{r, Breast_AdenoCA_betasb, echo=FALSE, fig.height=4, eval=FALSE}
ct <- "Breast-AdenoCA"
betas_breast_AdenoCA_sparseRE_DMSL_nonexo <- python_like_select_rownames(summary(sparseRE_DMSL_nonexo[[ct]]), 'beta')
rownames(betas_breast_AdenoCA_sparseRE_DMSL_nonexo) <- rep(vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Breast_AdenoCA, sigs_to_remove = nonexogenous$V1)$Y)), each=2)
ggplot(cbind(melt(betas_breast_AdenoCA_sparseRE_DMSL_nonexo),
             group=c('Intercept', 'Slope')) %>% filter(Var2=='Estimate', group=='Slope'), aes(x=Var1, y=value))+
  geom_hline(yintercept = 0, lty='dashed', col='blue')+geom_point()+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
```

```{r, Breast_AdenoCA_betasbdiag, echo=FALSE, ,fig.height=3, fig.width=4.5, eval=TRUE, dev='tikz'}
plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, 'Breast adenocarcinoma\n diagRE DMSL non-exogenous'))
```

```{r, Breast_AdenoCA_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Breast-AdenoCA"
pval_Breast_AdenoCA <- wald_TMB_wrapper(diagRE_DMSL_nonexo[[ct]])
```
We use the results from the diagonal single lambda DM to test for differential abundance, giving a p-value of `r pval_Breast_AdenoCA`.



\subsubsection{Covariance matrices}

```{r, Breast_AdenoCA_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7}

ct <- "Breast-AdenoCA"
models_it_Breast_AdenoCA <- c('fullRE_M', 'fullRE_M_nonexo')
covmats_Breast_AdenoCA <- lapply(models_it_Breast_AdenoCA,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Breast_AdenoCA) <- models_it_Breast_AdenoCA
## because it's fullRE_M, it's sorted
colnames(covmats_Breast_AdenoCA[['fullRE_M']]) <- rownames(covmats_Breast_AdenoCA[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Breast_AdenoCA)$Y))
## because it's fullRE_M_nonexo, it's sorted
colnames(covmats_Breast_AdenoCA[['fullRE_M_nonexo']]) <- rownames(covmats_Breast_AdenoCA[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Breast_AdenoCA, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Breast_AdenoCA)){pheatmap(covmats_Breast_AdenoCA[[i]], cluster_rows = F, cluster_cols = F, main = models_it_bone_osteosarc[i])}
```

\subsubsection{Simulation under inferred data}

```{r, Breast_AdenoCA_objnonexo, echo=FALSE}

obj_Breast_AdenoCA_nonexo <- give_subset_sigs_TMBobj(obj_Breast_AdenoCA, sigs_to_remove = nonexogenous$V1)
```

Sorting the object as we are using sparseRE_DM.
```{r, Breast_AdenoCA_sim, echo=FALSE, fig.height=3}
sim_Breast_AdenoCA <- give_sim_from_estimates("Breast-AdenoCA", "signatures",
                                              sigs_to_remove=unique(nonexogenous$V1),
                                              bool_give_PCA = T, path_to_data= "../../data/",
                                            obj_data=sort_columns_TMB(obj_Breast_AdenoCA_nonexo),
                                              bool_nonexo=T,
                                              model="sparseRE_DM", nrow_pca_plot=1)
sim_Breast_AdenoCA[[2]]+ggtitle('Simulation of Breast Adenocarcinoma samples')+theme_bw()

```

\subsubsection{Ranked plot for coverage}

```{r, Breast_AdenoCA_ranked_plot, echo=FALSE, warning=FALSE, dev='png'}
ct <- "Breast-AdenoCA"
integer_overdispersion_param_DMSL <- 1

for(loglog_it in c(T,F)){
  grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Breast_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Breast_AdenoCA_nonexo,
                 loglog = loglog_it, title = 'Breast_AdenoCA_nonexo (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_Breast_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Breast_AdenoCA_nonexo,
                 loglog = loglog_it, title = 'Breast_AdenoCA_nonexo (DMSL)'), ncol=2)
}
```


\subsubsection{Signatures from mutSigExtractor}

```{r, Breast_AdenoCA_mutsigextractor, echo=FALSE, warning=FALSE}
obj_Breast_AdenoCA_mutSigExtractor <- load_PCAWG(ct = "Breast-AdenoCA",
                                                 typedata = "signaturesmutSigExtractor",
                                                 path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Breast_AdenoCA_mutSigExtractor, legend_on = FALSE,
                      verbose=F)
```


\clearpage
\subsection{Cervix-SCC}

\subsubsection{Barplot and general statistics}
```{r Cervix_SCC1, echo=FALSE, echo=FALSE, fig.height=1.5, warning=FALSE}
ct <- "Cervix-SCC"
obj_Cervix_SCC <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Cervix_SCC, legend_on = F, verbose=F, nrow_plot=1)
```

The number of samples and signatures is:
```{r Cervix_SCC1b, echo=FALSE}
dim(obj_Cervix_SCC$Y)
```

The signatures are:
```{r Cervix_SCC1c, echo=FALSE}
colnames(obj_Cervix_SCC$Y)
```

\subsubsection{Convergence table}


```{r Cervix_SCC2, echo=FALSE, dependson=c('summary_convergence')}
melt(all_summaries) %>% filter(value=="Cervix-SCC")
```


\subsubsection{Potentially problematic signatures}

SBS33 is a potentially problematic signature, being 0 in `r round( (colSums(obj_Cervix_SCC$Y == 0)/nrow(obj_Cervix_SCC$Y))['SBS33'], digits=3)*100`\% of cases and with an overall exposure of `r round((colSums(obj_Cervix_SCC$Y)/sum(obj_Cervix_SCC$Y))['SBS33'], digits=3)*100`\%.

```{r, Cervix_SCC1d}
colSums(obj_Cervix_SCC$Y == 0)/nrow(obj_Cervix_SCC$Y)
colSums(obj_Cervix_SCC$Y)/sum(obj_Cervix_SCC$Y)
```

\subsubsection{Betas}

```{r, Cervix_SCC_betas, echo=FALSE, warning=FALSE}
ct <- "Cervix-SCC"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]], theme_bw=T)+ggtitle(paste0(ct, '\n diagRE_M')),
             plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]], theme_bw=T)+ggtitle(paste0(ct, '\n fullRE_DMSL')),
             plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]], theme_bw=T)+ggtitle(paste0(ct, '\n diagRE_DMSL')),
             plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]], theme_bw=T)+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]], theme_bw=T)+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]], theme_bw=T)+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
  plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]], theme_bw=T)+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
  plot_betas(sparseRE_DMSL_nonexo[[ct]], names_cats = logR_nonexo_sorted[[ct]], theme_bw=T)+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```

```{r, Cervix_SCC_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Cervix_SCC <- wald_TMB_wrapper(fullRE_DMSL_nonexo[["Cervix-SCC"]])
```
We use the results from the fullRE single lambda DM to test for differential abundance, giving a p-value of `r pval_bone_osteosarc`.

\subsubsection{Covariance matrices}


```{r, Cervix_SCC_cov, echo=FALSE, message=FALSE, fig.height=2.7, fig.width=2.7}

ct <- "Cervix-SCC"

models_it_bone_Cervix_SCC <- c('fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_bone_Cervix_SCC <- lapply(models_it_bone_Cervix_SCC,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_bone_Cervix_SCC) <- models_it_bone_Cervix_SCC
## because it's fullRE_M_nonexo, it's not sorted
colnames(covmats_bone_Cervix_SCC[['fullRE_M_nonexo']]) <- rownames(covmats_bone_Cervix_SCC[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Cervix_SCC, nonexogenous$V1)$Y))
## because it's fullRE_DMSL_nonexo, it's sorted
colnames(covmats_bone_Cervix_SCC[['fullRE_DMSL_nonexo']]) <- rownames(covmats_bone_Cervix_SCC[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Cervix_SCC, nonexogenous$V1)$Y))

for(i in 1:length(covmats_bone_Cervix_SCC)){pheatmap(covmats_bone_Cervix_SCC[[i]], cluster_rows = F, cluster_cols = F, main = models_it_bone_Cervix_SCC[i])}
```

\subsubsection{Simulation under inferred data}

```{r, Cervix_SCC_obj, echo=FALSE}
obj_Cervix_SCC_nonexo <- give_subset_sigs_TMBobj(obj_Cervix_SCC, sigs_to_remove = nonexogenous$V1)
obj_Cervix_SCC_nonexo_sorted <- sort_columns_TMB(give_subset_sigs_TMBobj(obj_Cervix_SCC, sigs_to_remove = nonexogenous$V1))
```

We are usaing the sorted version of the exposures, as we are using sparseRE DMSL.

```{r, Cervix_SCC_sim, echo=FALSE, fig.height=3.5}
sim_Cervix_SCC <- give_sim_from_estimates( "Cervix-SCC", "signatures", 
                                          sigs_to_remove=unique(nonexogenous$V1),
                                          bool_give_PCA = T, path_to_data= NA,
                                          sig_of_interest = "SBS2",
                                          obj_data=obj_Cervix_SCC_nonexo_sorted,
                                          model="sparseRE_DM", bool_nonexo=T,
                                          nrow_pca_plot=1)

sim_Cervix_SCC[[2]]+ggtitle('Simulation of Cervix SCC samples')+theme_bw()

```

Comparison of the estimated covariance matrix and the closest positive semidefinite matrix.

```{r, Cervix_SCC_cov_mat_sparse}
ct <- "Cervix-SCC"

dmin1_Cervix_SCC_cov_mat_sparse <- length(python_like_select_name(sparseRE_DMSL_nonexo[[ct]]$par.fixed, 'logs_sd_RE'))

cov_vec_Cervix_SCC_cov_mat_sparse = rep(0, (dmin1_Cervix_SCC_cov_mat_sparse**2-dmin1_Cervix_SCC_cov_mat_sparse)/2)
cov_vec_Cervix_SCC_cov_mat_sparse[as.numeric(strsplit(subset_sigs_sparse_cov_idx_nonexo[subset_sigs_sparse_cov_idx_nonexo$V1 == ct,"V2"], ',')[[1]])] = python_like_select_name(sparseRE_DMSL_nonexo[[ct]]$par.fixed, 'cov_RE_part')

cov_mat_Cervix_SCC <- fill_covariance_matrix(arg_d = dmin1_Cervix_SCC_cov_mat_sparse,
                                    arg_entries_var =  exp(python_like_select_name(sparseRE_DMSL_nonexo[[ct]]$par.fixed, 'logs_sd_RE')),
                                    arg_entries_cov = cov_vec_Cervix_SCC_cov_mat_sparse)

cov_mat_Cervix_SCC

Matrix::nearPD(cov_mat_Cervix_SCC)
```

Now with fullRE M:
```{r, Cervix_SCC_sim_M, echo=FALSE, fig.height=3.5}
sim_Cervix_SCC <- give_sim_from_estimates( "Cervix-SCC", "signatures", 
                                          sigs_to_remove=unique(nonexogenous$V1),
                                          bool_give_PCA = T, path_to_data= NA,
                                          sig_of_interest = "SBS2",
                                          obj_data=obj_Cervix_SCC_nonexo,
                                          model="fullRE_M", bool_nonexo=T,
                                          nrow_pca_plot=1)

sim_Cervix_SCC[[2]]+ggtitle('Simulation of Cervix SCC samples')+theme_bw()

```

\subsubsection{Ranked plot for coverage}

```{r, Cervix_SCC_ranked_plot, echo=FALSE, fig.height=3.5, dev='png'}
ct <- "Cervix-SCC"
integer_overdispersion_param_DMSL <- 1
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Cervix_SCC_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Cervix_SCC_nonexo,
                 loglog = F, title = 'obj_Cervix_SCC_nonexo\n (fullRE M)')+theme_bw(),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_Cervix_SCC_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Cervix_SCC_nonexo,
                 loglog = F, title = 'obj_Cervix_SCC_nonexo\n (fullRE DMSL)')+theme_bw(), ncol=2)
```

\clearpage
\subsubsection{Signatures from mutSigExtractor}

```{r, Cervix_SCC_mutsigextractor, echo=FALSE, warning=FALSE, fig.height=2}
obj_Cervix_SCC_mutSigExtractor <- load_PCAWG(ct = "Cervix-SCC", typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Cervix_SCC_mutSigExtractor, legend_on = F, verbose=F, nrow_plot=1)
```

\subsection{CNS-GBM}
\subsubsection{Barplot and general statistics}
```{r CNSGBM1, echo=FALSE, echo=FALSE}
ct <- "CNS-GBM"
obj_CNS_GBM <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_GBM, legend_on = TRUE, verbose=F)
```



The number of samples and signatures is:
```{r CNSGBM1b, echo=FALSE}
dim(obj_CNS_GBM$Y)
```

The signatures are:
```{r CNSGBM1c, echo=FALSE}
colnames(obj_CNS_GBM$Y)
```


\subsubsection{Convergence table}

We only have converged results for the multinomial with full RE, and the DM with a single lambda (diag and sparse RE). It is the same for nonexogenous signatures.

```{r CNSGBM2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "CNS-GBM"
melt(all_summaries) %>% filter(value==ct)
```


\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo
```{r CNSGBM3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "CNS-GBM"

obj_CNSGBM <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_CNSGBM <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_CNSGBM)
sortedM_CNSGBM
```

```{r CNSGBM3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_CNSGBM$Y)-1

sortedDM_CNSGBM <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_CNSGBM,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_CNSGBM$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_CNSGBM$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_CNSGBM$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_CNSGBM$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_CNSGBM

```


If we use the values of the fullRE M exo as initial values for the fullRE DMSL exo do converge:
```{r CNSGBM3b, echo=FALSE, message=FALSE, dependson=c('CNSGBM3')}
sortedDM_CNSGBM$pdHess
```


\subsubsection{Potentially problematic signatures}

We notice that there are no truly problematic signatures (SBS15 has the most zeros; 50\%).
```{r, CNSGBM1d}
colSums(obj_CNS_GBM$Y == 0)/nrow(obj_CNS_GBM$Y)
colSums(obj_CNS_GBM$Y)/sum(obj_CNS_GBM$Y)
```

```{r, additional_runs}
additional_sortedMnonexo <- list()
additional_sortedDMSLnonexo <- list()
```

```{r, CNS_GBM_additional_runs, dependson=c('additional_runs')}
additional_sortedMnonexo[["CNS-GBM"]] <- sortedM_CNSGBM
additional_sortedDMSLnonexo[["CNS-GBM"]] <- sortedDM_CNSGBM
```

\subsubsection{Betas}

```{r, CNSGBM_betas, echo=FALSE, warning=FALSE}
ct <- "CNS-GBM"

grid.arrange(plot_betas(fullRE_M[[ct]], names_cats=logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M')),
plot_betas(fullRE_DMSL[[ct]], names_cats=logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]], names_cats=logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]], names_cats=logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]], names_cats=logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(sortedDM_CNSGBM, names_cats=logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats=logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]], names_cats=logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```

```{r, CNSGBM_DA_beta_thesis, include=F, eval=T}
## to print in thesis

plot_betas(sortedDM_CNSGBM, names_cats=logR_nonexo_sorted[[ct]], remove_SBS=F)
ggsave("../../../CDA_in_Cancer/text/thesis/figures/GlobalDA/summary_TMB_PCAWG_files/figure-latex/beta_fullRE_DMSL_nonexo_CNSGBM_DA.pdf", width = 4, height = 2.5)
```

```{r, CNSGBM_DA, echo=FALSE, message=FALSE, results='hide'}
pval_CNS_GBM <- wald_TMB_wrapper(sortedDM_CNSGBM)
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_CNS_GBM`.

\subsubsection{Covariance matrices}



```{r, CNSGBM_cov, echo=FALSE, message=FALSE, fig.height=2.4, fig.width=2.4, dependson=c('CNS_GBM_additional_runs')}

ct <- "CNS-GBM"
# models_it_CNS_GBM <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_CNS_GBM <- c('fullRE_M', 'fullRE_M_nonexo', 'additional_sortedDMSLnonexo')
covmats_CNS_GBM <- lapply(models_it_CNS_GBM,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_CNS_GBM) <- models_it_CNS_GBM
## because it's fullRE_M, it's sorted
colnames(covmats_CNS_GBM[['fullRE_M']]) <- rownames(covmats_CNS_GBM[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_CNS_GBM)$Y))
colnames(covmats_CNS_GBM[['fullRE_M_nonexo']]) <- rownames(covmats_CNS_GBM[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_CNS_GBM, nonexogenous$V1)$Y))
colnames(covmats_CNS_GBM[['additional_sortedDMSLnonexo']]) <- rownames(covmats_CNS_GBM[['additional_sortedDMSLnonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_CNS_GBM, nonexogenous$V1)$Y))

for(i in 1:length(covmats_CNS_GBM)){pheatmap(covmats_CNS_GBM[[i]], cluster_rows = F, cluster_cols = F, main = models_it_CNS_GBM[i], fontsize=6)}
```



\subsubsection{Simulation under inferred data}
With fullRE DMSL:
```{r, CNSGBM_sim, echo=FALSE}
sim_CNS_GBM <- give_sim_from_estimates("CNS-GBM", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= NA,
                                      model="fullRE_DMSL", bool_nonexo = T,
                                      obj_data=obj_CNSGBM,
                                      tmb_object=sortedDM_CNSGBM)

sim_CNS_GBM[[2]]+ggtitle('Simulation of CNS-GBM samples')

```

With fullRE M, this time the covariance matrix is positive semi-definite:

```{r, CNSGBM_sim_2, echo=FALSE, fig.height=3}
obj_CNSGBM_unsorted <- give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1)
obj_CNSGBM_unsorted <- give_subset_sigs_TMBobj(obj_CNS_GBM, sigs_to_remove = nonexogenous$V1)

sim_CNS_GBM_M <- give_sim_from_estimates("CNS-GBM", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= NA,
                                      model="fullRE_M", bool_nonexo = T,
                                      obj_data=obj_CNSGBM_unsorted,
                                      tmb_object=fullRE_M_nonexo[["CNS-GBM"]], nrow=1)

sim_CNS_GBM_M[[2]]+ggtitle('Simulation of CNS-GBM samples (M)')

```


\subsubsection{Ranked plot for coverage}

```{r, CNSGBM_ranked_plot, echo=FALSE, dev='png'}
ct <- "CNS-GBM"
integer_overdispersion_param_DMSL <- 1
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_CNSGBM_unsorted,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNSGBM_unsorted,
                 loglog = F, title = 'obj_CNS_GBM (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = sortedDM_CNSGBM,
                 data_object = obj_CNSGBM,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNSGBM,
           loglog = F, title = 'obj_CNS_GBM (DMSL)'), ncol=2)
```


\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are a bit more chaotic:
```{r, CNSGBM_mutsigextractor, echo=FALSE, warning=FALSE, fig.height=2}
obj_CNS_GBM_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_GBM_mutSigExtractor, legend_on = FALSE, nrow=1, verbose=F)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.
```{r, CNSGBM_sortedbynummuts, echo=FALSE, fig.height=2, fig.width=4}
createBarplot(normalise_rw(non_duplicated_rows(obj_CNS_GBM$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_CNS_GBM$Y)),
                                        decreasing = F)), remove_labels=T)
```

<!-- -------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------- -->

\subsection{CNS-Medullo}
\subsubsection{Barplot and general statistics}
```{r CNSMedullo1, echo=FALSE}
ct <- "CNS-Medullo"
obj_CNS_Medullo <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_Medullo, legend_on = TRUE)
```


The number of samples and signatures is:
```{r CNSMedullo1b, echo=FALSE}
dim(obj_CNS_Medullo$Y)
```

The signatures are:
```{r CNSMedullo1c, echo=FALSE}
colnames(obj_CNS_Medullo$Y)
```



\subsubsection{Convergence table}

Pretty much everything has converged in this case
```{r CNSMedullo2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "CNS-Medullo"
melt(all_summaries) %>% filter(value==ct)
```

As nonexo DMSL has already converged, we don't re-run anything.

\subsubsection{Potentially problematic signatures}

We notice that there are no truly problematic signatures 
```{r, CNSMedullo1d}
colSums(obj_CNS_Medullo$Y == 0)/nrow(obj_CNS_Medullo$Y)
colSums(obj_CNS_Medullo$Y)/sum(obj_CNS_Medullo$Y)
```


\subsubsection{Betas}

```{r, CNSMedullo_betas, echo=FALSE}
ct <- "CNS-Medullo"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]], names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```



```{r, CNSMedullo_DA, echo=FALSE, message=FALSE, results='hide'}
pval_CNS_Medullo <- wald_TMB_wrapper(fullRE_DMSL_nonexo[["CNS-Medullo"]])
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_CNS_Medullo`.


\subsubsection{Covariance matrices}

```{r, CNSMedullo_cov, echo=FALSE, message=FALSE, fig.height=2.3, fig.width=2.3, dependson=c('CNS_Medullo_additional_runs')}

ct <- "CNS-Medullo"
# models_it_CNS_Medullo <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_CNS_Medullo <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_CNS_Medullo <- lapply(models_it_CNS_Medullo,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_CNS_Medullo) <- models_it_CNS_Medullo
## because it's fullRE_M, it's sorted
colnames(covmats_CNS_Medullo[['fullRE_M']]) <- rownames(covmats_CNS_Medullo[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_CNS_Medullo)$Y))
colnames(covmats_CNS_Medullo[['fullRE_M_nonexo']]) <- rownames(covmats_CNS_Medullo[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_CNS_Medullo, nonexogenous$V1)$Y))
colnames(covmats_CNS_Medullo[['fullRE_DMSL_nonexo']]) <- rownames(covmats_CNS_Medullo[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_CNS_Medullo, nonexogenous$V1)$Y))

for(i in 1:length(covmats_CNS_Medullo)){pheatmap(covmats_CNS_Medullo[[i]], cluster_rows = F, cluster_cols = F, main = models_it_CNS_Medullo[i], fontsize=7)}
```


\subsubsection{Simulation under inferred data}

```{r, create_obj_CNS_Medullo_nonexo}
obj_CNS_Medullo_nonexo <- give_subset_sigs_TMBobj(obj_CNS_Medullo, nonexogenous$V1)
```

```{r, CNSMedullo_sim, echo=FALSE, fig.height=2.5}
sim_CNS_Medullo <- give_sim_from_estimates("CNS-Medullo", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = T,
                                      tmb_object=fullRE_DMSL_nonexo[["CNS-Medullo"]],
                                      obj_data=obj_CNS_Medullo_nonexo, nrow=1)

sim_CNS_Medullo[[2]]+theme_bw()+ggtitle('Simulation of CNS-Medullo samples')

```


\subsubsection{Ranked plot for coverage}

```{r, CNSMedullo_ranked_plot, echo=FALSE, dev='png'}
ct <- "CNS-Medullo"
integer_overdispersion_param_DMSL <- 1
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_CNS_Medullo_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNS_Medullo_nonexo,
                 loglog = F, title = 'obj_CNS_Medullo nonexo (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[["CNS-Medullo"]],
                 data_object = obj_CNS_Medullo_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNS_Medullo_nonexo,
           loglog = F, title = 'obj_CNS_Medullo nonexo (DMSL)'), ncol=2)
```



\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are a bit more chaotic:
```{r, CNSMedullo_mutsigextractor, echo=FALSE, warning=F}
obj_CNS_Medullo_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_Medullo_mutSigExtractor, legend_on = FALSE, verbose=F)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.
```{r, CNSMedullo_sortedbynummuts, echo=FALSE, warning=F, fig.height=2, fig.width=4}
createBarplot(normalise_rw(non_duplicated_rows(obj_CNS_Medullo$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_CNS_Medullo$Y)),
                                        decreasing = F)), verbose=F, remove_labels=T,
              arg_title='')+
  theme(legend.position = "bottom")
```

\clearpage
<!-- -------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------- -->

\subsection{CNS-Oligo}

\subsubsection{Barplot and general statistics}
```{r CNSOligo1, echo=FALSE, fig.height=3}
ct <- "CNS-Oligo"
obj_CNS_Oligo <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_Oligo, legend_on = TRUE, legend_bottom=T,
                      verbose=F, nrow_plot=1, arg_title='')
```


The number of samples and signatures is:
```{r CNSOligo1b, echo=FALSE}
dim(obj_CNS_Oligo$Y)
```

The signatures are:
```{r CNSOligo1c, echo=FALSE}
colnames(obj_CNS_Oligo$Y)
```


\subsubsection{Convergence table}

Pretty much everything has converged
```{r CNSOligo2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "CNS-Oligo"
melt(all_summaries) %>% filter(value==ct)
```


<!-- \subsubsection{Potentially problematic signatures} -->

<!-- We notice that there are no truly problematic signatures (SBS15 has the most zeros; 50\%). -->
<!-- ```{r, CNSOligo1d} -->
<!-- colSums(obj_CNS_Oligo$Y == 0)/nrow(obj_CNS_Oligo$Y) -->
<!-- colSums(obj_CNS_Oligo$Y)/sum(obj_CNS_Oligo$Y) -->
<!-- ``` -->



\subsubsection{Betas}

```{r, CNSOligo_betas, echo=FALSE}
ct <- "CNS-Oligo"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M')),
plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
  plot_betas(fullRE_DMDL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMDL_nonexo')), nrow=2)
```



```{r, CNSOligo_DA, echo=FALSE, message=FALSE, results='hide'}
pval_CNS_Oligo <- wald_TMB_wrapper(fullRE_DMSL_nonexo[["CNS-Oligo"]])

```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_CNS_Oligo`.

\subsubsection{Covariance matrices}



```{r, CNSOligo_cov, echo=FALSE, message=FALSE, fig.height=2.5, fig.width=2.5, dependson=c('CNS_Oligo_additional_runs')}

ct <- "CNS-Oligo"
models_it_CNS_Oligo <- c('fullRE_M', 'fullRE_DMSL', 'fullRE_DMSL_nonexo')
covmats_CNS_Oligo <- lapply(models_it_CNS_Oligo,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_CNS_Oligo) <- models_it_CNS_Oligo

## because it's fullRE_M, it's sorted
colnames(covmats_CNS_Oligo[['fullRE_M']]) <- rownames(covmats_CNS_Oligo[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_CNS_Oligo)$Y))
colnames(covmats_CNS_Oligo[['fullRE_DMSL']]) <- rownames(covmats_CNS_Oligo[['fullRE_DMSL']]) <- vector_cats_to_logR(colnames(obj_CNS_Oligo$Y))
colnames(covmats_CNS_Oligo[['fullRE_DMSL_nonexo']]) <- rownames(covmats_CNS_Oligo[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_CNS_Oligo, nonexogenous$V1)$Y))

for(i in 1:length(covmats_CNS_Oligo)){pheatmap(covmats_CNS_Oligo[[i]], cluster_rows = F, cluster_cols = F, main = models_it_CNS_Oligo[i], fontsize=7)}
```




```{r, CNSOligo_objnonexo, echo=FALSE}
obj_CNS_Oligo_nonexo <- give_subset_sigs_TMBobj(obj_CNS_Oligo, sigs_to_remove = nonexogenous$V1)
```

\subsubsection{Simulation under inferred data}
```{r, CNSOligo_sim, echo=FALSE, fig.height=2.5}
sim_CNS_Oligo <- give_sim_from_estimates("CNS-Oligo", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = T,
                                      tmb_object=fullRE_DMSL_nonexo[["CNS-Oligo"]],
                                      obj_data=obj_CNS_Oligo_nonexo, nrow=1)

sim_CNS_Oligo[[2]]+ggtitle('Simulation of CNS-Oligo samples')+theme_bw()


```



\subsubsection{Ranked plot for coverage}
The values for DMSL nonexo look considerably better than for M nonexo.

```{r, CNSOligo_ranked_plot, echo=FALSE, dev='png'}
ct <- "CNS-Oligo"
integer_overdispersion_param_DMSL <- 1
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_CNS_Oligo_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNS_Oligo_nonexo,
                 loglog = F, title = 'obj_CNS_Oligo (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_CNS_Oligo_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNS_Oligo_nonexo,
           loglog = F, title = 'obj_CNS_Oligo (DMSL)'), ncol=2)
```


\subsubsection{Signatures from mutSigExtractor}

These are the signatures from mutSigExtractor:
```{r, CNSOligo_mutsigextractor, echo=FALSE, warning=FALSE, fig.height=2}
obj_CNS_Oligo_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_Oligo_mutSigExtractor, legend_on = FALSE, verbose=F, nrow=1)
```


Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.

```{r, CNSOligo_sortedbynummuts, fig.height=2, fig.width=4, echo=FALSE}
createBarplot(normalise_rw(non_duplicated_rows(obj_CNS_Oligo$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_CNS_Oligo$Y)),
                                        decreasing = F)), verbose=F, remove_labels=T)
```

<!-- -------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------- -->

\subsection{CNS-PiloAstro}

\subsection{CNS-PiloAstro}
\subsubsection{Barplot and general statistics}
```{r CNSPiloAstro1, echo=FALSE}
ct <- "CNS-PiloAstro"
obj_CNS_PiloAstro <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_PiloAstro, legend_on = TRUE, verbose=F)
```



The number of samples and signatures is:
```{r CNSPiloAstro1b, echo=FALSE}
dim(obj_CNS_PiloAstro$Y)
```

The signatures are:
```{r CNSPiloAstro1c, echo=FALSE}
colnames(obj_CNS_PiloAstro$Y)
```


\subsubsection{Convergence table}

We have converged results for everything except for full RE DM, in the case of all signatures (with only nonexo everything has).

```{r CNSPiloAstro2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "CNS-PiloAstro"
melt(all_summaries) %>% filter(value==ct)
```



\subsubsection{Re-running of fitting}
Using fullRE_M to fit fullRE_DMSL (all sigs, as the one with nonexo has already converged)
```{r CNSPiloAstro3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "CNS-PiloAstro"

obj_CNSPiloAstro <- sort_columns_TMB(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"))
sortedM_CNSPiloAstro <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_CNSPiloAstro)
sortedM_CNSPiloAstro
```


```{r CNSPiloAstro3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_CNSPiloAstro$Y)-1

sortedDM_CNSPiloAstro <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_CNSPiloAstro,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_CNSPiloAstro$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_CNSPiloAstro$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_CNSPiloAstro$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_CNSPiloAstro$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_CNSPiloAstro

```



If we use the values of the fullRE M as initial values for the fullRE DMSL still do not converge:
```{r CNSPiloAstro3b, echo=FALSE, message=FALSE, dependson=c('CNSPiloAstro3')}
sortedDM_CNSPiloAstro$pdHess
```




\subsubsection{Potentially problematic signatures}

We notice that there are no truly problematic signatures (SBS15 has the most zeros; 50\%).
```{r, CNSPiloAstro1d}
colSums(obj_CNS_PiloAstro$Y == 0)/nrow(obj_CNS_PiloAstro$Y)
colSums(obj_CNS_PiloAstro$Y)/sum(obj_CNS_PiloAstro$Y)
```

SBS19 and SBS23 are quite sparse.



```{r, CNS_PiloAstro_additional_runs, dependson=c('additional_runs'), echo=FALSE}
additional_sortedMnonexo[["CNS-PiloAstro"]] <- sortedM_CNSPiloAstro
additional_sortedDMSLnonexo[["CNS-PiloAstro"]] <- sortedDM_CNSPiloAstro
```

\subsubsection{Betas}

```{r, CNSPiloAstro_betas,echo=FALSE, warning=FALSE}
ct <- "CNS-PiloAstro"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
  plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
  plot_betas(sparseRE_DMSL_nonexo[[ct]], names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```




```{r, CNSPiloAstro_DA, echo=FALSE, message=FALSE, results='hide'}
pval_CNS_PiloAstro <- wald_TMB_wrapper(fullRE_DMSL_nonexo[["CNS-PiloAstro"]])
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_CNS_PiloAstro`.


\subsubsection{Covariance matrices}



```{r, CNSPiloAstro_cov, echo=FALSE, message=FALSE, fig.height=2.4, fig.width=2.4, dependson=c('CNS_PiloAstro_additional_runs')}

ct <- "CNS-PiloAstro"
# models_it_CNS_PiloAstro <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_CNS_PiloAstro <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_CNS_PiloAstro <- lapply(models_it_CNS_PiloAstro,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_CNS_PiloAstro) <- models_it_CNS_PiloAstro
## because it's fullRE_M, it's sorted
colnames(covmats_CNS_PiloAstro[['fullRE_M']]) <- rownames(covmats_CNS_PiloAstro[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_CNS_PiloAstro)$Y))
colnames(covmats_CNS_PiloAstro[['fullRE_M_nonexo']]) <- rownames(covmats_CNS_PiloAstro[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_CNS_PiloAstro, nonexogenous$V1)$Y))
colnames(covmats_CNS_PiloAstro[['fullRE_DMSL_nonexo']]) <- rownames(covmats_CNS_PiloAstro[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_CNS_PiloAstro, nonexogenous$V1)$Y))

for(i in 1:length(covmats_CNS_PiloAstro)){pheatmap(covmats_CNS_PiloAstro[[i]], cluster_rows = F, cluster_cols = F, main = models_it_CNS_PiloAstro[i], fontsize=7)}
```

```{r, CNSPiloAstro_objnonexo, echo=FALSE}
obj_CNS_PiloAstro_nonexo <- give_subset_sigs_TMBobj(obj_CNS_PiloAstro, sigs_to_remove = nonexogenous$V1)
```

\subsubsection{Simulation under inferred data}
```{r, CNSPiloAstro_sim, echo=FALSE, fig.height=2.5}
sim_CNS_PiloAstro <- give_sim_from_estimates(ct = "CNS-PiloAstro", typedata = "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = F,
                                      tmb_object=fullRE_DMSL_nonexo[["CNS-PiloAstro"]],
                                      obj_data=obj_CNS_PiloAstro_nonexo, nrow_pca_plot=1)

sim_CNS_PiloAstro[[2]]+ggtitle('Simulation of CNS-PiloAstro samples')+theme_bw()


```



\subsubsection{Ranked plot for coverage}
The strange pattern in DMSL is worth pointing out. The beta coefficients are too very different between M and DMSL for nonexo.

```{r, CNSPiloAstro_ranked_plot, echo=FALSE, dev='png'}
ct <- "CNS-PiloAstro"
integer_overdispersion_param_DMSL <- 1
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_CNS_PiloAstro_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNS_PiloAstro_nonexo,
                 loglog = F, title = 'obj_CNS_PiloAstro (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_CNS_PiloAstro_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNS_PiloAstro_nonexo,
           loglog = F, title = 'obj_CNS_PiloAstro (DMSL)'), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are a bit more chaotic:
```{r, CNSPiloAstro_mutsigextractor, echo=FALSE, fig.height=2, warning=FALSE}
obj_CNS_PiloAstro_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_PiloAstro_mutSigExtractor, legend_on = FALSE, nrow=1, verbose=F)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations, with perhaps SBS9 being slightly found in the rightmost side preferentially.
```{r, CNSPiloAstro_sortedbynummuts, echo=F, fig.height=2, fig.width=4}
createBarplot(normalise_rw(non_duplicated_rows(obj_CNS_PiloAstro$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_CNS_PiloAstro$Y)),
                                        decreasing = F)), verbose=F, remove_labels=T)
```


\subsection{ColoRect-AdenoCA}

\subsection{ColoRect-AdenoCA}
\subsubsection{Barplot and general statistics}
```{r ColoRectAdenoCA1, echo=FALSE}
ct <- "ColoRect-AdenoCA"
obj_ColoRect_AdenoCA <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_ColoRect_AdenoCA, legend_on = TRUE, verbose=F)
```



The number of samples and signatures is:
```{r ColoRectAdenoCA1b, echo=FALSE}
dim(obj_ColoRect_AdenoCA$Y)
```

The signatures are:
```{r ColoRectAdenoCA1c, echo=FALSE}
colnames(obj_ColoRect_AdenoCA$Y)
```



\subsubsection{Convergence table}

We only have converged results for the multinomial with diag RE, when including all mutations. For exogenous mutations, full DMSL is has not converged.

```{r ColoRectAdenoCA2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "ColoRect-AdenoCA"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo
```{r ColoRectAdenoCA3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}

TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "ColoRect-AdenoCA"

obj_ColoRectAdenoCA <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct,
                                                                           typedata = "signatures",
                                                                           path_to_data = "../../data/"),
                                                                nonexogenous$V1))
colnames(obj_ColoRectAdenoCA)
sortedM_ColoRectAdenoCA <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_ColoRectAdenoCA)
sortedM_ColoRectAdenoCA
```


Now the fullM doesn't converge (even though the original fullRE M nonexo did converge?), so I cannot use all the parameters to find the starting parameters of the DM, as some are NA. I can however use some, such as beta.


What parameters are NA? Betas, logsd and covariances are not NA. Therefore, we use these values as starting values, and give an empty random effects matrix.

```{r ColoRectAdenoCA3a1, echo=FALSE, message=FALSE, dependson=c('libraries'), include=FALSE}
sortedM_ColoRectAdenoCA$par.fixed
```


```{r ColoRectAdenoCA3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide', eval=T}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_ColoRectAdenoCA$Y)-1

initial_params_colorect <- list(
                             beta = matrix(python_like_select_name(sortedM_ColoRectAdenoCA$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(0, nrow=length(sortedM_ColoRectAdenoCA$par.random) %/% dmin1,
                                              ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_ColoRectAdenoCA$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_ColoRectAdenoCA$par.fixed, 'cov_par_RE'),
                             log_lambda = 2)

# sortedDM_ColoRectAdenoCA <- wrapper_run_TMB(model = "fullREDMsinglelambda",
#                            object = obj_ColoRectAdenoCA,
#                            smart_init_vals = F, use_nlminb = T,
#                            initial_params = initial_params_colorect)
# sortedDM_ColoRectAdenoCA

```

I get the error "gradient function must rerurn a number vector of length 43" for some reason I don't understand - it's as though the initial values I am giving are not correct.

```{r ColoRectAdenoCA3b, echo=FALSE, message=FALSE, dependson=c('ColoRectAdenoCA3')}
# sortedDM_ColoRectAdenoCA$pdHess
```

\subsubsection{Potentially problematic signatures}

```{r, ColoRectAdenoCA1d}
colSums(obj_ColoRect_AdenoCA$Y == 0)/nrow(obj_ColoRect_AdenoCA$Y)
colSums(obj_ColoRect_AdenoCA$Y)/sum(obj_ColoRect_AdenoCA$Y)
```

\subsubsection{Betas}

```{r, ColoRectAdenoCA_betas, echo=FALSE, warning=FALSE}
ct <- "ColoRect-AdenoCA"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
  plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
  plot_betas(sparseRE_DMSL_nonexo[[ct]], names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')
                                                 ), nrow=2)
```

```{r, ColoRectAdenoCA_DA, echo=FALSE, message=FALSE, results='hide'}
pval_ColoRect_AdenoCA <- wald_TMB_wrapper(diagRE_DMSL_nonexo[["ColoRect-AdenoCA"]])
```
We use the results from the diagonal RE single lambda DM nonexo to test for differential abundance, giving a p-value of `r pval_ColoRect_AdenoCA`.

\subsubsection{Covariance matrices}

```{r, ColoRectAdenoCA_cov, echo=FALSE, message=FALSE, fig.height=2.6, fig.width=2.6, dependson=c('ColoRect_AdenoCA_additional_runs')}

ct <- "ColoRect-AdenoCA"
models_it_ColoRect_AdenoCA <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_ColoRect_AdenoCA <- lapply(models_it_ColoRect_AdenoCA,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_ColoRect_AdenoCA) <- models_it_ColoRect_AdenoCA
## because it's fullRE_M, it's sorted
colnames(covmats_ColoRect_AdenoCA[['fullRE_M']]) <- rownames(covmats_ColoRect_AdenoCA[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_ColoRect_AdenoCA)$Y))
colnames(covmats_ColoRect_AdenoCA[['fullRE_M_nonexo']]) <- rownames(covmats_ColoRect_AdenoCA[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_ColoRect_AdenoCA, nonexogenous$V1)$Y))
colnames(covmats_ColoRect_AdenoCA[['fullRE_DMSL_nonexo']]) <- rownames(covmats_ColoRect_AdenoCA[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_ColoRect_AdenoCA, nonexogenous$V1)$Y))

for(i in 1:length(covmats_ColoRect_AdenoCA)){pheatmap(covmats_ColoRect_AdenoCA[[i]], cluster_rows = F, cluster_cols = F, main = models_it_ColoRect_AdenoCA[i], fontsize=7)}
```


\subsubsection{Simulation under inferred data}
I am simulating using the full effects multinomial, because the function <give_sim_from_estimates> needs to be adapted to diagDMSL.

```{r, ColoRectAdenoCA_objnonexo, echo=FALSE}
obj_ColoRect_AdenoCA_nonexo <- give_subset_sigs_TMBobj(obj_ColoRect_AdenoCA, sigs_to_remove = nonexogenous$V1)
```

```{r, ColoRectAdenoCA_sim, echo=FALSE, fig.height=2.2}
sim_ColoRect_AdenoCA <- give_sim_from_estimates("ColoRect-AdenoCA", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_M", bool_nonexo = T,
                                      tmb_object=(fullRE_M_nonexo[["ColoRect-AdenoCA"]]),
                                      sig_of_interest = "SBS14",
                                      obj_data=obj_ColoRect_AdenoCA_nonexo, nrow_pca_plot=1)

sim_ColoRect_AdenoCA[[2]]+ggtitle('Simulation of ColoRect-AdenoCA samples')+theme_bw()


```


\subsubsection{Ranked plot for coverage}

```{r, ColoRectAdenoCA_ranked_plot, echo=FALSE, fig.height=3.5, fig.width=6, dev='png'}
ct <- "ColoRect-AdenoCA"
integer_overdispersion_param_DMSL <- 1
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_ColoRect_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_ColoRect_AdenoCA_nonexo,
                 loglog = F, title = 'obj_ColoRect_AdenoCA\n (M nonexo)', theme_bw=T),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                 data_object = obj_ColoRect_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_ColoRect_AdenoCA_nonexo,
           loglog = F, title = 'obj_ColoRect_AdenoCA\n (diag DMSL nonexo)', theme_bw=T), ncol=2)

```

\subsubsection{Signatures from mutSigExtractor}

```{r, ColoRectAdenoCA_mutsigextractor, echo=FALSE, warning=FALSE, fig.height=2}
obj_ColoRect_AdenoCA_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_ColoRect_AdenoCA_mutSigExtractor, legend_on = FALSE, verbose=F, nrow=1)
```

Exposures sorted by increasing number of mutations: very clearly there are a few samples with very high number of mutations that also have a completely different mutational signature exposure.
```{r, ColoRectAdenoCA_sortedbynummuts, fig.height=2, fig.width=4, echo=FALSE}
createBarplot(normalise_rw(non_duplicated_rows(obj_ColoRect_AdenoCA$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_ColoRect_AdenoCA$Y)),
                                        decreasing = F)), verbose=F, remove_labels=T)+
  theme(legend.position = "bottom")
```

\subsection{Eso-AdenoCA}

\subsubsection{Barplot and general statistics}
```{r EsoAdenoCA1, echo=FALSE}
ct <- "Eso-AdenoCA"
obj_Eso_AdenoCA <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Eso_AdenoCA, legend_on = TRUE, verbose=F)
```

The number of samples and signatures is:
```{r EsoAdenoCA1b, echo=FALSE}
dim(obj_Eso_AdenoCA$Y)
```

The signatures are:
```{r EsoAdenoCA1c, echo=FALSE}
colnames(obj_Eso_AdenoCA$Y)
```


\subsubsection{Convergence table}

None of the fullRE have converged when including all signatures. When including nonexo, all but fullRE_DMSL_nonexo (using either the highest absolute signature or SBS1) have converged.
```{r EsoAdenoCA2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Eso-AdenoCA"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo
```{r EsoAdenoCA3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Eso-AdenoCA"

obj_EsoAdenoCA <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                      nonexogenous$V1))
sortedM_EsoAdenoCA <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_EsoAdenoCA, use_nlminb=T)
sortedM_EsoAdenoCA

```

which has a positive-semidefinite covariance matrix, i.e. has converged

```{r EsoAdenoCA3convergence, echo=FALSE, message=FALSE, dependson=c('libraries')}
sortedM_EsoAdenoCA$pdHess
```

The fullRE DMSL hasn't, though: 
```{r EsoAdenoCA3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_EsoAdenoCA$Y)-1

sortedDM_EsoAdenoCA <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_EsoAdenoCA,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_EsoAdenoCA$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_EsoAdenoCA$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_EsoAdenoCA$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_EsoAdenoCA$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_EsoAdenoCA
```

```{r EsoAdenoCA3b, echo=FALSE, message=FALSE, dependson=c('EsoAdenoCA3')}
sortedDM_EsoAdenoCA$pdHess
```

Running fullRE DMSL, this time without sorting, doesn't converge either:
```{r EsoAdenoCA3a2notsorted, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
ct <- "Eso-AdenoCA"
obj_EsoAdenoCA_notsorted <- give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                      nonexogenous$V1)

TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_EsoAdenoCA_notsorted$Y)-1

notsortedDM_EsoAdenoCA <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_EsoAdenoCA_notsorted,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(fullRE_M_nonexo[[ct]]$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(fullRE_M_nonexo[[ct]]$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(fullRE_M_nonexo[[ct]]$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(fullRE_M_nonexo[[ct]]$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
notsortedDM_EsoAdenoCA
```

Bafflingly, using two lambdas does:

\subsubsection{Potentially problematic signatures}

We notice that there are no truly problematic signatures (SBS30 has the most zeros; 54.6\%).
```{r, EsoAdenoCA1d}
colSums(obj_Eso_AdenoCA$Y == 0)/nrow(obj_Eso_AdenoCA$Y)
colSums(obj_Eso_AdenoCA$Y)/sum(obj_Eso_AdenoCA$Y)
```

\subsubsection{Betas}

```{r, EsoAdenoCA_betas, echo=FALSE, fig.height=4, warning=FALSE}
ct <- "Eso-AdenoCA"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]], names_cats = logR_nonexo_sorted[[ct]]
)+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```


```{r, EsoAdenoCA_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Eso_AdenoCA <- wald_TMB_wrapper(diagRE_DMSL_nonexo[["Eso-AdenoCA"]])

```
We use the results from the diag RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Eso_AdenoCA`.

\subsubsection{Covariance matrices}

```{r, EsoAdenoCA_cov, echo=FALSE, message=FALSE, fig.height=2.8, fig.width=2.8, dependson=c('Eso_AdenoCA_additional_runs')}

ct <- "Eso-AdenoCA"
# models_it_Eso_AdenoCA <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Eso_AdenoCA <- c('fullRE_M', 'fullRE_M_nonexo')
covmats_Eso_AdenoCA <- lapply(models_it_Eso_AdenoCA,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Eso_AdenoCA) <- models_it_Eso_AdenoCA
## because it's fullRE_M, it's sorted
colnames(covmats_Eso_AdenoCA[['fullRE_M']]) <- rownames(covmats_Eso_AdenoCA[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Eso_AdenoCA)$Y))
colnames(covmats_Eso_AdenoCA[['fullRE_M_nonexo']]) <- rownames(covmats_Eso_AdenoCA[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Eso_AdenoCA, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Eso_AdenoCA)){pheatmap(covmats_Eso_AdenoCA[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Eso_AdenoCA[i], fontsize=7)}
```

```{r, EsoAdenoCA_nonexo, echo=FALSE}
obj_Eso_AdenoCA_nonexo <- give_subset_sigs_TMBobj(obj_Eso_AdenoCA, sigs_to_remove = nonexogenous$V1)
```

\subsubsection{Simulation under inferred data}
```{r, EsoAdenoCA_sim, echo=FALSE, fig.height=2}
sim_Eso_AdenoCA <- give_sim_from_estimates("Eso-AdenoCA", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="diagRE_DMSL", bool_nonexo = T,
                                       tmb_object=diagRE_DMSL_nonexo[[ct]],
                                      sig_of_interest='SBS2',
                                      obj_data=obj_Eso_AdenoCA_nonexo, nrow_pca_plot=1)

sim_Eso_AdenoCA[[2]]+ggtitle('Simulation of Eso-AdenoCA samples')+theme_bw()

```

\subsubsection{Ranked plot for coverage}

```{r, EsoAdenoCA_ranked_plot, echo=FALSE, fig.height=2.5, dev='png'}
ct <- "Eso-AdenoCA"
integer_overdispersion_param_DMSL <- 1
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Eso_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Eso_AdenoCA_nonexo,
                 loglog = F, title = 'obj_Eso_AdenoCA (M)', theme_bw=T),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                 data_object = obj_Eso_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Eso_AdenoCA_nonexo,
           loglog = F, title = 'obj_Eso_AdenoCA (DMSL)', theme_bw=T), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, EsoAdenoCA_mutsigextractor, warning=FALSE, echo=FALSE}
obj_Eso_AdenoCA_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Eso_AdenoCA_mutSigExtractor, legend_on = FALSE, verbose=F)
```

Exposures sorted by increasing number of mutations: there is a trend of samples with more mutations having more SBS17b and less SBS5, relatively.

```{r, EsoAdenoCA_sortedbynummuts, fig.height=2, fig.width=6, echo=FALSE}
createBarplot(normalise_rw(non_duplicated_rows(obj_Eso_AdenoCA$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Eso_AdenoCA$Y)),
                                        decreasing = F)), verbose=F, remove_labels=T)
```


\subsection{Head-SCC}

\subsubsection{Barplot and general statistics}
```{r HeadSCC1, echo=FALSE, echo=FALSE, fig.height=2.2, warning=FALSE}
ct <- "Head-SCC"
obj_Head_SCC <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Head_SCC, legend_on = F, verbose=F, nrow=1)
```

The number of samples and signatures is:
```{r HeadSCC1b, echo=FALSE}
dim(obj_Head_SCC$Y)
```

The signatures are:
```{r HeadSCC1c, echo=FALSE}
colnames(obj_Head_SCC$Y)
```

\subsubsection{Convergence table}

We don't have converged results for the multinomial with full RE, but for nonexogenous signatures everything has.

```{r HeadSCC2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Head-SCC"
melt(all_summaries) %>% filter(value==ct)
```


\subsubsection{Re-running of fitting}
We don't need refitting, as the results have already converged.


\subsubsection{Potentially problematic signatures}

SBS33 is likely to be problematic.
```{r, HeadSCC1d}
colSums(obj_Head_SCC$Y == 0)/nrow(obj_Head_SCC$Y)
colSums(obj_Head_SCC$Y)/sum(obj_Head_SCC$Y)
```

\subsubsection{Betas}

```{r, HeadSCC_betas, echo=F, warning=FALSE, fig.height=4}
ct <- "Head-SCC"

grid.arrange(plot_betas(fullRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
             plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
             plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
             plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
  plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
  plot_betas(sparseRE_DMSL_nonexo[[ct]], names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```


```{r, HeadSCC_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Head_SCC <- wald_TMB_wrapper(fullRE_DMSL_nonexo[["Head-SCC"]])

```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Head_SCC`.

\subsubsection{Covariance matrices}

```{r, HeadSCC_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Head_SCC_additional_runs')}

ct <- "Head-SCC"
# models_it_Head_SCC <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Head_SCC <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_Head_SCC <- lapply(models_it_Head_SCC,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Head_SCC) <- models_it_Head_SCC
## because it's fullRE_M, it's sorted
colnames(covmats_Head_SCC[['fullRE_M']]) <- rownames(covmats_Head_SCC[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Head_SCC)$Y))
colnames(covmats_Head_SCC[['fullRE_M_nonexo']]) <- rownames(covmats_Head_SCC[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Head_SCC, nonexogenous$V1)$Y))
colnames(covmats_Head_SCC[['fullRE_DMSL_nonexo']]) <- rownames(covmats_Head_SCC[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Head_SCC, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Head_SCC)){pheatmap(covmats_Head_SCC[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Head_SCC[i])}
```

```{r, HeadSCC_objnonexo, echo=FALSE}
obj_Head_SCC_nonexo <- give_subset_sigs_TMBobj(obj_Head_SCC, sigs_to_remove = nonexogenous$V1)
```

\subsubsection{Simulation under inferred data}
```{r, HeadSCC_sim, echo=FALSE, fig.height=2.4}
sim_Head_SCC <- give_sim_from_estimates("Head-SCC", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = T, sig_of_interest="SBS2",
                                      tmb_object=fullRE_DMSL_nonexo[["Head-SCC"]],
                                      obj_data=obj_Head_SCC_nonexo, nrow_pca_plot=1)

sim_Head_SCC[[2]]+ggtitle('Simulation of Head-SCC samples')+theme_bw()


```

\subsubsection{Ranked plot for coverage}

```{r, HeadSCC_ranked_plot, echo=FALSE, dev='png'}
ct <- "Head-SCC"
integer_overdispersion_param_DMSL <- 1
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Head_SCC_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Head_SCC_nonexo,
                 loglog = F, title = 'obj_Head_SCC (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_Head_SCC_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Head_SCC_nonexo,
           loglog = F, title = 'obj_Head_SCC (DMSL)'), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, HeadSCC_mutsigextractor, echo=F, warning=FALSE, fig.height=2}
obj_Head_SCC_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Head_SCC_mutSigExtractor, legend_on = FALSE, verbose=F, nrow=1)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.
```{r, HeadSCC_sortedbynummuts, fig.height=2, fig.width=6, echo=F}
createBarplot(normalise_rw(non_duplicated_rows(obj_Head_SCC$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Head_SCC$Y)),
                                        decreasing = F)), verbose=F, remove_labels=T)
```

\subsection{Kidney-ChRCC}

\subsubsection{Barplot and general statistics}
```{r KidneyChRCC1, echo=FALSE, fig.height=2.1, warning=FALSE}
ct <- "Kidney-ChRCC"
obj_Kidney_ChRCC <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Kidney_ChRCC, legend_on = F, verbose=F, nrow=1)
```

The number of samples and signatures is:
```{r KidneyChRCC1b, echo=FALSE}
dim(obj_Kidney_ChRCC$Y)
```

The signatures are:
```{r KidneyChRCC1c, echo=FALSE}
colnames(obj_Kidney_ChRCC$Y)
```

\subsubsection{Convergence table}

For all signatures, no fullRE model has converged. For nonexogenous ones, all have.
```{r KidneyChRCC2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Kidney-ChRCC"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}
We do not need to re-run any model fitting.

\subsubsection{Potentially problematic signatures}

We notice that SBS17a and SBS17b are perhaps problematic.
```{r, KidneyChRCC1d}
colSums(obj_Kidney_ChRCC$Y == 0)/nrow(obj_Kidney_ChRCC$Y)
colSums(obj_Kidney_ChRCC$Y)/sum(obj_Kidney_ChRCC$Y)
```


\subsubsection{Betas}

```{r, KidneyChRCC_betas, echo=F, warning=F}
ct <- "Kidney-ChRCC"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]], names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```


```{r, KidneyChRCC_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Kidney_ChRCC <- wald_TMB_wrapper(fullRE_DMSL_nonexo[["Kidney-ChRCC"]])
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Kidney_ChRCC`.

\subsubsection{Covariance matrices}

```{r, KidneyChRCC_cov, echo=FALSE, message=FALSE, fig.height=2.7, fig.width=2.7, dependson=c('Kidney_ChRCC_additional_runs')}

ct <- "Kidney-ChRCC"
# models_it_Kidney_ChRCC <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Kidney_ChRCC <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_Kidney_ChRCC <- lapply(models_it_Kidney_ChRCC,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Kidney_ChRCC) <- models_it_Kidney_ChRCC
## because it's fullRE_M, it's sorted
colnames(covmats_Kidney_ChRCC[['fullRE_M']]) <- rownames(covmats_Kidney_ChRCC[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Kidney_ChRCC)$Y))
colnames(covmats_Kidney_ChRCC[['fullRE_M_nonexo']]) <- rownames(covmats_Kidney_ChRCC[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Kidney_ChRCC, nonexogenous$V1)$Y))
colnames(covmats_Kidney_ChRCC[['fullRE_DMSL_nonexo']]) <- rownames(covmats_Kidney_ChRCC[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Kidney_ChRCC, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Kidney_ChRCC)){pheatmap(covmats_Kidney_ChRCC[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Kidney_ChRCC[i], fontsize=7)}
```

```{r, KidneyChRCC_objnonexo, echo=FALSE}
obj_Kidney_ChRCC_nonexo <- give_subset_sigs_TMBobj(obj_Kidney_ChRCC, sigs_to_remove = nonexogenous$V1)
```

\subsubsection{Simulation under inferred data}
```{r, KidneyChRCC_sim, echo=FALSE, fig.height=2.2}
sim_Kidney_ChRCC <- give_sim_from_estimates("Kidney-ChRCC", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = T,
                                      tmb_object=fullRE_DMSL_nonexo[["Kidney-ChRCC"]],
                                      obj_data=obj_Kidney_ChRCC_nonexo,
                                      sig_of_interest='SBS17b', nrow=1)

sim_Kidney_ChRCC[[2]]+ggtitle('Simulation of Kidney-ChRCC samples')+theme_bw()


```


\subsubsection{Ranked plot for coverage}

```{r, KidneyChRCC_ranked_plot, echo=FALSE, fig.height=2, dev='png'}
ct <- "Kidney-ChRCC"
integer_overdispersion_param_DMSL <- 1
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Kidney_ChRCC_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Kidney_ChRCC_nonexo,
                 loglog = F, title = 'obj_Kidney_ChRCC (M)', theme_bw=T),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[["Kidney-ChRCC"]],
                 data_object = obj_Kidney_ChRCC_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Kidney_ChRCC_nonexo,
           loglog = F, title = 'obj_Kidney_ChRCC (DMSL)', theme_bw=T), ncol=2)
```


\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, KidneyChRCC_mutsigextractor, echo=F, warning=FALSE, fig.height=2}
obj_Kidney_ChRCC_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Kidney_ChRCC_mutSigExtractor, legend_on = FALSE, nrow=1, verbose=F)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.

```{r, KidneyChRCC_sortedbynummuts, fig.height=2, fig.width=6, echo=FALSE}
createBarplot(normalise_rw(non_duplicated_rows(obj_Kidney_ChRCC$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Kidney_ChRCC$Y)),
                                        decreasing = F)), verbose=F, remove_labels=T)
```

\subsection{Kidney-RCC.clearcell}
\subsubsection{Barplot and general statistics}
```{r KidneyRCCclearcell1, echo=FALSE, fig.height=2, warning=FALSE}
ct <- "Kidney-RCC.clearcell"
obj_Kidney_RCCclearcell <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Kidney_RCCclearcell, legend_on = F, verbose=F, nrow=1)
```


The number of samples and signatures is:
```{r KidneyRCCclearcell1b, echo=FALSE}
dim(obj_Kidney_RCCclearcell$Y)
```

The signatures are:
```{r KidneyRCCclearcell1c, echo=FALSE}
colnames(obj_Kidney_RCCclearcell$Y)
```

\subsubsection{Convergence table}

Essentially, everything has converged.

```{r KidneyRCCclearcell2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Kidney-RCC.clearcell"
melt(all_summaries) %>% filter(value==ct)
```



\subsubsection{Potentially problematic signatures}

There are no problematic signatures.
```{r, KidneyRCCclearcell1d}
colSums(obj_Kidney_RCCclearcell$Y == 0)/nrow(obj_Kidney_RCCclearcell$Y)
colSums(obj_Kidney_RCCclearcell$Y)/sum(obj_Kidney_RCCclearcell$Y)
```

We would need to run \verb|fullRE_DMSL|, because it timed out.

\subsubsection{Betas}

```{r, KidneyRCCclearcell_betas, echo=F, fig.height=4}
ct <- "Kidney-RCC.clearcell"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]], names_cats = logR_nonexo_sorted[[ct]]
)+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```


```{r, KidneyRCCclearcell_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Kidney_RCCclearcell <- wald_TMB_wrapper(fullRE_DMSL_nonexo[["Kidney-RCC.clearcell"]])
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Kidney_RCCclearcell`.

\subsubsection{Covariance matrices}

```{r, KidneyRCCclearcell_cov, echo=FALSE, message=FALSE, fig.height=2.7, fig.width=2.7, dependson=c('Kidney_RCCclearcell_additional_runs')}

ct <- "Kidney-RCC.clearcell"
# models_it_Kidney_RCCclearcell <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Kidney_RCCclearcell <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_Kidney_RCCclearcell <- lapply(models_it_Kidney_RCCclearcell,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Kidney_RCCclearcell) <- models_it_Kidney_RCCclearcell
## because it's fullRE_M, it's sorted
colnames(covmats_Kidney_RCCclearcell[['fullRE_M']]) <- rownames(covmats_Kidney_RCCclearcell[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Kidney_RCCclearcell)$Y))
colnames(covmats_Kidney_RCCclearcell[['fullRE_M_nonexo']]) <- rownames(covmats_Kidney_RCCclearcell[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Kidney_RCCclearcell, nonexogenous$V1)$Y))
colnames(covmats_Kidney_RCCclearcell[['fullRE_DMSL_nonexo']]) <- rownames(covmats_Kidney_RCCclearcell[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Kidney_RCCclearcell, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Kidney_RCCclearcell)){pheatmap(covmats_Kidney_RCCclearcell[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Kidney_RCCclearcell[i], fontsize=7)}
```

```{r, KidneyRCCclearcell_objnonexo, echo=FALSE}
obj_Kidney_RCCclearcell_nonexo <- give_subset_sigs_TMBobj(obj_Kidney_RCCclearcell, sigs_to_remove = nonexogenous$V1)
```

\subsubsection{Simulation under inferred data}
```{r, KidneyRCCclearcell_sim, echo=FALSE, fig.height=2}
sim_Kidney_RCCclearcell <- give_sim_from_estimates("Kidney-RCC.clearcell", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = T, sig_of_interest='SBS12',
                                       tmb_object=fullRE_DMSL_nonexo[["Kidney-RCC.clearcell"]],
                                      obj_data=obj_Kidney_RCCclearcell_nonexo, nrow=1)

sim_Kidney_RCCclearcell[[2]]+ggtitle('Simulation of Kidney-RCC.clearcell samples')+theme_bw()


```


\subsubsection{Ranked plot for coverage}

```{r, KidneyRCCclearcell_ranked_plot, echo=FALSE, fig.height=2.3, dev='png'}
ct <- "Kidney-RCC.clearcell"
integer_overdispersion_param_DMSL <- 1
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Kidney_RCCclearcell_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Kidney_RCCclearcell_nonexo,
                 loglog = F, title = 'obj_Kidney_RCCclearcell (M)', theme_bw=T),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_Kidney_RCCclearcell_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Kidney_RCCclearcell_nonexo,
           loglog = F, title = 'obj_Kidney_RCCclearcell (DMSL)', theme_bw=T), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, KidneyRCCclearcell_mutsigextractor, echo=F, warning=FALSE}
obj_Kidney_RCCclearcell_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Kidney_RCCclearcell_mutSigExtractor, legend_on = FALSE, verbose=FALSE)
```

I should check if this grey exposure corresponds to SBS40.

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations except for perhaps the very few with highest exposure.
```{r, KidneyRCCclearcell_sortedbynummuts, fig.height=2, fig.width=6, warning=FALSE, echo=FALSE}
createBarplot(normalise_rw(non_duplicated_rows(obj_Kidney_RCCclearcell$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Kidney_RCCclearcell$Y)),
                                        decreasing = F)), verbose=F)
```


\subsection{Kidney-RCC.papillary}
It looks very similar to clear cell, looking generally at the signatures.

\subsubsection{Barplot and general statistics}
```{r KidneyRCCpapillary1, echo=FALSE, warning=FALSE, fig.height=2}
ct <- "Kidney-RCC.papillary"
obj_Kidney_RCCpapillary <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Kidney_RCCpapillary, legend_on = F, verbose=F, nrow=1)
```

The number of samples and signatures is:
```{r KidneyRCCpapillary1b, echo=FALSE}
dim(obj_Kidney_RCCpapillary$Y)
```

The signatures are:
```{r KidneyRCCpapillary1c, echo=FALSE}
colnames(obj_Kidney_RCCpapillary$Y)
```

\subsubsection{Convergence table}

Although fulLRE DMSL has in one case converged, it hasn't when using SBS1 as baseline. The nonexogenous version has not converged, but M has.


```{r KidneyRCCpapillary2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Kidney-RCC.papillary"
melt(all_summaries) %>% filter(value==ct)
```


\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo. We first re-run M.
```{r KidneyRCCpapillary3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Kidney-RCC.papillary"

obj_KidneyRCCpapillary <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_KidneyRCCpapillary <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_KidneyRCCpapillary)
sortedM_KidneyRCCpapillary
```

The we use it to re-run DM.
```{r KidneyRCCpapillary3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_KidneyRCCpapillary$Y)-1

sortedDM_KidneyRCCpapillary <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_KidneyRCCpapillary,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_KidneyRCCpapillary$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_KidneyRCCpapillary$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_KidneyRCCpapillary$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_KidneyRCCpapillary$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_KidneyRCCpapillary

```


If we use the values of the fullRE M exo as initial values for the fullRE DMSL exo do converge:
```{r KidneyRCCpapillary3b, echo=FALSE, message=FALSE, dependson=c('KidneyRCCpapillary3')}
sortedDM_KidneyRCCpapillary$pdHess
```


\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures:
```{r, KidneyRCCpapillary1d}
colSums(obj_Kidney_RCCpapillary$Y == 0)/nrow(obj_Kidney_RCCpapillary$Y)
colSums(obj_Kidney_RCCpapillary$Y)/sum(obj_Kidney_RCCpapillary$Y)
```
SBS29 is found in relatively small quantities.

```{r, Kidney_RCCpapillary_additional_runs, dependson=c('additional_runs'), echo=FALSE}
additional_sortedMnonexo[["Kidney-RCC.papillary"]] <- sortedM_KidneyRCCpapillary
additional_sortedDMSLnonexo[["Kidney-RCC.papillary"]] <- sortedDM_KidneyRCCpapillary
```

\subsubsection{Betas}

```{r, KidneyRCCpapillary_betas, echo=F}
ct <- "Kidney-RCC.papillary"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(sortedDM_KidneyRCCpapillary, names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]], names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```



```{r, KidneyRCCpapillary_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Kidney_RCCpapillary <- wald_TMB_wrapper(sortedDM_KidneyRCCpapillary)
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Kidney_RCCpapillary`.

\subsubsection{Covariance matrices}

```{r, KidneyRCCpapillary_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Kidney_RCCpapillary_additional_runs')}

ct <- "Kidney-RCC.papillary"
# models_it_Kidney_RCCpapillary <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Kidney_RCCpapillary <- c('fullRE_M', 'fullRE_M_nonexo', 'additional_sortedDMSLnonexo')
covmats_Kidney_RCCpapillary <- lapply(models_it_Kidney_RCCpapillary,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Kidney_RCCpapillary) <- models_it_Kidney_RCCpapillary
## because it's fullRE_M, it's sorted
colnames(covmats_Kidney_RCCpapillary[['fullRE_M']]) <- rownames(covmats_Kidney_RCCpapillary[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Kidney_RCCpapillary)$Y))
colnames(covmats_Kidney_RCCpapillary[['fullRE_M_nonexo']]) <- rownames(covmats_Kidney_RCCpapillary[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Kidney_RCCpapillary, nonexogenous$V1)$Y))
colnames(covmats_Kidney_RCCpapillary[['additional_sortedDMSLnonexo']]) <- rownames(covmats_Kidney_RCCpapillary[['additional_sortedDMSLnonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Kidney_RCCpapillary, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Kidney_RCCpapillary)){pheatmap(covmats_Kidney_RCCpapillary[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Kidney_RCCpapillary[i])}
```

```{r, KidneyRCCpapillary_objnonexo, echo=FALSE}
obj_Kidney_RCCpapillary_nonexo <- give_subset_sigs_TMBobj(obj_Kidney_RCCpapillary, sigs_to_remove = nonexogenous$V1)
obj_Kidney_RCCpapillary_nonexo_sorted <- sort_columns_TMB(give_subset_sigs_TMBobj(obj_Kidney_RCCpapillary, sigs_to_remove = nonexogenous$V1))
```

\subsubsection{Simulation under inferred data}
```{r, KidneyRCCpapillary_sim, echo=FALSE, fig.height=2.4}
sim_Kidney_RCCpapillary <- give_sim_from_estimates("Kidney-RCC.papillary", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = T,
                                      sig_of_interest='SBS22',
                                      tmb_object=sortedDM_KidneyRCCpapillary,
                                      obj_data=obj_Kidney_RCCpapillary_nonexo_sorted, nrow=1)

sim_Kidney_RCCpapillary[[2]]+ggtitle('Simulation of Kidney-RCC.papillary samples')


```


\subsubsection{Ranked plot for coverage}

```{r, KidneyRCCpapillary_ranked_plot, echo=FALSE, dev='png'}
ct <- "Kidney-RCC.papillary"
integer_overdispersion_param_DMSL <- 1
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Kidney_RCCpapillary_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Kidney_RCCpapillary_nonexo,
                 loglog = F, title = 'obj_Kidney_RCCpapillary (M)', theme_bw=T),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = sortedDM_KidneyRCCpapillary,
                 data_object = obj_Kidney_RCCpapillary_nonexo_sorted,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Kidney_RCCpapillary_nonexo_sorted,
           loglog = F, title = 'obj_Kidney_RCCpapillary (DMSL)', theme_bw=T), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, KidneyRCCpapillary_mutsigextractor, echo=F, warning=FALSE}
obj_Kidney_RCCpapillary_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Kidney_RCCpapillary_mutSigExtractor, legend_on = FALSE, verbose=F)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.
```{r, KidneyRCCpapillary_sortedbynummuts, fig.height=2, fig.width=6, warning=F, echo=F}
createBarplot(normalise_rw(non_duplicated_rows(obj_Kidney_RCCpapillary$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Kidney_RCCpapillary$Y)),
                                        decreasing = F)), verbose=F, remove_labels=T)
```

\subsection{Liver-HCC}
\subsubsection{Barplot and general statistics}
```{r LiverHCC1, echo=FALSE, warning=F}
ct <- "Liver-HCC"
obj_Liver_HCC <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Liver_HCC, legend_on = TRUE, verbose=F)
```


The number of samples and signatures is:
```{r LiverHCC1b, echo=FALSE}
dim(obj_Liver_HCC$Y)
```

The signatures are:
```{r LiverHCC1c, echo=FALSE}
colnames(obj_Liver_HCC$Y)
```


\subsubsection{Convergence table}

The fullRE versions with all signatures have not converged. Neither has \verb|fullRE_M_nonexo|, but \verb|fullRE_DMSL_nonexo| has.
```{r LiverHCC2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Liver-HCC"
melt(all_summaries) %>% filter(value==ct)
```


\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures:
```{r, LiverHCC1d}
colSums(obj_Liver_HCC$Y == 0)/nrow(obj_Liver_HCC$Y)
colSums(obj_Liver_HCC$Y)/sum(obj_Liver_HCC$Y)
```

SBS28 is only present in 7\% of samples and has extremely low exposure - we could consider removing it.


\subsubsection{Betas}

```{r, LiverHCC_betas, echo=F, warning=F}
ct <- "Liver-HCC"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]], names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```

Difficult to see the labels, so I replot it here
```{r, LiverHCC_betasb_zoom, echo=FALSE, ,fig.height=3, fig.width=4.5, eval=TRUE, dev='tikz'}
plot_betas(fullRE_DMSL_nonexo[["Liver-HCC"]], names_cats= logR_nonexo_notsorted[["Liver-HCC"]])+ggtitle(paste0("Liver-HCC", 'fullRE DMSL non-exogenous'))
```


```{r, LiverHCC_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Liver_HCC <- wald_TMB_wrapper(fullRE_DMSL_nonexo[["Liver-HCC"]])
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Liver_HCC`.

\subsubsection{Covariance matrices}

```{r, LiverHCC_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Liver_HCC_additional_runs')}

ct <- "Liver-HCC"
# models_it_Liver_HCC <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Liver_HCC <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_Liver_HCC <- lapply(models_it_Liver_HCC,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Liver_HCC) <- models_it_Liver_HCC
## because it's fullRE_M, it's sorted
colnames(covmats_Liver_HCC[['fullRE_M']]) <- rownames(covmats_Liver_HCC[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Liver_HCC)$Y))
colnames(covmats_Liver_HCC[['fullRE_M_nonexo']]) <- rownames(covmats_Liver_HCC[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Liver_HCC, nonexogenous$V1)$Y))
colnames(covmats_Liver_HCC[['fullRE_DMSL_nonexo']]) <- rownames(covmats_Liver_HCC[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Liver_HCC, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Liver_HCC)){pheatmap(covmats_Liver_HCC[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Liver_HCC[i])}
```

```{r, LiverHCC_objnonexo, echo=FALSE}
obj_Liver_HCC_nonexo <- give_subset_sigs_TMBobj(obj_Liver_HCC, sigs_to_remove = nonexogenous$V1)
```

\subsubsection{Simulation under inferred data}
```{r, LiverHCC_sim, echo=FALSE, fig.height=2.2}
sim_Liver_HCC <- give_sim_from_estimates("Liver-HCC", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = T,
                                      sig_of_interest='SBS19',
                                      tmb_object=fullRE_DMSL_nonexo[["Liver-HCC"]],
                                      obj_data=obj_Liver_HCC_nonexo, nrow=1)

sim_Liver_HCC[[2]]+ggtitle('Simulation of Liver-HCC samples')


```



\subsubsection{Ranked plot for coverage}

Remember that fullRE M has not converged, and it should be re-run:

```{r, LiverHCC_ranked_plot, echo=FALSE, dev='png'}
ct <- "Liver-HCC"
integer_overdispersion_param_DMSL <- 1
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Liver_HCC_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Liver_HCC_nonexo,
                 loglog = F, title = 'obj_Liver_HCC (M)', theme_bw=T),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_Liver_HCC_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Liver_HCC_nonexo,
           loglog = F, title = 'obj_Liver_HCC (DMSL)', theme_bw=T), ncol=2)
```


\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, LiverHCC_mutsigextractor, echo=F, warning=FALSE}
obj_Liver_HCC_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Liver_HCC_mutSigExtractor, legend_on = FALSE, verbose=F)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.

```{r, LiverHCC_sortedbynummuts, fig.height=2, fig.width=6,warning=FALSE, echo=FALSE}
createBarplot(normalise_rw(non_duplicated_rows(obj_Liver_HCC$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Liver_HCC$Y)),
                                        decreasing = F)), verbose=F, remove_labels=T)
```

\subsection{Lung-AdenoCA}
How can we have such few samples?
\subsubsection{Barplot and general statistics}
```{r LungAdenoCA1, echo=FALSE, fig.height=2, warning=FALSE}
ct <- "Lung-AdenoCA"
obj_Lung_AdenoCA <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Lung_AdenoCA, legend_on = F, nrow=1, verbose=F)
```



The number of samples and signatures is:
```{r LungAdenoCA1b, echo=FALSE}
dim(obj_Lung_AdenoCA$Y)
```

The signatures are:
```{r LungAdenoCA1c, echo=FALSE}
colnames(obj_Lung_AdenoCA$Y)
```


\subsubsection{Convergence table}

No fullRE DMSL have converged.
```{r LungAdenoCA2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Lung-AdenoCA"
melt(all_summaries) %>% filter(value==ct)
```


\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo. We re-run fullRE_M_nonexo and it has converged:
```{r LungAdenoCA3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Lung-AdenoCA"

obj_LungAdenoCA <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_LungAdenoCA <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_LungAdenoCA)
sortedM_LungAdenoCA
```

But fullRE DMSL hasn't:
```{r LungAdenoCA3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_LungAdenoCA$Y)-1

sortedDM_LungAdenoCA <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_LungAdenoCA,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_LungAdenoCA$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_LungAdenoCA$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_LungAdenoCA$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_LungAdenoCA$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_LungAdenoCA
```

If we use the values of the fullRE M exo as initial values for the fullRE DMSL exo does not converge:
```{r LungAdenoCA3b, echo=FALSE, message=FALSE, dependson=c('LungAdenoCA3')}
sortedDM_LungAdenoCA$pdHess
```

\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures:
```{r, LungAdenoCA1d}
colSums(obj_Lung_AdenoCA$Y == 0)/nrow(obj_Lung_AdenoCA$Y)
colSums(obj_Lung_AdenoCA$Y)/sum(obj_Lung_AdenoCA$Y)
```
None seem to be problematic.


\subsubsection{Betas}

```{r, LungAdenoCA_betas, echo=F, fig.height=3, warning=FALSE}
ct <- "Lung-AdenoCA"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]], names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```


```{r, LungAdenoCA_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Lung_AdenoCA <- wald_TMB_wrapper(diagRE_DMSL_nonexo[["Lung-AdenoCA"]])
```
We use the results from the diag RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Lung_AdenoCA`.

\subsubsection{Covariance matrices}

```{r, LungAdenoCA_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Lung_AdenoCA_additional_runs')}

ct <- "Lung-AdenoCA"
# models_it_Lung_AdenoCA <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Lung_AdenoCA <- c('fullRE_M', 'fullRE_M_nonexo')
covmats_Lung_AdenoCA <- lapply(models_it_Lung_AdenoCA,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Lung_AdenoCA) <- models_it_Lung_AdenoCA
## because it's fullRE_M, it's sorted
colnames(covmats_Lung_AdenoCA[['fullRE_M']]) <- rownames(covmats_Lung_AdenoCA[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Lung_AdenoCA)$Y))
colnames(covmats_Lung_AdenoCA[['fullRE_M_nonexo']]) <- rownames(covmats_Lung_AdenoCA[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Lung_AdenoCA, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Lung_AdenoCA)){pheatmap(covmats_Lung_AdenoCA[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Lung_AdenoCA[i])}
```

```{r, LungAdenoCA_objnonexo, echo=FALSE}
obj_Lung_AdenoCA_nonexo <- give_subset_sigs_TMBobj(obj_Lung_AdenoCA, sigs_to_remove = nonexogenous$V1)
```

\subsubsection{Simulation under inferred data}
```{r, LungAdenoCA_sim, echo=FALSE, fig.height=2.2}
sim_Lung_AdenoCA <- give_sim_from_estimates("Lung-AdenoCA", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="diagRE_DMSL", bool_nonexo = T,
                                      sig_of_interest='SBS9',
                                      tmb_object=diagRE_DMSL_nonexo[["Lung-AdenoCA"]],
                                      obj_data=obj_Lung_AdenoCA_nonexo, nrow=1)

sim_Lung_AdenoCA[[2]]+ggtitle('Simulation of Lung-AdenoCA samples')+theme_bw()


```

\subsubsection{Ranked plot for coverage}

```{r, LungAdenoCA_ranked_plot, echo=FALSE, dev='png'}
ct <- "Lung-AdenoCA"
integer_overdispersion_param_DMSL <- 1
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Lung_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Lung_AdenoCA_nonexo,
                 loglog = F, title = 'obj_Lung_AdenoCA (M)', theme_bw=T),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                 data_object = obj_Lung_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Lung_AdenoCA_nonexo,
           loglog = F, title = 'obj_Lung_AdenoCA (DMSL)', theme_bw=T), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, LungAdenoCA_mutsigextractor, echo=F, fig.height=2, warning=FALSE}
obj_Lung_AdenoCA_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Lung_AdenoCA_mutSigExtractor, legend_on = FALSE, nrow=1, verbose=F)
```

Exposures sorted by increasing number of mutations: there is a trend in which SBS5 decreases and SBS4 increases with the number of mutations.

```{r, LungAdenoCA_sortedbynummuts, fig.height=2, fig.width=6, warning=FALSE, echo=FALSE}
createBarplot(normalise_rw(non_duplicated_rows(obj_Lung_AdenoCA$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Lung_AdenoCA$Y)),
                                        decreasing = F)), verbose=F, remove_labels=T)
```


\subsection{Lung-SCC}
\subsubsection{Barplot and general statistics}
```{r LungSCC1, echo=FALSE, warning=FALSE, fig.height=2}
ct <- "Lung-SCC"
obj_Lung_SCC <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Lung_SCC, legend_on = F, verbose=F, nrow=1, legend_bottom=T,
                      arg_title='')
```



The number of samples and signatures is:
```{r LungSCC1b, echo=FALSE}
dim(obj_Lung_SCC$Y)
```

The signatures are:
```{r LungSCC1c, echo=FALSE}
colnames(obj_Lung_SCC$Y)
```

\subsubsection{Convergence table}

We have converged results in most cases, and all in nonexo.

```{r LungSCC2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Lung-SCC"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures; none are.
```{r, LungSCC1d}
colSums(obj_Lung_SCC$Y == 0)/nrow(obj_Lung_SCC$Y)
colSums(obj_Lung_SCC$Y)/sum(obj_Lung_SCC$Y)
```

\subsubsection{Betas}

Very clear example of only one signature changing:

```{r, LungSCC_betas, echo=F, warning=FALSE}
ct <- "Lung-SCC"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]], names_cats = logR_nonexo_sorted[[ct]]
)+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```

```{r, LungSCC_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Lung_SCC <- wald_TMB_wrapper(fullRE_DMSL_nonexo[["Lung-SCC"]])
```

We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Lung_SCC`.

\subsubsection{Covariance matrices}

```{r, LungSCC_cov, echo=FALSE, message=FALSE, fig.height=2.7, fig.width=2.7, dependson=c('Lung_SCC_additional_runs')}

ct <- "Lung-SCC"
# models_it_Lung_SCC <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Lung_SCC <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_Lung_SCC <- lapply(models_it_Lung_SCC,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Lung_SCC) <- models_it_Lung_SCC
## because it's fullRE_M, it's sorted
colnames(covmats_Lung_SCC[['fullRE_M']]) <- rownames(covmats_Lung_SCC[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Lung_SCC)$Y))
colnames(covmats_Lung_SCC[['fullRE_M_nonexo']]) <- rownames(covmats_Lung_SCC[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Lung_SCC, nonexogenous$V1)$Y))
colnames(covmats_Lung_SCC[['fullRE_DMSL_nonexo']]) <- rownames(covmats_Lung_SCC[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Lung_SCC, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Lung_SCC)){pheatmap(covmats_Lung_SCC[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Lung_SCC[i])}
```


\subsubsection{Ranked plot for coverage}

```{r, LungSCC_ranked_plot, echo=FALSE, fig.height=3, fig.width=4, dev='png'}
ct <- "Lung-SCC"
integer_overdispersion_param_DMSL <- 1
obj_Lung_SCC_nonexo <- give_subset_sigs_TMBobj(obj_Lung_SCC, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Lung_SCC_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Lung_SCC_nonexo,
                 loglog = F, title = 'obj_Lung_SCC (M)', theme_bw=T),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_Lung_SCC_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Lung_SCC_nonexo,
           loglog = F, title = 'obj_Lung_SCC (DMSL)', theme_bw=T), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, LungSCC_mutsigextractor, echo=F, warning=F, fig.height=2}
obj_Lung_SCC_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Lung_SCC_mutSigExtractor, legend_on = FALSE, verbose=F, nrow=1)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.

```{r, LungSCC_sortedbynummuts, fig.height=2, fig.width=6, echo=F}
createBarplot(normalise_rw(non_duplicated_rows(obj_Lung_SCC$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Lung_SCC$Y)),
                                        decreasing = F)), verbose=F, remove_labels=T)
```

\subsection{Lymph-BNHL}
\subsubsection{Barplot and general statistics}
```{r LymphBNHL1, echo=FALSE, fig.height=2, warning=F}
ct <- "Lymph-BNHL"
obj_Lymph_BNHL <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Lymph_BNHL, legend_on = F, nrow=1, verbose=F)
```



The number of samples and signatures is:
```{r LymphBNHL1b, echo=FALSE}
dim(obj_Lymph_BNHL$Y)
```

The signatures are:
```{r LymphBNHL1c, echo=FALSE}
colnames(obj_Lymph_BNHL$Y)
```


\subsubsection{Convergence table}

fullRE_DMSL_nonexo had not run, and fullRE_M_nonexo didn't converge.
```{r LymphBNHL2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Lymph-BNHL"
melt(all_summaries) %>% filter(value==ct)
```



\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo. Very clearly there are too many signatures.
```{r LymphBNHL3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Lymph-BNHL"

obj_LymphBNHL <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_LymphBNHL <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_LymphBNHL)
sortedM_LymphBNHL
```

Which signatures should be omitted from the analysis?

```{r, LymphBNHL_remove_small_signatures, fig.height=2, echo=F}

ggplot(melt(obj_LymphBNHL$Y), aes(x=Var2, y=value+1))+geom_violin()+scale_y_continuous(trans = "log2")

```

SBS13 and SBS39 should definitely be removed.

```{r LymphBNHL3_subset, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Lymph-BNHL"

obj_LymphBNHL <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                c(nonexogenous$V1, 'SBS13', 'SBS39')))
sortedM_LymphBNHL <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_LymphBNHL, use_nlminb=T)
sortedM_LymphBNHL
```

Has fullRE M now converged?
converge:
```{r LymphBNHL3_subset_conv, echo=FALSE, message=FALSE, dependson=c('LymphBNHL3')}
sortedM_LymphBNHL$pdHess
```

it has. I now run DM with this subset

```{r LymphBNHL3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_LymphBNHL$Y)-1

sortedDM_LymphBNHL <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_LymphBNHL,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_LymphBNHL$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_LymphBNHL$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_LymphBNHL$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_LymphBNHL$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_LymphBNHL

```

Its convergence is as follows:

```{r LymphBNHL3b, echo=FALSE, message=FALSE, dependson=c('LymphBNHL3')}
sortedDM_LymphBNHL$pdHess
```

it has also converged

```{r, Lymph_BNHL_additional_runs, dependson=c('additional_runs'), echo=F}
additional_sortedMnonexo[["Lymph-BNHL"]] <- sortedM_LymphBNHL
additional_sortedDMSLnonexo[["Lymph-BNHL"]] <- sortedDM_LymphBNHL
```


\subsubsection{Betas}

```{r, LymphBNHL_betas, echo=F, warning=F, fig.height=4}
ct <- "Lymph-BNHL"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(additional_sortedMnonexo[[ct]], names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(additional_sortedDMSLnonexo[[ct]], names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]], names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```


```{r, LymphBNHL_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Lymph_BNHL <- wald_TMB_wrapper(sortedDM_LymphBNHL)
```
We use the results from the full RE single lambda DM with the subset of signatures (removing thw two problematic ones) to test for differential abundance, giving a p-value of `r pval_Lymph_BNHL`.

\subsubsection{Covariance matrices}

```{r, LymphBNHL_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Lymph_BNHL_additional_runs')}

ct <- "Lymph-BNHL"
models_it_Lymph_BNHL <- c('fullRE_M', 'additional_sortedMnonexo', 'additional_sortedDMSLnonexo')
covmats_Lymph_BNHL <- lapply(models_it_Lymph_BNHL,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Lymph_BNHL) <- models_it_Lymph_BNHL
## because it's fullRE_M, it's sorted
colnames(covmats_Lymph_BNHL[['fullRE_M']]) <- rownames(covmats_Lymph_BNHL[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Lymph_BNHL)$Y))
colnames(covmats_Lymph_BNHL[['additional_sortedMnonexo']]) <- rownames(covmats_Lymph_BNHL[['additional_sortedMnonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Lymph_BNHL,c(nonexogenous$V1, 'SBS13', 'SBS39'))$Y))
colnames(covmats_Lymph_BNHL[['additional_sortedDMSLnonexo']]) <- rownames(covmats_Lymph_BNHL[['additional_sortedDMSLnonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Lymph_BNHL,c(nonexogenous$V1, 'SBS13', 'SBS39'))$Y))
for(i in 1:length(covmats_Lymph_BNHL)){pheatmap(covmats_Lymph_BNHL[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Lymph_BNHL[i])}
```

```{r, LymphBNHL_objnonexo, echo=FALSE}

# obj_Lymph_BNHL_nonexo_sorted <- sort_columns_TMB(give_subset_sigs_TMBobj(obj_Lymph_BNHL,
#                                                  sigs_to_remove = c(nonexogenous$V1, 'SBS13', 'SBS39')))
# obj_Lymph_BNHL_nonexo <- give_subset_sigs_TMBobj(obj_Lymph_BNHL,
#                                                  sigs_to_remove = c(nonexogenous$V1, 'SBS13', 'SBS39'))

```

\subsubsection{Simulation under inferred data}
```{r, LymphBNHL_sim, echo=FALSE, fig.height=2.4}
sim_Lymph_BNHL <- give_sim_from_estimates("Lymph-BNHL", "signatures",
                                      sigs_to_remove=c(unique(nonexogenous$V1), 'SBS13', 'SBS39'),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = T,
                                      sig_of_interest='SBS6',
                                      tmb_object=sortedDM_LymphBNHL,
                                      obj_data=obj_LymphBNHL, nrow=1)

sim_Lymph_BNHL[[2]]+ggtitle('Simulation of Lymph-BNHL samples')+theme_bw()


```


\subsubsection{Ranked plot for coverage}

```{r, LymphBNHL_ranked_plot, echo=FALSE, fig.height=2.5,fig.width=6, dev='png'}
ct <- "Lymph-BNHL"
integer_overdispersion_param_DMSL <- 1
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = sortedM_LymphBNHL,
                 data_object = obj_LymphBNHL,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_LymphBNHL,
                 loglog = F, title = 'obj_Lymph_BNHL (M)', theme_bw=T),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = sortedDM_LymphBNHL,
                 data_object = obj_LymphBNHL,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_LymphBNHL,
           loglog = F, title = 'obj_Lymph_BNHL (DMSL)', theme_bw=T), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:

```{r, LymphBNHL_mutsigextractor, echo=F, warning=F, fig.height=1}
obj_Lymph_BNHL_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Lymph_BNHL_mutSigExtractor, legend_on = FALSE, verbose=F, nrow=1)
```

something must have gone wrong here. Dims of Y for mutsigextractor and normal signatures:

```{r, LymphBNHL_mutsigextractor2, echo=F, warning=F, fig.height=1}
dim(obj_Lymph_BNHL_mutSigExtractor$Y)
dim(obj_Lymph_BNHL$Y)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.

```{r, LymphBNHL_sortedbynummuts, fig.height=2, fig.width=6, echo=F}
createBarplot(normalise_rw(non_duplicated_rows(obj_Lymph_BNHL$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Lymph_BNHL$Y)),
                                        decreasing = F)), remove_labels=T, verbose=F)
```

\subsection{Lymph-CLL}

\subsubsection{Barplot and general statistics}
```{r LymphCLL1, echo=FALSE, fig.height=1, warning=FALSE}
ct <- "Lymph-CLL"
obj_Lymph_CLL <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Lymph_CLL, legend_on = F, verbose=F, nrow=1)
```



The number of samples and signatures is:
```{r LymphCLL1b, echo=FALSE}
dim(obj_Lymph_CLL$Y)
```

The signatures are:
```{r LymphCLL1c, echo=FALSE}
colnames(obj_Lymph_CLL$Y)
```


\subsubsection{Convergence table}

We have converged results in most cases

```{r LymphCLL2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Lymph-CLL"
melt(all_summaries) %>% filter(value==ct)
```


\subsubsection{Potentially problematic signatures}
SBS9 has quite a lot of zeros.
```{r, LymphCLL1d}
colSums(obj_Lymph_CLL$Y == 0)/nrow(obj_Lymph_CLL$Y)
colSums(obj_Lymph_CLL$Y)/sum(obj_Lymph_CLL$Y)
```



\subsubsection{Betas}

It's interesting the very high correlation between intercept and slope betas.

```{r, LymphCLL_betas, echo=F, fig.height=3.5}
ct <- "Lymph-CLL"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
  # plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')), nrow=2)
```




```{r, LymphCLL_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Lymph_CLL <- wald_TMB_wrapper(fullRE_DMSL_nonexo[["Lymph-CLL"]])
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Lymph_CLL`.


\subsubsection{Covariance matrices}



```{r, LymphCLL_cov, echo=FALSE, message=FALSE, fig.height=2.7, fig.width=2.7, dependson=c('Lymph_CLL_additional_runs')}

ct <- "Lymph-CLL"
# models_it_Lymph_CLL <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Lymph_CLL <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_Lymph_CLL <- lapply(models_it_Lymph_CLL,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Lymph_CLL) <- models_it_Lymph_CLL
## because it's fullRE_M, it's sorted
colnames(covmats_Lymph_CLL[['fullRE_M']]) <- rownames(covmats_Lymph_CLL[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Lymph_CLL)$Y))
colnames(covmats_Lymph_CLL[['fullRE_M_nonexo']]) <- rownames(covmats_Lymph_CLL[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Lymph_CLL, nonexogenous$V1)$Y))
colnames(covmats_Lymph_CLL[['fullRE_DMSL_nonexo']]) <- rownames(covmats_Lymph_CLL[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Lymph_CLL, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Lymph_CLL)){pheatmap(covmats_Lymph_CLL[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Lymph_CLL[i])}
```


```{r, LymphCLL_objnonexo, echo=FALSE}
obj_Lymph_CLL_nonexo <- give_subset_sigs_TMBobj(obj_Lymph_CLL, sigs_to_remove = nonexogenous$V1)
```

\subsubsection{Simulation under inferred data}
```{r, LymphCLL_sim, echo=FALSE, fig.height=2}
sim_Lymph_CLL <- give_sim_from_estimates("Lymph-CLL", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = T,
                                      tmb_object=fullRE_DMSL_nonexo[["Lymph-CLL"]],
                                      obj_data=obj_Lymph_CLL_nonexo,
                                      sig_of_interest='SBS9', nrow=1)

sim_Lymph_CLL[[2]]+ggtitle('Simulation of Lymph-CLL samples')


```



\subsubsection{Ranked plot for coverage}

```{r, LymphCLL_ranked_plot, warning=F, echo=F, fig.height=2, dev='png'}
ct <- "Lymph-CLL"
integer_overdispersion_param_DMSL <- 1
for(loglog_bool_it in c(T,F)){
  .full_rankedplot <-    give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[["Lymph-CLL"]],
                   data_object = obj_Lymph_CLL_nonexo,
                   print_plot = F, nreps = 100, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                     lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                            rank_number=1:length(j)) )})[[1]],
                   data_object = obj_Lymph_CLL_nonexo,
             loglog = loglog_bool_it, title = 'obj_Lymph_CLL nonexo (fullRE DMSL)', theme_bw=T)
  grid.arrange(
    give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                   data_object = obj_Lymph_CLL_nonexo,
                   print_plot = F, nreps = 100, model = "M")), function(i){
                     lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                            rank_number=1:length(j)) )})[[1]],
                   data_object = obj_Lymph_CLL_nonexo,
                   loglog = loglog_bool_it, title = 'obj_Lymph_CLL nonexo (M)', theme_bw=T),
    .full_rankedplot, ncol=2)

  grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                   data_object = obj_Lymph_CLL_nonexo,
                   print_plot = F, nreps = 100, model = "DMSL",
                   integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                     lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                            rank_number=1:length(j)) )})[[1]],
                   data_object = obj_Lymph_CLL_nonexo,
                   loglog = loglog_bool_it, title = 'obj_Lymph_CLL nonexo (diagRE DMSL)', theme_bw=T),
               .full_rankedplot, ncol=2)

}
```


\subsubsection{Signatures from mutSigExtractor}

These are the signatures from mutSigExtractor:
```{r, LymphCLL_mutsigextractor, echo=F, warning=FALSE, fig.height=2}
obj_Lymph_CLL_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Lymph_CLL_mutSigExtractor, legend_on = FALSE, verbose=F, nrow=1)
```

Exposures sorted by increasing number of mutations: SBS9 and SBS25 seem to be somewhat associated with samples with a high number of mutations.

```{r, LymphCLL_sortedbynummuts, fig.height=2, echo=FALSE}
createBarplot(normalise_rw(non_duplicated_rows(obj_Lymph_CLL$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Lymph_CLL$Y)),
                                        decreasing = F)), remove_labels=T, verbose=F)
```



\subsection{Myeloid-MPN}

\subsubsection{Barplot and general statistics}
```{r MyeloidMPN1, echo=FALSE, warning=FALSE, fig.height=2}
ct <- "Myeloid-MPN"
obj_Myeloid_MPN <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Myeloid_MPN, legend_on = F, verbose=F, nrow=1)
```

The number of samples and signatures is:
```{r MyeloidMPN1b, echo=FALSE}
dim(obj_Myeloid_MPN$Y)
```

The signatures are:
```{r MyeloidMPN1c, echo=FALSE}
colnames(obj_Myeloid_MPN$Y)
```

\subsubsection{Convergence table}

These are the results for the convergence of models fits. The fullRE DMSL have not converged, or have not run.

```{r MyeloidMPN2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Myeloid-MPN"
melt(all_summaries) %>% filter(value==ct)
```


\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo.
```{r MyeloidMPN3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Myeloid-MPN"

obj_MyeloidMPN <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_MyeloidMPN <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_MyeloidMPN)
sortedM_MyeloidMPN
```

```{r MyeloidMPN3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_MyeloidMPN$Y)-1

sortedDM_MyeloidMPN <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_MyeloidMPN,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_MyeloidMPN$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_MyeloidMPN$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_MyeloidMPN$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_MyeloidMPN$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_MyeloidMPN

```

If we use the values of the fullRE M exo as initial values for the fullRE DMSL exo do converge:
```{r MyeloidMPN3b, echo=FALSE, message=FALSE, dependson=c('MyeloidMPN3')}
sortedDM_MyeloidMPN$pdHess
```


\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures. There are none.
```{r, MyeloidMPN1d}
colSums(obj_Myeloid_MPN$Y == 0)/nrow(obj_Myeloid_MPN$Y)
colSums(obj_Myeloid_MPN$Y)/sum(obj_Myeloid_MPN$Y)
```

```{r, Myeloid_MPN_additional_runs, dependson=c('additional_runs'), echo=F}
additional_sortedMnonexo[["Myeloid-MPN"]] <- sortedM_MyeloidMPN
additional_sortedDMSLnonexo[["Myeloid-MPN"]] <- sortedDM_MyeloidMPN
```


```{r, MyeloidMPN_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Myeloid_MPN <- wald_TMB_wrapper(sortedDM_MyeloidMPN)
```

We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Myeloid_MPN`.


\subsubsection{Betas}

```{r, MyeloidMPN_betas, echo=F, fig.height=3.5}
ct <- "Myeloid-MPN"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(sortedDM_MyeloidMPN, names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')), nrow=2)
```

\subsubsection{Covariance matrices}

```{r, MyeloidMPN_cov, echo=FALSE, message=FALSE, fig.height=2.5, fig.width=2.5, dependson=c('Myeloid_MPN_additional_runs')}

ct <- "Myeloid-MPN"
models_it_Myeloid_MPN <- c('fullRE_M', 'fullRE_M_nonexo', 'additional_sortedDMSLnonexo')
covmats_Myeloid_MPN <- lapply(models_it_Myeloid_MPN,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Myeloid_MPN) <- models_it_Myeloid_MPN
## because it's fullRE_M, it's sorted
colnames(covmats_Myeloid_MPN[['fullRE_M']]) <- rownames(covmats_Myeloid_MPN[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Myeloid_MPN)$Y))
colnames(covmats_Myeloid_MPN[['fullRE_M_nonexo']]) <- rownames(covmats_Myeloid_MPN[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Myeloid_MPN, nonexogenous$V1)$Y))
colnames(covmats_Myeloid_MPN[['additional_sortedDMSLnonexo']]) <- rownames(covmats_Myeloid_MPN[['additional_sortedDMSLnonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Myeloid_MPN, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Myeloid_MPN)){pheatmap(covmats_Myeloid_MPN[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Myeloid_MPN[i], fontsize = 7)}
```

```{r, MyeloidMPN_objnonexo, echo=FALSE}
obj_Myeloid_MPN_nonexo <- (give_subset_sigs_TMBobj(obj_Myeloid_MPN, sigs_to_remove = nonexogenous$V1))
obj_Myeloid_MPN_nonexo_sorted <- sort_columns_TMB(give_subset_sigs_TMBobj(obj_Myeloid_MPN, sigs_to_remove = nonexogenous$V1))
```

\subsubsection{Simulation under inferred data}
```{r, MyeloidMPN_sim, echo=FALSE, fig.height=2}
sim_Myeloid_MPN <- give_sim_from_estimates("Myeloid-MPN", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = T,
                                       tmb_object=sortedDM_MyeloidMPN,
                                      obj_data=obj_Myeloid_MPN_nonexo_sorted, nrow=1)

sim_Myeloid_MPN[[2]]+ggtitle('Simulation of Myeloid-MPN samples')+theme_bw()


```


\subsubsection{Ranked plot for coverage}

```{r, MyeloidMPN_ranked_plot, echo=F, fig.height=5, dev='png'}
ct <- "Myeloid-MPN"
integer_overdispersion_param_DMSL <- 1
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Myeloid_MPN_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Myeloid_MPN_nonexo,
                 loglog = F, title = 'obj_Myeloid_MPN (M)', theme_bw=T),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = sortedDM_MyeloidMPN,
                 data_object = obj_Myeloid_MPN_nonexo_sorted,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Myeloid_MPN_nonexo_sorted,
           loglog = F, title = 'obj_Myeloid_MPN (DMSL)', theme_bw=T), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, MyeloidMPN_mutsigextractor, echo=F, fig.height=2, warning=FALSE}
obj_Myeloid_MPN_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Myeloid_MPN_mutSigExtractor, legend_on = FALSE, nrow=1, verbose=F)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.

```{r, MyeloidMPN_sortedbynummuts, fig.height=2, fig.width=6, echo=FALSE}
createBarplot(normalise_rw(non_duplicated_rows(obj_Myeloid_MPN$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Myeloid_MPN$Y)),
                                        decreasing = F)), remove_labels=T, verbose=F)
```

\subsection{Ovary-AdenoCA}
\subsubsection{Barplot and general statistics}
```{r OvaryAdenoCA1, echo=FALSE}
ct <- "Ovary-AdenoCA"
obj_Ovary_AdenoCA <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Ovary_AdenoCA, legend_on = TRUE, verbose=F)
```



The number of samples and signatures is:
```{r OvaryAdenoCA1b, echo=FALSE}
dim(obj_Ovary_AdenoCA$Y)
```

The signatures are:
```{r OvaryAdenoCA1c, echo=FALSE}
colnames(obj_Ovary_AdenoCA$Y)
```

\subsubsection{Convergence table}

These are the results for the convergence of models fits. None of the all-signatures models converged (we do have many signatures!) but nonexo generally have, except fullRE_DMSL_nonexo.

```{r OvaryAdenoCA2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Ovary-AdenoCA"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo.
```{r OvaryAdenoCA3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Ovary-AdenoCA"

obj_OvaryAdenoCA <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_OvaryAdenoCA <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_OvaryAdenoCA)
sortedM_OvaryAdenoCA
```

```{r OvaryAdenoCA3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_OvaryAdenoCA$Y)-1

sortedDM_OvaryAdenoCA <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_OvaryAdenoCA,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_OvaryAdenoCA$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_OvaryAdenoCA$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_OvaryAdenoCA$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_OvaryAdenoCA$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_OvaryAdenoCA
```


If we use the values of the fullRE M exo as initial values for the fullRE DMSL exo do not yet converge:
```{r OvaryAdenoCA3b, echo=FALSE, message=FALSE, dependson=c('OvaryAdenoCA3')}
sortedDM_OvaryAdenoCA$pdHess

```


\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures. There doesn't seem to be.
```{r, OvaryAdenoCA1d}
colSums(obj_Ovary_AdenoCA$Y == 0)/nrow(obj_Ovary_AdenoCA$Y)
colSums(obj_Ovary_AdenoCA$Y)/sum(obj_Ovary_AdenoCA$Y)
```


\subsubsection{Betas}

```{r, OvaryAdenoCA_betas, echo=F, warning=FALSE}
ct <- "Ovary-AdenoCA"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(sortedDM_OvaryAdenoCA, names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]], names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```


```{r, OvaryAdenoCA_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Ovary_AdenoCA <- wald_TMB_wrapper(diagRE_DMSL_nonexo[["Ovary-AdenoCA"]])
```

We use the results from the diag RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Ovary_AdenoCA`.

\subsubsection{Covariance matrices}

Keep in mind that fullRE DMSL nonexo has not converged.

```{r, OvaryAdenoCA_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Ovary_AdenoCA_additional_runs')}

ct <- "Ovary-AdenoCA"
# models_it_Ovary_AdenoCA <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Ovary_AdenoCA <- c('fullRE_M_nonexo')
covmats_Ovary_AdenoCA <- lapply(models_it_Ovary_AdenoCA,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Ovary_AdenoCA) <- models_it_Ovary_AdenoCA
## because it's fullRE_M, it's sorted
# colnames(covmats_Ovary_AdenoCA[['fullRE_M']]) <- rownames(covmats_Ovary_AdenoCA[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Ovary_AdenoCA)$Y))
colnames(covmats_Ovary_AdenoCA[['fullRE_M_nonexo']]) <- rownames(covmats_Ovary_AdenoCA[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Ovary_AdenoCA, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Ovary_AdenoCA)){pheatmap(covmats_Ovary_AdenoCA[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Ovary_AdenoCA[i])}
```


\subsubsection{Simulation under inferred data}
Using diagRE DMSL nonexo.

```{r, OvaryAdenoCA_obj_nonexo, echo=FALSE}
obj_Ovary_AdenoCA_nonexo <- give_subset_sigs_TMBobj(obj_Ovary_AdenoCA, sigs_to_remove = nonexogenous$V1)
```

```{r, OvaryAdenoCA_sim, echo=FALSE, fig.height=2}
sim_Ovary_AdenoCA <- give_sim_from_estimates("Ovary-AdenoCA", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="diagRE_DMSL", bool_nonexo = T,
                                      tmb_object=diagRE_DMSL_nonexo[[ct]],
                                      obj_data=obj_Ovary_AdenoCA_nonexo, nrow=1)

sim_Ovary_AdenoCA[[2]]+ggtitle('Simulation of Ovary-AdenoCA samples')+theme_bw()


```

\subsubsection{Ranked plot for coverage}

```{r, OvaryAdenoCA_ranked_plot, echo=FALSE, fig.height=3, dev='png'}
ct <- "Ovary-AdenoCA"
integer_overdispersion_param_DMSL <- 1
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Ovary_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Ovary_AdenoCA_nonexo,
                 loglog = F, title = 'obj_Ovary_AdenoCA (M)', theme_bw=T),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                 data_object = obj_Ovary_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Ovary_AdenoCA_nonexo,
           loglog = F, title = 'obj_Ovary_AdenoCA (DMSL)', theme_bw=T), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, OvaryAdenoCA_mutsigextractor, echo=F, warning=FALSE}
obj_Ovary_AdenoCA_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Ovary_AdenoCA_mutSigExtractor, legend_on = FALSE, verbose=F)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.

```{r, OvaryAdenoCA_sortedbynummuts, fig.height=2, fig.width=6, echo=FALSE}
createBarplot(normalise_rw(non_duplicated_rows(obj_Ovary_AdenoCA$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Ovary_AdenoCA$Y)),
                                        decreasing = F)), verbose=F, remove_labels=T)
```


\subsection{Panc-AdenoCA}
\subsubsection{Barplot and general statistics}
```{r PancAdenoCA1, echo=FALSE}
ct <- "Panc-AdenoCA"
obj_Panc_AdenoCA <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Panc_AdenoCA, legend_on = TRUE, verbose=F)
```



The number of samples and signatures is:
```{r PancAdenoCA1b, echo=FALSE}
dim(obj_Panc_AdenoCA$Y)
```

The signatures are:
```{r PancAdenoCA1c, echo=FALSE}
colnames(obj_Panc_AdenoCA$Y)
```

\subsubsection{Convergence table}

These are the results for the convergence of models fits. Most runs have converged. fullRE_DMSL_nonexo hadn't run.

```{r PancAdenoCA2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Panc-AdenoCA"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo. M hasn't converged.
```{r PancAdenoCA3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Panc-AdenoCA"

obj_PancAdenoCA <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_PancAdenoCA <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_PancAdenoCA)
sortedM_PancAdenoCA
```



\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures. SBS17a is potentially problematic.
```{r, PancAdenoCA1d}
colSums(obj_Panc_AdenoCA$Y == 0)/nrow(obj_Panc_AdenoCA$Y)
colSums(obj_Panc_AdenoCA$Y)/sum(obj_Panc_AdenoCA$Y)
```

From the violin plot, none seem too problematic.

```{r, obj_Panc_AdenoCA_remove_small_signatures, fig.height=1.3, echo=FALSE}
ggplot(melt(obj_Panc_AdenoCA$Y), aes(x=Var2, y=value+1))+geom_violin()+scale_y_continuous(trans = "log2")
```

\subsubsection{Betas}

```{r, PancAdenoCA_betas, echo=F, warning=FALSE, fig.height=3.5}
ct <- "Panc-AdenoCA"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]], names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```


```{r, PancAdenoCA_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Panc_AdenoCA <- wald_TMB_wrapper(diagRE_DMSL_nonexo[["Panc-AdenoCA"]])
```

We use the results from the diag RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Panc_AdenoCA`.

\subsubsection{Covariance matrices}

```{r, PancAdenoCA_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Panc_AdenoCA_additional_runs')}

ct <- "Panc-AdenoCA"
# models_it_Panc_AdenoCA <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Panc_AdenoCA <- c('fullRE_M', 'fullRE_M_nonexo')
covmats_Panc_AdenoCA <- lapply(models_it_Panc_AdenoCA,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Panc_AdenoCA) <- models_it_Panc_AdenoCA
## because it's fullRE_M, it's sorted
colnames(covmats_Panc_AdenoCA[['fullRE_M']]) <- rownames(covmats_Panc_AdenoCA[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Panc_AdenoCA)$Y))
colnames(covmats_Panc_AdenoCA[['fullRE_M_nonexo']]) <- rownames(covmats_Panc_AdenoCA[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Panc_AdenoCA, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Panc_AdenoCA)){pheatmap(covmats_Panc_AdenoCA[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Panc_AdenoCA[i])}
```

```{r, PancAdenoCA_objnonexo, echo=FALSE}
obj_Panc_AdenoCA_nonexo <- give_subset_sigs_TMBobj(obj_Panc_AdenoCA, sigs_to_remove = nonexogenous$V1)
```

\subsubsection{Simulation under inferred data}

```{r, PancAdenoCA_sim, echo=FALSE, fig.height=2}
sim_Panc_AdenoCA <- give_sim_from_estimates("Panc-AdenoCA", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="diagRE_DMSL", bool_nonexo = T,
                                      tmb_object=diagRE_DMSL_nonexo[["Panc-AdenoCA"]],
                                      obj_data=obj_Panc_AdenoCA_nonexo, nrow=1)

sim_Panc_AdenoCA[[2]]+ggtitle('Simulation of Panc-AdenoCA samples')+theme_bw()


```

Multinomial:

```{r, PancAdenoCA_sim_M, echo=FALSE, fig.height=2}
sim_Panc_AdenoCA <- give_sim_from_estimates("Panc-AdenoCA", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_M", bool_nonexo = F,
                                      tmb_object=fullRE_M_nonexo[["Panc-AdenoCA"]],
                                      obj_data=obj_Panc_AdenoCA_nonexo, nrow=1)

sim_Panc_AdenoCA[[2]]+ggtitle('Simulation of Panc-AdenoCA samples\nUsing multinomial')+theme_bw()


```

\subsubsection{Ranked plot for coverage}

```{r, PancAdenoCA_ranked_plot, echo=F, dev='png'}
ct <- "Panc-AdenoCA"
integer_overdispersion_param_DMSL <- 1
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Panc_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Panc_AdenoCA_nonexo,
                 loglog = F, title = 'obj_Panc_AdenoCA (M)', theme_bw=T),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                 data_object = obj_Panc_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Panc_AdenoCA_nonexo,
           loglog = F, title = 'obj_Panc_AdenoCA (DMSL)', theme_bw=T), ncol=2)
```


\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, PancAdenoCA_mutsigextractor, echo=F, warning=F, fig.height=1.5}
obj_Panc_AdenoCA_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Panc_AdenoCA_mutSigExtractor, legend_on = FALSE, verbose=F, nrow=1)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.

```{r, PancAdenoCA_sortedbynummuts, fig.height=2, fig.width=6, echo=F}
createBarplot(normalise_rw(non_duplicated_rows(obj_Panc_AdenoCA$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Panc_AdenoCA$Y)),
                                        decreasing = F)), remove_labels=T, verbose=F)
```

\clearpage
\subsection{Panc-Endocrine}


\subsubsection{Barplot and general statistics}
```{r PancEndocrine1, echo=FALSE}
ct <- "Panc-Endocrine"
obj_Panc_Endocrine <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Panc_Endocrine, legend_on = TRUE, verbose=F)
```



The number of samples and signatures is:
```{r PancEndocrine1b, echo=FALSE}
dim(obj_Panc_Endocrine$Y)
```

The signatures are:
```{r PancEndocrine1c, echo=FALSE}
colnames(obj_Panc_Endocrine$Y)
```


\subsubsection{Convergence table}

These are the results for the convergence of models fits. fullRE_DMSL and fullRE_DMSL_nonexo haven't.

```{r PancEndocrine2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Panc-Endocrine"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo.
```{r PancEndocrine3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Panc-Endocrine"

obj_PancEndocrine <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_PancEndocrine <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_PancEndocrine)
sortedM_PancEndocrine
```

```{r PancEndocrine3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_PancEndocrine$Y)-1

sortedDM_PancEndocrine <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_PancEndocrine,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_PancEndocrine$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_PancEndocrine$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_PancEndocrine$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_PancEndocrine$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_PancEndocrine

```


If we use the values of the fullRE M exo as initial values for the fullRE DMSL exo doesn't converge:
```{r PancEndocrine3b, echo=FALSE, message=FALSE, dependson=c('PancEndocrine3')}
sortedDM_PancEndocrine$pdHess
```

\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures:
```{r, PancEndocrine1d}
colSums(obj_Panc_Endocrine$Y == 0)/nrow(obj_Panc_Endocrine$Y)
colSums(obj_Panc_Endocrine$Y)/sum(obj_Panc_Endocrine$Y)
```


\subsubsection{Betas}

```{r, PancEndocrine_betas, echo=F, warning=F, fig.height=3.8}
ct <- "Panc-Endocrine"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]] , names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(sortedDM_PancEndocrine, names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]], names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```



```{r, PancEndocrine_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Panc_Endocrine <- wald_TMB_wrapper(diagRE_DMSL_nonexo[["Panc-Endocrine"]])
```

We use the results from the diag RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Panc_Endocrine`.

\subsubsection{Covariance matrices}

```{r, PancEndocrine_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Panc_Endocrine_additional_runs')}

ct <- "Panc-Endocrine"
# models_it_Panc_Endocrine <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Panc_Endocrine <- c('fullRE_M', 'fullRE_M_nonexo')
covmats_Panc_Endocrine <- lapply(models_it_Panc_Endocrine,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Panc_Endocrine) <- models_it_Panc_Endocrine
## because it's fullRE_M, it's sorted
colnames(covmats_Panc_Endocrine[['fullRE_M']]) <- rownames(covmats_Panc_Endocrine[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Panc_Endocrine)$Y))
colnames(covmats_Panc_Endocrine[['fullRE_M_nonexo']]) <- rownames(covmats_Panc_Endocrine[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Panc_Endocrine, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Panc_Endocrine)){pheatmap(covmats_Panc_Endocrine[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Panc_Endocrine[i])}
```

```{r, PancEndocrine_objnonexo, echo=FALSE}
obj_Panc_Endocrine_nonexo <- give_subset_sigs_TMBobj(obj_Panc_Endocrine, sigs_to_remove = nonexogenous$V1)
```

\subsubsection{Simulation under inferred data}
```{r, PancEndocrine_sim, echo=FALSE, fig.height=2.2}
sim_Panc_Endocrine <- give_sim_from_estimates("Panc-Endocrine", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="diagRE_DMSL", bool_nonexo = T,
                                      tmb_object=diagRE_DMSL_nonexo[[ct]],
                                      obj_data=obj_Panc_Endocrine_nonexo, nrow=1)

sim_Panc_Endocrine[[2]]+ggtitle('Simulation of Panc-Endocrine samples')+theme_bw()


```

\subsubsection{Ranked plot for coverage}

```{r, PancEndocrine_ranked_plot, echo=FALSE, fig.height=2.6, dev='png'}
ct <- "Panc-Endocrine"
integer_overdispersion_param_DMSL <- 1
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Panc_Endocrine_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Panc_Endocrine_nonexo,
                 loglog = F, title = 'obj_Panc_Endocrine (M)', theme_bw=T),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                 data_object = obj_Panc_Endocrine_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Panc_Endocrine_nonexo,
           loglog = F, title = 'obj_Panc_Endocrine (DMSL)', theme_bw=T), ncol=2)
```


\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, PancEndocrine_mutsigextractor, echo=F, warning=F, fig.height=2.2}
obj_Panc_Endocrine_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Panc_Endocrine_mutSigExtractor, legend_on = FALSE, verbose=F, nrow=1)
```

Exposures sorted by increasing number of mutations: there is a trend with one signature only being present, and in very large amounts, in hyeprmutated samples.

```{r, PancEndocrine_sortedbynummuts, fig.height=2, fig.width=6, echo=F}
createBarplot(normalise_rw(non_duplicated_rows(obj_Panc_Endocrine$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Panc_Endocrine$Y)),
                                        decreasing = F)), verbose=F, remove_labels=T)
```


\subsection{Prost-AdenoCA}


\subsubsection{Barplot and general statistics}
```{r ProstAdenoCA1, echo=FALSE}
ct <- "Prost-AdenoCA"
obj_Prost_AdenoCA <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Prost_AdenoCA, legend_on = TRUE, verbose=F)
```



The number of samples and signatures is:
```{r ProstAdenoCA1b, echo=FALSE}
dim(obj_Prost_AdenoCA$Y)
```

The signatures are:
```{r ProstAdenoCA1c, echo=FALSE}
colnames(obj_Prost_AdenoCA$Y)
```


\subsubsection{Convergence table}

These are the results for the convergence of models fits. Most have converged. fullRE_DMSL_nonexo hasn't run and needs to be re-run.

```{r ProstAdenoCA2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Prost-AdenoCA"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo.
```{r ProstAdenoCA3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Prost-AdenoCA"

obj_ProstAdenoCA <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_ProstAdenoCA <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_ProstAdenoCA, use_nlminb=T)
sortedM_ProstAdenoCA
```

But DMSL hasn't:
```{r ProstAdenoCA3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_ProstAdenoCA$Y)-1

sortedDM_ProstAdenoCA <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_ProstAdenoCA,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_ProstAdenoCA$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_ProstAdenoCA$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_ProstAdenoCA$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_ProstAdenoCA$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_ProstAdenoCA

```

```{r ProstAdenoCA3b, echo=FALSE, message=FALSE, dependson=c('ProstAdenoCA3')}
sortedDM_ProstAdenoCA$pdHess
```


\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures. None seem to be, although SBS33 is absent in 60\% of samples.
```{r, ProstAdenoCA1d}
colSums(obj_Prost_AdenoCA$Y == 0)/nrow(obj_Prost_AdenoCA$Y)
colSums(obj_Prost_AdenoCA$Y)/sum(obj_Prost_AdenoCA$Y)
```


\subsubsection{Betas}

```{r, ProstAdenoCA_betas, echo=F, warning=F}
ct <- "Prost-AdenoCA"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(sortedDM_ProstAdenoCA, names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]], names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```



```{r, ProstAdenoCA_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Prost_AdenoCA <- wald_TMB_wrapper(diagRE_DMSL_nonexo[["Prost-AdenoCA"]])
```

We use the results from the diag RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Prost_AdenoCA`.

\subsubsection{Covariance matrices}

```{r, ProstAdenoCA_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Prost_AdenoCA_additional_runs')}

ct <- "Prost-AdenoCA"
# models_it_Prost_AdenoCA <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Prost_AdenoCA <- c('fullRE_M', 'fullRE_M_nonexo')
covmats_Prost_AdenoCA <- lapply(models_it_Prost_AdenoCA,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Prost_AdenoCA) <- models_it_Prost_AdenoCA
## because it's fullRE_M, it's sorted
colnames(covmats_Prost_AdenoCA[['fullRE_M']]) <- rownames(covmats_Prost_AdenoCA[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Prost_AdenoCA)$Y))
colnames(covmats_Prost_AdenoCA[['fullRE_M_nonexo']]) <- rownames(covmats_Prost_AdenoCA[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Prost_AdenoCA, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Prost_AdenoCA)){pheatmap(covmats_Prost_AdenoCA[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Prost_AdenoCA[i])}
```

```{r, ProstAdenoCA_objnonexo, echo=FALSE}
obj_Prost_AdenoCA_nonexo <- give_subset_sigs_TMBobj(obj_Prost_AdenoCA, sigs_to_remove = nonexogenous$V1)
```

\subsubsection{Simulation under inferred data}
```{r, ProstAdenoCA_sim, echo=FALSE, fig.height=2.4}
sim_Prost_AdenoCA <- give_sim_from_estimates("Prost-AdenoCA", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="diagRE_DMSL", bool_nonexo = F,
                                      tmb_object=diagRE_DMSL_nonexo[[ct]],
                                      obj_data=obj_Prost_AdenoCA_nonexo, nrow=1)

sim_Prost_AdenoCA[[2]]+ggtitle('Simulation of Prost-AdenoCA samples')+theme_bw()


```

\subsubsection{Ranked plot for coverage}

```{r, ProstAdenoCA_ranked_plot, echo=FALSE, dev='png'}
ct <- "Prost-AdenoCA"
integer_overdispersion_param_DMSL <- 1
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Prost_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Prost_AdenoCA_nonexo,
                 loglog = F, title = 'obj_Prost_AdenoCA (M)', theme_bw=T),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                 data_object = obj_Prost_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Prost_AdenoCA_nonexo,
           loglog = F, title = 'obj_Prost_AdenoCA (DMSL)', theme_bw=T), ncol=2)
```


\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, ProstAdenoCA_mutsigextractor, echo=F, warning=F, fig.height=2}
obj_Prost_AdenoCA_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Prost_AdenoCA_mutSigExtractor, legend_on = FALSE, verbose=F, nrow=1)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations, except perhaps SBS3 in the hypermutated ones.

```{r, ProstAdenoCA_sortedbynummuts, fig.height=2, fig.width=6, echo=F}
createBarplot(normalise_rw(non_duplicated_rows(obj_Prost_AdenoCA$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Prost_AdenoCA$Y)),
                                        decreasing = F)), remove_labels=T, verbose=F)
```


\subsection{Skin-Melanoma.acral}

\subsubsection{Barplot and general statistics}
```{r SkinMelanomaacral1, echo=FALSE, warning=F, fig.height=2}
ct <- "Skin-Melanoma.acral"
obj_Skin_Melanomaacral <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Skin_Melanomaacral, legend_on = F, verbose=F, nrow=1)
```



The number of samples and signatures is:
```{r SkinMelanomaacral1b, echo=FALSE}
dim(obj_Skin_Melanomaacral$Y)
```

The signatures are:
```{r SkinMelanomaacral1c, echo=FALSE}
colnames(obj_Skin_Melanomaacral$Y)
```


\subsubsection{Convergence table}

These are the results for the convergence of models fits. They have converged even though very clearly we have very few observations and too many parameters. I thought I would have excluded this cancer type? In CT_sufficient_samples.txt it does appear but shouldn't - I don't continue the analyses for this cancer type.

```{r SkinMelanomaacral2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Skin-Melanoma.acral"
melt(all_summaries) %>% filter(value==ct)
```


\subsection{Skin-Melanoma.cutaneous}

\subsubsection{Barplot and general statistics}
```{r SkinMelanomacutaneous1, echo=FALSE}
ct <- "Skin-Melanoma.cutaneous"
obj_Skin_Melanomacutaneous <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Skin_Melanomacutaneous, legend_on = TRUE, verbose=F)
```



The number of samples and signatures is:
```{r SkinMelanomacutaneous1b, echo=FALSE}
dim(obj_Skin_Melanomacutaneous$Y)
```

The signatures are:
```{r SkinMelanomacutaneous1c, echo=FALSE}
colnames(obj_Skin_Melanomacutaneous$Y)
```

\subsubsection{Convergence table}

These are the results for the convergence of models fits. fullRE_DMSL have not converged.

```{r SkinMelanomacutaneous2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Skin-Melanoma.cutaneous"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo.
```{r SkinMelanomacutaneous3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Skin-Melanoma.cutaneous"

obj_SkinMelanomacutaneous <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_SkinMelanomacutaneous <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_SkinMelanomacutaneous)
sortedM_SkinMelanomacutaneous
```


```{r SkinMelanomacutaneous3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_SkinMelanomacutaneous$Y)-1

sortedDM_SkinMelanomacutaneous <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_SkinMelanomacutaneous,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_SkinMelanomacutaneous$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_SkinMelanomacutaneous$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_SkinMelanomacutaneous$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_SkinMelanomacutaneous$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_SkinMelanomacutaneous

```


If we use the values of the fullRE M exo as initial values for the fullRE DMSL exo do converge:
```{r SkinMelanomacutaneous3b, echo=FALSE, message=FALSE, dependson=c('SkinMelanomacutaneous3')}
sortedDM_SkinMelanomacutaneous$pdHess
```

It has converged.


\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures; there are none.
```{r, SkinMelanomacutaneous1d}
colSums(obj_Skin_Melanomacutaneous$Y == 0)/nrow(obj_Skin_Melanomacutaneous$Y)
colSums(obj_Skin_Melanomacutaneous$Y)/sum(obj_Skin_Melanomacutaneous$Y)
```

```{r, Skin_Melanomacutaneous_additional_runs, dependson=c('additional_runs'), echo=FALSE}
additional_sortedMnonexo[["Skin-Melanoma.cutaneous"]] <- sortedM_SkinMelanomacutaneous
additional_sortedDMSLnonexo[["Skin-Melanoma.cutaneous"]] <- sortedDM_SkinMelanomacutaneous
```

\subsubsection{Betas}

```{r, SkinMelanomacutaneous_betas, echo=FALSE, warning=F, fig.height=6}
ct <- "Skin-Melanoma.cutaneous"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
             plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
             plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
             plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')),
             plot_betas(fullRE_M_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
             plot_betas(sortedDM_SkinMelanomacutaneous, names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
             plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
             nrow=3)
```




```{r, SkinMelanomacutaneous_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Skin_Melanomacutaneous <- wald_TMB_wrapper(sortedDM_SkinMelanomacutaneous)
```

We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Skin_Melanomacutaneous`.

\subsubsection{Covariance matrices}
```{r, SkinMelanomacutaneous_cov, echo=FALSE, message=FALSE, fig.height=2.4, fig.width=2.4, dependson=c('Skin_Melanomacutaneous_additional_runs')}

ct <- "Skin-Melanoma.cutaneous"
# models_it_Skin_Melanomacutaneous <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Skin_Melanomacutaneous <- c('fullRE_M', 'fullRE_M_nonexo', 'additional_sortedDMSLnonexo')
covmats_Skin_Melanomacutaneous <- lapply(models_it_Skin_Melanomacutaneous,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Skin_Melanomacutaneous) <- models_it_Skin_Melanomacutaneous
## because it's fullRE_M, it's sorted
colnames(covmats_Skin_Melanomacutaneous[['fullRE_M']]) <- rownames(covmats_Skin_Melanomacutaneous[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Skin_Melanomacutaneous)$Y))
colnames(covmats_Skin_Melanomacutaneous[['fullRE_M_nonexo']]) <- rownames(covmats_Skin_Melanomacutaneous[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Skin_Melanomacutaneous, nonexogenous$V1)$Y))
colnames(covmats_Skin_Melanomacutaneous[['additional_sortedDMSLnonexo']]) <- rownames(covmats_Skin_Melanomacutaneous[['additional_sortedDMSLnonexo']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(give_subset_sigs_TMBobj(obj_Skin_Melanomacutaneous, nonexogenous$V1))$Y))

for(i in 1:length(covmats_Skin_Melanomacutaneous)){pheatmap(covmats_Skin_Melanomacutaneous[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Skin_Melanomacutaneous[i], fontsize = 7)}
```


```{r, SkinMelanomacutaneous_objnonexo, echo=FALSE}
obj_Skin_Melanomacutaneous_nonexo <- give_subset_sigs_TMBobj(obj_Skin_Melanomacutaneous, sigs_to_remove = nonexogenous$V1)
```

\subsubsection{Simulation under inferred data}
```{r, SkinMelanomacutaneous_sim, echo=FALSE, fig.height=2.5}
sim_Skin_Melanomacutaneous <- give_sim_from_estimates("Skin-Melanoma.cutaneous", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = F,
                                      sig_of_interest='SBS2',
                                      tmb_object=sortedDM_SkinMelanomacutaneous,
                                      obj_data=obj_Skin_Melanomacutaneous_nonexo, nrow=1)

sim_Skin_Melanomacutaneous[[2]]+ggtitle('Simulation of Skin-Melanoma.cutaneous samples')+theme_bw()


```


\subsubsection{Ranked plot for coverage}

```{r, SkinMelanomacutaneous_ranked_plot, echo=F, fig.height=2.8, dev='png'}
ct <- "Skin-Melanoma.cutaneous"
integer_overdispersion_param_DMSL <- 1
obj_Skin_Melanomacutaneous_nonexo_sorted <- sort_columns_TMB(give_subset_sigs_TMBobj(obj_Skin_Melanomacutaneous, sigs_to_remove = nonexogenous$V1))
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Skin_Melanomacutaneous_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Skin_Melanomacutaneous_nonexo,
                 loglog = F, title = 'obj_Skin_Melanomacutaneous (M)', theme_bw=T),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = sortedDM_SkinMelanomacutaneous,
                 data_object = obj_Skin_Melanomacutaneous_nonexo_sorted,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Skin_Melanomacutaneous_nonexo_sorted,
           loglog = F, title = 'obj_Skin_Melanomacutaneous (DMSL)', theme_bw=T), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, SkinMelanomacutaneous_mutsigextractor, echo=F, warning=F, fig.height=2}
obj_Skin_Melanomacutaneous_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Skin_Melanomacutaneous_mutSigExtractor, legend_on = FALSE,
                      verbose=F, nrow=1)
```

Exposures sorted by increasing number of mutations: SBS40 is crearly prevalent in samples with few mutations.

```{r, SkinMelanomacutaneous_sortedbynummuts, fig.height=2, fig.width=6, echo=F}
createBarplot(normalise_rw(non_duplicated_rows(obj_Skin_Melanomacutaneous$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Skin_Melanomacutaneous$Y)),
                                        decreasing = F)), verbose=F, remove_labels=T)
```



\subsection{Stomach-AdenoCA}

\subsubsection{Barplot and general statistics}
```{r StomachAdenoCA1, echo=FALSE}
ct <- "Stomach-AdenoCA"
obj_Stomach_AdenoCA <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Stomach_AdenoCA, legend_on = TRUE, verbose=F)
```


The number of samples and signatures is:
```{r StomachAdenoCA1b, echo=FALSE}
dim(obj_Stomach_AdenoCA$Y)
```

The signatures are:
```{r StomachAdenoCA1c, echo=FALSE}
colnames(obj_Stomach_AdenoCA$Y)
```


\subsubsection{Convergence table}

These are the results for the convergence of models fits. Besides fullRE_DMSL_nonexo, we have convergence with almost everything.

```{r StomachAdenoCA2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Stomach-AdenoCA"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo, but M hasn't converged. We should include fewer signatures.
```{r StomachAdenoCA3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Stomach-AdenoCA"

obj_StomachAdenoCA <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_StomachAdenoCA <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_StomachAdenoCA,
                           use_nlminb=T)
sortedM_StomachAdenoCA
```


\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures:
```{r, StomachAdenoCA1d}
colSums(obj_Stomach_AdenoCA$Y == 0)/nrow(obj_Stomach_AdenoCA$Y)
colSums(obj_Stomach_AdenoCA$Y)/sum(obj_Stomach_AdenoCA$Y)
```

```{r, StomachAdenoCA_remove_small_signatures, fig.height=2.3, echo=F}
ggplot(melt(obj_Stomach_AdenoCA$Y), aes(x=Var2, y=value+1))+geom_violin()+scale_y_continuous(trans = "log2")+facet_wrap(.~Var2, nrow=2, scales="free_x")
```

- Removing SBS20, SBS26, fullM still hasn't converged
- Removing SBS20, SBS26, SBS9 fullM still hasn't converged
- Removing SBS20, SBS26, SBS9, SBS13 fullM still hasn't converged
- Removing SBS20, SBS26, SBS9, SBS13, SBS44 fullM still hasn't converged

```{r StomachAdenoCA3_subset, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Stomach-AdenoCA"

obj_StomachAdenoCA_subset <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                c(nonexogenous$V1, 'SBS20', 'SBS26', 'SBS9', 'SBS13')))
obj_StomachAdenoCA_subset <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_StomachAdenoCA, use_nlminb=T)
obj_StomachAdenoCA_subset
```

\subsubsection{Betas}

```{r, StomachAdenoCA_betas, echo=F, warning=F, fig.height=6}
ct <- "Stomach-AdenoCA"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')),
  plot_betas(fullRE_M_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]], names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), ncol=2)
```

Difficult to see the labels, so I replot it here
```{r, StomachAdenoCA_betas_zoom, echo=FALSE, ,fig.height=3, fig.width=4.5, eval=TRUE, dev='tikz'}
plot_betas(diagRE_DMSL_nonexo[["Liver-HCC"]], names_cats= logR_nonexo_notsorted[["Stomach-AdenoCA"]])+ggtitle(paste0("Stomach-AdenoCA", 'diagRE DMSL non-exogenous'))
```


```{r, StomachAdenoCA_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Stomach_AdenoCA <- wald_TMB_wrapper(diagRE_DMSL_nonexo[["Stomach-AdenoCA"]])
```

We use the results from the diag RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Stomach_AdenoCA`.

\subsubsection{Covariance matrices}
I do not include this section as I have had to use ony diagonal matrices.

```{r, StomachAdenoCA_objnonexo, echo=FALSE}
# obj_Stomach_AdenoCA_nonexo_sorted <- sort_columns_TMB(give_subset_sigs_TMBobj(obj_Stomach_AdenoCA, sigs_to_remove = nonexogenous$V1))
obj_Stomach_AdenoCA_nonexo <- give_subset_sigs_TMBobj(obj_Stomach_AdenoCA, sigs_to_remove = nonexogenous$V1)
```

\subsubsection{Simulation under inferred data}
```{r, StomachAdenoCA_sim, echo=FALSE, fig.height=2.2}
sim_Stomach_AdenoCA <- give_sim_from_estimates("Stomach-AdenoCA", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="diagRE_DMSL", bool_nonexo = T,
                                      sig_of_interest="SBS2",
                                      tmb_object=diagRE_DMSL_nonexo[["Stomach-AdenoCA"]],
                                      obj_data=obj_Stomach_AdenoCA_nonexo, nrow=1)

sim_Stomach_AdenoCA[[2]]+ggtitle('Simulation of Stomach-AdenoCA samples')+theme_bw()


```
\subsubsection{Ranked plot for coverage}
Comparing for now only diagRE_DMSL_nonexo and sparse for nonexo. The blue/red dots seem to behave incorrectly.


```{r, StomachAdenoCA_ranked_plot, echo=F, dev='png'}
ct <- "Stomach-AdenoCA"
integer_overdispersion_param_DMSL <- 1
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = sparseRE_DMSL_nonexo[[ct]], integer_overdispersion_param=1,
                 data_object = obj_StomachAdenoCA,
                 print_plot = F, nreps = 20, model = "DMSL")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_StomachAdenoCA,
                 loglog = F, title = 'obj_Stomach_AdenoCA (sparse DMSL)', theme_bw=T),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                 data_object = obj_Stomach_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Stomach_AdenoCA_nonexo,
           loglog = F, title = 'obj_Stomach_AdenoCA (DMSL)', theme_bw=T), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, StomachAdenoCA_mutsigextractor, echo=F, warning=F, fig.height=2}
obj_Stomach_AdenoCA_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Stomach_AdenoCA_mutSigExtractor, legend_on = FALSE, verbose=F, nrow=1)
```

Exposures sorted by increasing number of mutations: there is no clear trend of signatures being associated with the number of mutations.

```{r, StomachAdenoCA_sortedbynummuts, fig.height=2, fig.width=6, echo=F}
createBarplot(normalise_rw(non_duplicated_rows(obj_Stomach_AdenoCA$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Stomach_AdenoCA$Y)),
                                        decreasing = F)), verbose=F, remove_labels=T)
```



\subsection{Thy-AdenoCA}


\subsubsection{Barplot and general statistics}
```{r ThyAdenoCA1, echo=FALSE, fig.height=2.4, warning=F}
ct <- "Thy-AdenoCA"
obj_Thy_AdenoCA <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Thy_AdenoCA, legend_on = F, verbose=F, nrow=1)
```



The number of samples and signatures is:
```{r ThyAdenoCA1b, echo=FALSE}
dim(obj_Thy_AdenoCA$Y)
```

The signatures are:
```{r ThyAdenoCA1c, echo=FALSE}
colnames(obj_Thy_AdenoCA$Y)
```


\subsubsection{Convergence table}

These are the results for the convergence of models fits. Practically everything timed-out.

```{r ThyAdenoCA2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Thy-AdenoCA"
melt(all_summaries) %>% filter(value==ct)
```



\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo.
```{r ThyAdenoCA3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Thy-AdenoCA"

obj_ThyAdenoCA <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_ThyAdenoCA <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_ThyAdenoCA, use_nlminb=T)
sortedM_ThyAdenoCA
```


```{r ThyAdenoCA3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_ThyAdenoCA$Y)-1

sortedDM_ThyAdenoCA <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_ThyAdenoCA,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_ThyAdenoCA$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_ThyAdenoCA$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_ThyAdenoCA$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_ThyAdenoCA$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_ThyAdenoCA
```


If we use the values of the fullRE M exo as initial values for the fullRE DMSL exo do not converge, even though there aren't many signatures:
```{r ThyAdenoCA3b, echo=FALSE, message=FALSE, dependson=c('ThyAdenoCA3')}
sortedDM_ThyAdenoCA$pdHess

```



\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures:
```{r, ThyAdenoCA1d}
colSums(obj_Thy_AdenoCA$Y == 0)/nrow(obj_Thy_AdenoCA$Y)
colSums(obj_Thy_AdenoCA$Y)/sum(obj_Thy_AdenoCA$Y)
```

```{r, Thy_AdenoCAL_remove_small_signatures, fig.height=2, echo=F}
ggplot(melt(obj_Thy_AdenoCA$Y), aes(x=Var2, y=value+1))+geom_violin()+scale_y_continuous(trans = "log2")
```


\subsubsection{Betas}

```{r, ThyAdenoCA_betas, echo=F}
ct <- "Thy-AdenoCA"

grid.arrange(plot_betas(diagRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(sortedM_ThyAdenoCA, names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(sortedDM_ThyAdenoCA, names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]], names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```



```{r, ThyAdenoCA_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Thy_AdenoCA <- wald_TMB_wrapper(diagRE_DMSL_nonexo[["Thy-AdenoCA"]])
```

We use the results from the diag RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Thy_AdenoCA`.

\subsubsection{Covariance matrices}
I do not include those.

```{r, ThyAdenoCA_objnonexo, echo=FALSE}
obj_Thy_AdenoCA_nonexo <- give_subset_sigs_TMBobj(obj_Thy_AdenoCA, sigs_to_remove = nonexogenous$V1)
obj_Thy_AdenoCA_nonexo_sorted <- sort_columns_TMB(give_subset_sigs_TMBobj(obj_Thy_AdenoCA, sigs_to_remove = nonexogenous$V1))
```

\subsubsection{Simulation under inferred data}
```{r, ThyAdenoCA_sim, echo=FALSE, fig.height=2}
sim_Thy_AdenoCA <- give_sim_from_estimates("Thy-AdenoCA", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="diagRE_DMSL", bool_nonexo = T,
                                      tmb_object=diagRE_DMSL_nonexo[["Thy-AdenoCA"]],
                                      obj_data=obj_Thy_AdenoCA_nonexo, nrow=1)

sim_Thy_AdenoCA[[2]]+ggtitle('Simulation of Thy-AdenoCA samples')+theme_bw()


```


\subsubsection{Ranked plot for coverage}

```{r, ThyAdenoCA_ranked_plot, echo=F, fig.height=2, dev='png'}
ct <- "Thy-AdenoCA"
integer_overdispersion_param_DMSL <- 1
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = sortedM_ThyAdenoCA,
                 data_object = obj_Thy_AdenoCA_nonexo_sorted,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Thy_AdenoCA_nonexo_sorted,
                 loglog = F, title = 'obj_Thy_AdenoCA (M)', theme_bw=T),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                 data_object = obj_Thy_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Thy_AdenoCA_nonexo,
           loglog = F, title = 'obj_Thy_AdenoCA (DMSL)', theme_bw=T), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, ThyAdenoCA_mutsigextractor, echo=F, warning=F, fig.height=2}
obj_Thy_AdenoCA_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Thy_AdenoCA_mutSigExtractor, legend_on = FALSE, verbose=F, nrow=1)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.

```{r, ThyAdenoCA_sortedbynummuts, fig.height=2, fig.width=6, echo=F}
createBarplot(normalise_rw(non_duplicated_rows(obj_Thy_AdenoCA$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Thy_AdenoCA$Y)),
                                        decreasing = F)), remove_labels=T, verbose=F)
```

\subsection{Uterus-AdenoCA}

\subsubsection{Barplot and general statistics}
```{r Uterus-AdenoCA1, echo=FALSE}
ct <- "Uterus-AdenoCA"
obj_Uterus_AdenoCA <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Uterus_AdenoCA, legend_on = TRUE, verbose=F)
```



The number of samples and signatures is:
```{r Uterus-AdenoCA1b, echo=FALSE}
dim(obj_Uterus_AdenoCA$Y)
```

The signatures are:
```{r Uterus-AdenoCA1c, echo=FALSE}
colnames(obj_Uterus_AdenoCA$Y)
```


\subsubsection{Convergence table}

These are the results for the convergence of models fits. Almost everything has converged.

```{r Uterus-AdenoCA2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Uterus-AdenoCA"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo.
```{r UterusAdenoCA3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Uterus-AdenoCA"

obj_UterusAdenoCA <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_UterusAdenoCA <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_UterusAdenoCA)
sortedM_UterusAdenoCA
```


```{r UterusAdenoCA3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_UterusAdenoCA$Y)-1

sortedDM_UterusAdenoCA <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_UterusAdenoCA,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_UterusAdenoCA$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_UterusAdenoCA$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_UterusAdenoCA$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_UterusAdenoCA$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_UterusAdenoCA

```

If we use the values of the fullRE M exo as initial values for the fullRE DMSL exo doesn't converge:
```{r UterusAdenoCA3b, echo=FALSE, message=FALSE, dependson=c('UterusAdenoCA3')}
sortedDM_UterusAdenoCA$pdHess
```

\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures:
```{r, UterusAdenoCA1d}
colSums(obj_Uterus_AdenoCA$Y == 0)/nrow(obj_Uterus_AdenoCA$Y)
colSums(obj_Uterus_AdenoCA$Y)/sum(obj_Uterus_AdenoCA$Y)
```


\subsubsection{Betas}

```{r, UterusAdenoCA_betas, echo=F, warning=F, fig.height=4}
ct <- "Uterus-AdenoCA"

grid.arrange(plot_betas(fullRE_M[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M')),
plot_betas(fullRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]], names_cats= logR_all_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(sortedDM_UterusAdenoCA, names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]], names_cats= logR_nonexo_notsorted[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]], names_cats = logR_nonexo_sorted[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```



```{r, UterusAdenoCA_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Uterus_AdenoCA <- wald_TMB_wrapper(diagRE_DMSL_nonexo[["Uterus-AdenoCA"]])
```

We use the results from the diag RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Uterus_AdenoCA`.

\subsubsection{Covariance matrices}

```{r, UterusAdenoCA_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Uterus_AdenoCA_additional_runs')}

ct <- "Uterus-AdenoCA"
# models_it_Uterus_AdenoCA <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Uterus_AdenoCA <- c('fullRE_M', 'fullRE_M_nonexo')
covmats_Uterus_AdenoCA <- lapply(models_it_Uterus_AdenoCA,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Uterus_AdenoCA) <- models_it_Uterus_AdenoCA
## because it's fullRE_M, it's sorted
colnames(covmats_Uterus_AdenoCA[['fullRE_M']]) <- rownames(covmats_Uterus_AdenoCA[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Uterus_AdenoCA)$Y))
colnames(covmats_Uterus_AdenoCA[['fullRE_M_nonexo']]) <- rownames(covmats_Uterus_AdenoCA[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Uterus_AdenoCA, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Uterus_AdenoCA)){pheatmap(covmats_Uterus_AdenoCA[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Uterus_AdenoCA[i])}
```


```{r, UterusAdenoCA_objnonexo, echo=FALSE}
obj_Uterus_AdenoCA_nonexo <- give_subset_sigs_TMBobj(obj_Uterus_AdenoCA, sigs_to_remove = nonexogenous$V1)
obj_Uterus_AdenoCA_nonexo_sorted <- sort_columns_TMB(give_subset_sigs_TMBobj(obj_Uterus_AdenoCA, sigs_to_remove = nonexogenous$V1))
```

\subsubsection{Simulation under inferred data}
```{r, UterusAdenoCA_sim, echo=FALSE, fig.height=2}
sim_Uterus_AdenoCA <- give_sim_from_estimates("Uterus-AdenoCA", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="diagRE_DMSL", bool_nonexo = F,
                                      sig_of_interest='SBS6',
                                      tmb_object=diagRE_DMSL_nonexo[["Uterus-AdenoCA"]],
                                      obj_data=obj_Uterus_AdenoCA_nonexo, nrow=1)

sim_Uterus_AdenoCA[[2]]+ggtitle('Simulation of Uterus-AdenoCA samples')+theme_bw()


```


\subsubsection{Ranked plot for coverage}

```{r, UterusAdenoCA_ranked_plot, echo=F, fig.height=2.5, dev='png'}
ct <- "Uterus-AdenoCA"
integer_overdispersion_param_DMSL <- 1
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Uterus_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Uterus_AdenoCA_nonexo,
                 loglog = F, title = 'obj_Uterus_AdenoCA (M)', theme_bw=T),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                 data_object = obj_Uterus_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Uterus_AdenoCA_nonexo,
           loglog = F, title = 'obj_Uterus_AdenoCA (DMSL)', theme_bw=T), ncol=2)
```


\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, UterusAdenoCA_mutsigextractor, echo=F, warning=F, fig.height=2}
obj_Uterus_AdenoCA_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Uterus_AdenoCA_mutSigExtractor, legend_on = FALSE, verbose=F, nrow=1)
```

Exposures sorted by increasing number of mutations: there is a trend of hypermutated samples being very chaotic.
```{r, UterusAdenoCA_sortedbynummuts, fig.height=2, fig.width=6, echo=F}
createBarplot(normalise_rw(non_duplicated_rows(obj_Uterus_AdenoCA$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Uterus_AdenoCA$Y)),
                                        decreasing = F)), verbose=F, remove_labels=T)
```

\clearpage
\section{All p-values for non-exogenous signatures}

```{r, all_pvals_improved, echo=FALSE, results='asis'}
all_pvals <- rbind.data.frame(cbind.data.frame(ct='Bone-Osteosarc', pvalue=pval_bone_osteosarc, model='diagRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Breast-AdenoCA', pvalue=pval_Breast_AdenoCA, model='diagRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Cervix-SCC', pvalue=pval_Cervix_SCC, model='fullRE_DMSL_nonexo') ,
                              cbind.data.frame(ct='CNS-GBM', pvalue=pval_CNS_GBM, model='fullRE_DMSL_nonexo'),
                              cbind.data.frame(ct='CNS-Medullo', pvalue=pval_CNS_Medullo, model='fullRE_DMSL_nonexo'),
                              cbind.data.frame(ct='CNS-Oligo', pvalue=pval_CNS_Oligo, model='fullRE_DMSL_nonexo'),
                              cbind.data.frame(ct='CNS-PiloAstro', pvalue=pval_CNS_PiloAstro, model='fullRE_DMSL_nonexo'),
                              cbind.data.frame(ct='ColoRect-AdenoCA', pvalue=pval_ColoRect_AdenoCA, model='diagRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Eso-AdenoCA', pvalue=pval_Eso_AdenoCA, model='diagRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Head-SCC', pvalue=pval_Head_SCC, model='fullRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Kidney-ChRCC', pvalue=pval_Kidney_ChRCC, model='fullRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Kidney-RCC.clearcell', pvalue=pval_Kidney_RCCclearcell, model='fullRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Kidney-RCC.papillary', pvalue=pval_Kidney_RCCpapillary, model='fullRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Liver-HCC', pvalue=pval_Liver_HCC, model='fullRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Lung-AdenoCA', pvalue=pval_Lung_AdenoCA, model='diagRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Lung-SCC', pvalue=pval_Lung_SCC, model='diagRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Lymph-BNHL', pvalue=pval_Lymph_BNHL, model='fullRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Lymph-CLL', pvalue=pval_Lymph_CLL, model='fullRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Myeloid-MPN', pvalue=pval_Myeloid_MPN, model='fullRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Ovary-AdenoCA', pvalue=pval_Ovary_AdenoCA, model='diagRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Panc-AdenoCA', pvalue=pval_Panc_AdenoCA, model='diagRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Panc-Endocrine', pvalue=pval_Panc_Endocrine, model='diagRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Prost-AdenoCA', pvalue=pval_Prost_AdenoCA, model='diagRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Skin-Melanoma.acral', pvalue=NA, model=''),
                              cbind.data.frame(ct='Skin-Melanoma.cutaneous', pvalue=pval_Skin_Melanomacutaneous, model='fullRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Stomach-AdenoCA', pvalue=pval_Stomach_AdenoCA, model='diagRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Thy-AdenoCA', pvalue=pval_Thy_AdenoCA, model='diagRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Uterus-AdenoCA', pvalue=pval_Uterus_AdenoCA, model='diagRE_DMSL_nonexo')
                              )

xtable::print.xtable(xtable::xtable(all_pvals), digits=c(0,10,0))

```

\subsubsection{All p-values}
```{r, all_pvals_2, echo=F, results='asis'}
xtable::xtable(cbind.data.frame(pvals_fullRE_M=pvals_fullRE_M,
                 pvals_diagRE_DM=pvals_diagRE_DM,
                 pvals_DM=pvals_DM,
                 pvals_DMnonexo=pvals_DMnonexo))

```

\subsubsection{Correlation between p-values and number of samples}


\clearpage
\section{Dirichlet-Multinomial Mixtures}

We run the software \verb|MicrobeDMMv1.0| to determine whether we are facing DMM mixtures or not.

We save the files in two ways: all of the samples - early or not - together, and separately.

In some cases DMM says that there is an error with the input file - in this case the AIC or BIC is not plotted. If all of them are missing, all BIC and AIC are set to zero.


```{r, save_files_dmm, echo=FALSE}

roo_obj <- sapply(fles_roo[grepl('_signatures_', fles_roo)], readRDS)
for(i in 1:length(roo_obj)){
  if(!rlang::is_empty(attr(roo_obj[[i]], "count_matrices_active")[[1]])){
    write.table(cbind.data.frame(c('Taxa', colnames(attr(roo_obj[[i]], "count_matrices_active")[[1]])),
                                 rbind.data.frame(rownames(attr(roo_obj[[i]],
                                                                "count_matrices_active")[[1]]),
                                                  round(t(attr(roo_obj[[i]], "count_matrices_active")[[1]])))),
                file = paste0("../../data/roo_for_DMM/", gsub("_ROO.RDS", "", basename(names(roo_obj)))[i], "_early.csv"), sep = ",", row.names = FALSE, col.names = FALSE, quote = FALSE)
    
    write.table(cbind.data.frame(c('Taxa', colnames(attr(roo_obj[[i]], "count_matrices_active")[[2]])),
                                 rbind.data.frame(rownames(attr(roo_obj[[i]],
                                                                "count_matrices_active")[[2]]),
                                                  round(t(attr(roo_obj[[i]], "count_matrices_active")[[2]])))),
                file = paste0("../../data/roo_for_DMM/", gsub("_ROO.RDS", "", basename(names(roo_obj)))[i], "_late.csv"), sep = ",", row.names = FALSE, col.names = FALSE, quote = FALSE)
    
    ## write all
      write.table(cbind.data.frame(c('Taxa', colnames(attr(roo_obj[[i]], "count_matrices_active")[[1]])),
         rbind.data.frame(c(paste0(rownames(attr(roo_obj[[i]],
                                                 "count_matrices_active")[[1]]), '-early'),
                            paste0(rownames(attr(roo_obj[[i]],
                                                 "count_matrices_active")[[2]]), '-late')),
                          round(cbind.data.frame(t(attr(roo_obj[[i]],
                                                        "count_matrices_active")[[1]]),
                                                 t(attr(roo_obj[[i]],
                                                        "count_matrices_active")[[2]]))))),
         file = paste0("../../data/roo_for_DMM/",
                       gsub("_ROO.RDS", "", basename(names(roo_obj)))[i], "_all.csv"),
         sep = ",", row.names = FALSE, col.names = FALSE, quote = FALSE)
              
  }  
}

```
<!-- (base) FVFXDASHHV29:roo_for_DMM morril01$ pwd -->
<!-- /Users/morril01/Documents/PhD/GlobalDA/data/roo_for_DMM -->
<!-- (base) FVFXDASHHV29:roo_for_DMM morril01$ cat run.sh  -->
<!-- /Users/morril01/software/MicrobeDMMv1.0/DirichletMixtureGHPFit -in Biliary-AdenoCA_signatures_early.csv -out Biliary-AdenoCA_signatures_early_DMM -k 4 -->


```{r, analyse_files_dmm, echo=FALSE, warning=FALSE, message=FALSE, results='hide'}
z_DMM <- lapply(enough_samples, function(ct){
  list(all=lapply(1:8, function(k) try(read.table(paste0("../../data/roo_for_DMM/DMM_output/", ct, "_signatures_all", k, "_dmm.z"), sep = ',', skip = 1))),
       early=lapply(1:8, function(k) try(read.table(paste0("../../data/roo_for_DMM/DMM_output/", ct, "_signatures_early", k, "_dmm.z"), sep = ',', skip = 1))),
       late=lapply(1:8, function(k) try(read.table(paste0("../../data/roo_for_DMM/DMM_output/", ct, "_signatures_late", k, "_dmm.z"), sep = ',', skip = 1))))
})
names(z_DMM) <- enough_samples

# (# of clusters) Evidence, Negative Log Determinant, Laplace Approximation, BIC and AIC are also sent to stdout at the end and written to a file stub.fit.
fit_DMM <- lapply(enough_samples, function(ct){
  list(all=lapply(1:8, function(k) try(read.table(paste0("../../data/roo_for_DMM/DMM_output/", ct, "_signatures_all", k, "_dmm.fit"), sep = ' '))),
       early=lapply(1:8, function(k) try(read.table(paste0("../../data/roo_for_DMM/DMM_output/", ct, "_signatures_early", k, "_dmm.fit"), sep = ' '))),
       late=lapply(1:8, function(k) try(read.table(paste0("../../data/roo_for_DMM/DMM_output/", ct, "_signatures_late", k, "_dmm.fit"), sep = ' '))))
})
names(fit_DMM) <- enough_samples
```

```{r, some_functions, echo=FALSE}
na_to_zero <- function(i) if(all(is.na(i))){i[is.na(i)] = 0; i}else{i}
```


```{r, analyse_files_dmm_find_k, fig.height=1.5, echo=FALSE, message=FALSE}

# (# of clusters) Evidence, Negative Log Determinant, Laplace Approximation, BIC and AIC are also sent to stdout at the end and written to a file stub.fit.

par(mfrow=c(1,6), mar=c(1.8, 1.8, 1.8, 1.8))
invisible(sapply(names(fit_DMM), function(j_name){
  j=fit_DMM[[j_name]]
  plot(1:8, na_to_zero(sapply(j$all, function(jj) if(! (typeof(jj) == "character")){jj[4]}else{NA})), xlab='k', ylab='BIC', main=j_name)
  plot(1:8, na_to_zero(sapply(j$all, function(jj) if(! (typeof(jj) == "character")){jj[5]}else{NA})), xlab='k', ylab='AIC', main=j_name)
  plot(1:8, na_to_zero(sapply(j$early, function(jj) if(! (typeof(jj) == "character")){jj[4]}else{NA})), xlab='k', ylab='BIC', main=j_name)
  plot(1:8, na_to_zero(sapply(j$early, function(jj) if(! (typeof(jj) == "character")){jj[5]}else{NA})), xlab='k', ylab='AIC', main=j_name)
  plot(1:8, na_to_zero(sapply(j$late, function(jj) if(! (typeof(jj) == "character")){jj[4]}else{NA})), xlab='k', ylab='BIC', main=j_name)
  plot(1:8, na_to_zero(sapply(j$late, function(jj) if(! (typeof(jj) == "character")){jj[5]}else{NA})), xlab='k', ylab='AIC', main=j_name)
}))

j=fit_DMM[[1]]

# z_DMM$`CNS-GBM`$all

# z_DMM$`Bone-Osteosarc`

# xxxx <- try(read.table(paste0("../../data/roo_for_DMM/DMM_output/", ct, "_signatures_all.z"), sep = ',', skip = 1))

# table(apply(xxxx[grepl('_early', xxxx$V1),-1], 1, which.max),
#       apply(xxxx[grepl('_late', xxxx$V1),-1], 1, which.max))

```


\newpage

## Comparison of signature exposures with QP and mutsigextractor
```{r, to_del, warning=F, echo=F}
signature_mutsigextractor_roo2 <- sapply(fles_roo[grepl('_signaturesmutSigExtractor_', fles_roo)], readRDS)
roo_obj2 <- roo_obj
names(signature_mutsigextractor_roo2) <- gsub("_signaturesmutSigExtractor_ROO.RDS", "", basename(names(signature_mutsigextractor_roo2)))
names(roo_obj2) <- gsub("_signatures_ROO.RDS", "", basename(names(roo_obj2)))
```

```{r, comparison_signatures_mutextractor, eval=TRUE, echo=FALSE, warning=FALSE}

par(mfrow=c(2,3))
for(i in names(roo_obj2)){
  try({

  sig1 <- roo_obj2[[i]]
  sig2 <- signature_mutsigextractor_roo2[[i]]

    
    if(is.null(sig2) | (is.na(sig1)) | (typeof(sig1) == "logical")){
      plot(0,0, main=i)
    }else{
        sig1 <- do.call('rbind', sig1@count_matrices_active)
        sig2 <- do.call('rbind', sig2@count_matrices_all)

      if(nrow(sig1) != nrow(sig2)){
            plot(0,0, main=i)
      }else{

        sig2 <- as.vector(sig2[,match(colnames(sig1), colnames(sig2))])
        sig1 <- as.vector(sig1)
        plot(sig1, sig2, main=i)
      }
    }
  })
}
```

\section{Correlation of p-values and number of samples}


```{r, cor_pvals_samples}
pcawg_palette <- pcawg.colour.palette(gsub("\\..*", "", all_pvals$ct),
                                      scheme = "tumour.subtype")

names(pcawg_palette) <- all_pvals$ct

ggplot(data.frame(num_samples=num_samples[match(all_pvals$ct, names(num_samples))],
                  pvalue=all_pvals$pvalue,
                  ct=all_pvals$ct), aes(x=num_samples, y=pvalue, label=ct, col=ct, group=1))+
  geom_point()+scale_y_continuous(trans = "log2")+
  geom_smooth(method = lm)+theme_bw()+
  geom_label_repel()+geom_hline(yintercept = log2(0.05), lty='dashed')+
  labs(x='Number of samples', y = 'p-value (log2')+
  scale_color_manual(values = pcawg_palette)+
  guides(col=FALSE)

```

\section{Effect size}
We are dealing with multivariate data, and it is not clear how we could come up with a metric to show the change between two sets of paired mutational signatures.

- From the Aitchison school, the 'perturbation' is what is used, and is a $d-1$-dimensional vector. We must turn this value into a single value.


```{r, load_objects_all, echo=F}

all_objects <- lapply(enough_samples, function(ct){load_PCAWG(ct = ct, typedata = "signatures")})
names(all_objects) <- enough_samples
all_objects_nonexo <- lapply(enough_samples, function(ct){
  try(give_subset_sigs_TMBobj(all_objects[[ct]],
                       sigs_to_remove = unique(nonexogenous$V1)))
})
names(all_objects_nonexo) <- enough_samples

num_samples_all <- sapply(enough_samples, function(ct){
    .xx <- all_objects[[ct]]
    try(nrow(.xx$Y)/2)
})

```

$$
e_1 = \frac{\sum_{i=1}^n (\bar{W}_{i}^l - \bar{W}_i^e)^2}{n}
$$

```{r, effectsize1, dependson=c('load_objects_all'), echo=F}
effect_size1nonexo <- sapply(enough_samples, function(ct){
  .xx <- all_objects_nonexo[[ct]]
  print(dim(.xx$Y[1:(nrow(.xx$Y)/2),]))
  print(dim(.xx$Y[(1+nrow(.xx$Y)/2):(nrow(.xx$Y)),]))
  try(compute_effect_size_1(mat1 = .xx$Y[1:(nrow(.xx$Y)/2),], mat2 = .xx$Y[(1+nrow(.xx$Y)/2):(nrow(.xx$Y)),]))
})
names(effect_size1nonexo) <- enough_samples

ggplot(cbind.data.frame(effect_size=as.numeric(effect_size1nonexo),
                        num_samples=as.numeric(num_samples[match(enough_samples, names(num_samples))]),
                        minlogpval=-log(as.numeric(pvals_DMnonexo[match(enough_samples, names(pvals_DMnonexo))])),
                        label=enough_samples),
       aes(x=effect_size1nonexo, y=minlogpval, shape=exp(-minlogpval)<0.05,
           label=label))+
  theme_bw()+
  geom_point(aes(col=num_samples))+geom_label_repel(alpha=0.4)+
  theme(legend.position = "bottom")+ggtitle('Effect size #1, nonexo')
```

```{r, effectsize1all, dependson=c('load_objects_all'), echo=F}
effect_size1all <- sapply(enough_samples, function(ct){
  .xx <- all_objects[[ct]]
  try(compute_effect_size_1(.xx$Y[1:(nrow(.xx$Y)/2),],
                            .xx$Y[(1+nrow(.xx$Y)/2):(nrow(.xx$Y)),]))
})
names(effect_size1all) <- enough_samples

ggplot(cbind.data.frame(effect_size=as.numeric(effect_size1all),
                        num_samples=as.numeric(num_samples_all[match(enough_samples, names(num_samples_all))]),
                        minlogpval=-log(as.numeric(pvals_DM[match(enough_samples, names(pvals_DM))])),
                        label=enough_samples),
       aes(x=effect_size, y=minlogpval, shape=exp(-minlogpval)<0.05,
           label=label))+
  theme_bw()+
  geom_point(aes(col=num_samples))+geom_label_repel(alpha=0.4)+
  theme(legend.position = "bottom")+ggtitle('Effect size #1, all sigs')
```

$$
e_2 = \frac{\sum_{i=1}^n (\bar{W}_{i}^l - \bar{W}_i^e)^2}{n}\cdot\log\left( \frac{\sum_{i=1}^n\sum_{j=1}^kW_{ij}}{n}\right)
$$


```{r, effectsize2, dependson=c('load_objects_all'), echo=F}
effect_size2nonexo <- sapply(enough_samples, function(ct){
  .xx <- all_objects_nonexo[[ct]]
  try(compute_effect_size_2(mat1 = .xx$Y[1:(nrow(.xx$Y)/2),],
                            mat2 = .xx$Y[(1+nrow(.xx$Y)/2):(nrow(.xx$Y)),]))
})
names(effect_size2nonexo) <- enough_samples

ggplot(cbind.data.frame(effect_size=as.numeric(effect_size2nonexo),
                        num_samples=as.numeric(num_samples[match(enough_samples, names(num_samples))]),
                        minlogpval=-log(as.numeric(pvals_DMnonexo[match(enough_samples, names(pvals_DMnonexo))])),
                        label=enough_samples),
       aes(x=effect_size, y=minlogpval, shape=exp(-minlogpval)<0.05,
           label=label))+
  theme_bw()+
  geom_point(aes(col=num_samples))+geom_label_repel(alpha=0.4)+
  theme(legend.position = "bottom")+ggtitle('Effect size #2, nonexo')+
  guides(shape=F)

```

Signature-averaged perturbation
```{r, effectsize3, dependson=c('load_objects_all'), echo=F, fig.width=5, fig.height=6}
effect_size3nonexo <- sapply(enough_samples, function(ct){
  .xx <- all_objects_nonexo[[ct]]
  # print(head(.xx$z))
  try(give_totalperturbation_TMBobj_sigaverage(.xx, addone=T))
})
effect_size3nonexo <- as.numeric(effect_size3nonexo)

names(effect_size3nonexo) <- enough_samples

ggplot(cbind.data.frame(effect_size=as.numeric(effect_size3nonexo),
                        num_samples=as.numeric(num_samples[match(enough_samples, names(num_samples))]),
                        minlogpval=-log(as.numeric(pvals_DMnonexo[match(enough_samples, names(pvals_DMnonexo))])),
                        label=enough_samples),
       aes(x=effect_size, y=minlogpval, shape=exp(-minlogpval)<0.05,
           label=label))+
  theme_bw()+
  geom_point(aes(col=log(num_samples)))+geom_label_repel(alpha=0.4)+
  theme(legend.position = "bottom")+ggtitle('Total perturbation, non-exogenous signatures')+
  jcolors::scale_color_jcolors_contin("pal3", reverse = TRUE, bias = 2.25)+
    labs(x='Effect size', y='Negative log p-value')+
  guides(shape=F)

```

Signature-averaged perturbation (all sigs)

```{r, effectsize3all, dependson=c('load_objects_all'), echo=F, fig.width=5, fig.height=6}
effect_size3 <- sapply(enough_samples, function(ct){
  .xx <- all_objects[[ct]]
  try(give_totalperturbation_TMBobj_sigaverage(.xx, addone=T))
})
effect_size3 <- as.numeric(effect_size3)
names(effect_size3) <- enough_samples


ggplot(cbind.data.frame(effect_size=as.numeric(effect_size3),
                        num_samples=as.numeric(num_samples_all[match(enough_samples, names(num_samples_all))]),
                        minlogpval=-log(as.numeric(pvals_DM[match(enough_samples, names(pvals_DM))])),
                        label=enough_samples),
       aes(x=effect_size, y=minlogpval, shape=exp(-minlogpval)<0.05,
           label=label))+
  theme_bw()+
  geom_point(aes(col=log(num_samples)))+geom_label_repel(alpha=0.4)+
  theme(legend.position = "bottom")+ggtitle('Total perturbation, all signatures')+
  jcolors::scale_color_jcolors_contin("pal3", reverse = TRUE, bias = 2.25)+
  labs(x='Effect size', y='Negative log p-value')+
  guides(shape=FALSE)
```

Total perturbation (sample-averaged)
```{r, effectsize3b, dependson=c('load_objects_all'), echo=F, fig.width=5, fig.height=6}
effect_size3bnonexo <- sapply(enough_samples, function(ct){
  .xx <- all_objects_nonexo[[ct]]
  try(give_totalperturbation_TMBobj(.xx, addone=T))
})
effect_size3bnonexo <- as.numeric(effect_size3bnonexo)

names(effect_size3bnonexo) <- enough_samples


ggplot(cbind.data.frame(effect_size=as.numeric(effect_size3bnonexo),
                        num_samples=as.numeric(num_samples[match(enough_samples, names(num_samples))]),
                        minlogpval=-log(as.numeric(pvals_DMnonexo[match(enough_samples, names(pvals_DMnonexo))])),
                        label=enough_samples),
       aes(x=effect_size, y=minlogpval, shape=exp(-minlogpval)<0.05,
           label=label))+
  theme_bw()+
  geom_point(aes(col=log(num_samples)))+geom_label_repel(alpha=0.4)+
  theme(legend.position = "bottom")+ggtitle('Total perturbation, non-exogenous signatures')+
  jcolors::scale_color_jcolors_contin("pal3", reverse = TRUE, bias = 2.25)+
    labs(x='Effect size', y='Negative log p-value')+
  guides(shape=F)
```

Weighted total perturbation
```{r, effectsize4all, dependson=c('load_objects_all'), echo=F, fig.width=5, fig.height=6}
effect_size4 <- sapply(enough_samples, function(ct){
  .xx <- all_objects[[ct]]
  try(give_weightedtotalperturbation_TMBobj(.xx, addone=T))
})
effect_size4 <- as.numeric(effect_size4)
names(effect_size4) <- enough_samples


ggplot(cbind.data.frame(effect_size=as.numeric(effect_size4),
                        num_samples=as.numeric(num_samples_all[match(enough_samples, names(num_samples_all))]),
                        minlogpval=-log(as.numeric(pvals_DM[match(enough_samples, names(pvals_DM))])),
                        label=enough_samples),
       aes(x=effect_size, y=minlogpval, shape=exp(-minlogpval)<0.05,
           label=label))+
  theme_bw()+
  geom_point(aes(col=log(num_samples)))+geom_label_repel(alpha=0.4)+
  theme(legend.position = "bottom")+ggtitle('Weighted total perturbation, all signatures')+
  jcolors::scale_color_jcolors_contin("pal3", reverse = TRUE, bias = 2.25)+
  labs(x='Effect size', y='Negative log p-value')+
  guides(shape=FALSE)

```


\section{Which inferred covariance matrices are not positive semi-definite?}

```{r, covariance_matrices_PSD, echo=F}

list_models <- c("fullRE_M", "fullRE_M_nonexo", "fullRE_DMDL",
            "fullRE_M", "sparseRE_DMSL", "fullRE_DMDL_nonexo",
            "fullRE_DMDL_sortednonexo", "fullRE_DMSL_nonexo",
            "fullRE_DMSL_SBS1", "fullRE_DMSL", "sparseRE_DMSL_nonexo")
covariances_psd <- do.call('rbind', lapply(list_models, function(i){
  sapply(enough_samples, function(ct){
    try(
      if(get(i)[[ct]]$pdHess){
        ## if it has converged
    matrixcalc::is.positive.semi.definite(fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                              arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                              arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
      )
      }else{
        'NC'
      }
    )
})
}))

```

```{r, covariance_matrices_PSD_heatmap, echo=F, fig.height=7}
dim(covariances_psd)
rownames(covariances_psd) <- list_models
covariances_psd_df <- melt((covariances_psd), measure.vars=colnames((covariances_psd)))
dim(covariances_psd_df)
colnames(covariances_psd_df)
ggplot(covariances_psd_df, aes(x=Var1, y=Var2, fill=value))+
  geom_tile()+
  theme(legend.position = "bottom")+
  theme(axis.text.x=element_text(angle = 45, hjust = 1, vjust=1))+
  guides(fill=guide_legend(ncol=1))
```


\section{Comparison of the inferred covariance matrices and the matrices from the fitted intercepts}
```{r, covariance_matrices_comparison_fitted, echo=F, fig.height=3, fig.width=3}


list_models_short <- c("fullRE_M_nonexo",  "fullRE_DMSL_nonexo")
sapply(enough_samples, function(ct){
  sapply(list_models_short, function(i){
    try(
      if(get(i)[[ct]]$pdHess){
         .d_logR <- length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2
         print(ct)
    pheatmap(fill_covariance_matrix(arg_d = .d_logR,
                              arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                              arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE')), main=paste0(ct, '\n inferred'), cluster_rows = F, cluster_cols = F)
         pheatmap(cov(matrix(python_like_select_name(get(i)[[ct]]$par.random, 'u_large'), ncol=.d_logR)), main=paste0(ct, '\n empirical'), cluster_rows = F, cluster_cols = F)
      }else{
        'No convergence'
      }
    )
})
})

```

\section{Correlation of intercept and slope values}
```{r, runs_final, echo=F}
## get the final runs: preferably fullRE DM, but if not diagRE DM
final_list_runs <- list("Bone-Osteosarc"= list("diagRE_DMSL", diagRE_DMSL_nonexo[["Bone-Osteosarc"]]),
                        "Breast-AdenoCA"=list("diagRE_DMSL", diagRE_DMSL_nonexo[[ct]]),
                        "CNS-GBM"=list("fullRE_DMSL", sortedDM_CNSGBM),
                        "CNS-Medullo"=list("fullRE_DMSL", fullRE_DMSL_nonexo[["CNS-Medullo"]]),
                        "CNS-PiloAstro"=list("fullRE_DMSL", fullRE_DMSL_nonexo[["CNS-PiloAstro"]]),
                        "ColoRect-AdenoCA"=list("diagRE_DMSL", diagRE_DMSL_nonexo[["ColoRect-AdenoCA"]]),
                        "Eso-AdenoCA"=list("diagRE_DMSL", diagRE_DMSL_nonexo[["Eso-AdenoCA"]]),
                        "Head-SCC"=list("fullRE_DMSL", fullRE_DMSL_nonexo[["Head-SCC"]]),
                        "Kidney-ChRCC"=list("fullRE_DMSL", fullRE_DMSL_nonexo[["Kidney-ChRCC"]]),
                        "Kidney-RCC.clearcell"=list("fullRE_DMSL", fullRE_DMSL_nonexo[["Kidney-RCC.clearcell"]]),
                        "Kidney-RCC.papillary"=list("fullRE_DMSL", sortedDM_KidneyRCCpapillary),
                        "Liver-HCC"=list("fullRE_DMSL", fullRE_DMSL_nonexo[["Liver-HCC"]]),
                        "Lung-SCC"=list("fullRE_DMSL", fullRE_DMSL_nonexo[["Lung-SCC"]]),
                        "Lymph-BNHL"=list("fullRE_DMSL", sortedDM_LymphBNHL),
                        "Lymph-CLL"=list("fullRE_DMSL", fullRE_DMSL_nonexo[["Lymph-CLL"]]),
                        "Ovary-AdenoCA"=list("diagRE_DMSL", diagRE_DMSL_nonexo[["Ovary-AdenoCA"]]),
                        "Panc-AdenoCA"=list("diagRE_DMSL", diagRE_DMSL_nonexo[["Panc-AdenoCA"]]),
                        "Panc-Endocrine"=list("diagRE_DMSL", diagRE_DMSL_nonexo[["Panc-Endocrine"]]),
                        "Prost-AdenoCA"=list("diagRE_DMSL", diagRE_DMSL_nonexo[["Prost-AdenoCA"]]),
                        "Skin-Melanoma.cutaneous"=list("fullRE_DMSL", sortedDM_SkinMelanomacutaneous),
                        "Stomach-AdenoCA"=list("diagRE_DMSL", diagRE_DMSL_nonexo[["Stomach-AdenoCA"]]),
                        "Thy-AdenoCA"=list("diagRE_DMSL", diagRE_DMSL_nonexo[["Thy-AdenoCA"]]),
                        "Uterus-AdenoCA"=list("diagRE_DMSL", diagRE_DMSL_nonexo[["Uterus-AdenoCA"]]))
```

```{r, cor_intercept_slope, echo=F}
cor_intercept_slope <- do.call('rbind', lapply(1:length(final_list_runs), function(i){
  j= final_list_runs[[i]]
  cbind.data.frame(slope=select_slope_2(python_like_select_name(j[[2]]$par.fixed, "beta"), verbatim = FALSE),
        intercept=select_intercept(python_like_select_name(j[[2]]$par.fixed, "beta"), verbatim = FALSE),
        ct=names(final_list_runs)[i])
}))

```


```{r, cor_intercept_slope_plot, echo=F, fig.height=6, fig.width=4}
ggplot(cor_intercept_slope, aes(x=intercept, y=slope, col=ct, group=1))+geom_point()+
  geom_smooth(method = "lm")+
  theme_bw()+theme(legend.position = "bottom")+guides(col=guide_legend(ncol=3))
ggplot(cor_intercept_slope, aes(x=intercept, y=slope, col=ct, group=ct))+geom_point()+
  geom_smooth(method = "lm", se=F)+
  theme_bw()+theme(legend.position = "bottom")+guides(col=guide_legend(ncol=3))
```

```{r, libraries_2, echo=F, cache=F}
library(latex2exp)
library(cowplot)

renaming_pcawg <- read.table("../../data/other/short_names_pcawg.txt", sep = "\t")

```

```{r, cor_intercept_slope_plot2, echo=F, fig.height=4, fig.width=4}
ggplot(cor_intercept_slope, aes(x=intercept, y=slope, group=1))+geom_point()+
  geom_smooth(method = "lm")+
  theme_bw()+theme(legend.position = "bottom")+guides(col=guide_legend(ncol=3))
ggplot(cor_intercept_slope, aes(x=intercept, y=slope, group=ct))+geom_point()+
  geom_smooth(method = "lm", se=F)+
  theme_bw()+theme(legend.position = "bottom")+guides(col=guide_legend(ncol=3))+
  labs(x=TeX(r'($\beta$ intercept)'),
       y = TeX(r'($\beta$ slope)'))
```

For the cancer types for which we have both fullRE and diagRE, see how the beta coefficients change in these two models, in a scatteplot where we show beta intercepts and slopes.

Note that not all fullRE M or diagM have converged - I have removed those which haven't. In some cases I ran DMSL with a subset of signatures, so that diagRE DMSL (with more signatures) cannot be compared to fullRE DMSL.

```{r, beta_coef_differences_in_models, echo=F}

ct_subset_fullRE <- names(final_list_runs)[sapply(final_list_runs, function(i) i[1] == 'fullRE_DMSL')]


comparison_betas_models <- function(model_fullRE_DMSL_list, model_diagRE_DMSL_list, model_fullRE_M_list ){
  
  .x <- do.call('rbind.data.frame', lapply(enough_samples, function(ct){
    x_beta_fullRE_DMSL <- try(python_like_select_name(model_fullRE_DMSL_list[[ct]]$par.fixed, "beta"))
    x_beta_diagRE_DMSL <- try(python_like_select_name(model_diagRE_DMSL_list[[ct]]$par.fixed, "beta"))
    x_beta_fullRE_M <- try(python_like_select_name(model_fullRE_M_list[[ct]]$par.fixed, "beta"))
    if( (length(x_beta_fullRE_DMSL) != length(x_beta_diagRE_DMSL)) | (length(x_beta_fullRE_DMSL) != length(x_beta_fullRE_M)) ){
      ## if we don't have results for any, remove from the analysis
      list_betas <- list(x_beta_fullRE_DMSL, x_beta_diagRE_DMSL, x_beta_fullRE_M)
      typeofs_of_betas <- sapply(list_betas, typeof)
      if( all(typeofs_of_betas == "character")  ){
        return(NULL)
      }else{
        ## if we do have results for some, replace the error message by an NA string
        ## replace using the length of the first double entry
        
        if(typeofs_of_betas[1] == "character"){
          x_beta_fullRE_DMSL <- rep(NA, length(list_betas[[which(typeofs_of_betas == "double")[1]]]))
        }
        
        if(typeofs_of_betas[2] == "character"){
          x_beta_diagRE_DMSL <- rep(NA, length(list_betas[[which(typeofs_of_betas == "double")[1]]]))
        }
        
        if(typeofs_of_betas[3] == "character"){
          x_beta_fullRE_M <- rep(NA, length(list_betas[[which(typeofs_of_betas == "double")[1]]]))
        }
        
        if( (length(x_beta_fullRE_DMSL) != length(x_beta_diagRE_DMSL)) | (length(x_beta_fullRE_DMSL) != length(x_beta_fullRE_M)) ){
          warning(paste0(ct, ': the number of log-ratios is not consistent'))
          return(NULL)
        }
      }
      
    }
      cbind.data.frame(rbind.data.frame(
        cbind.data.frame(fullRE_DMSL=select_slope_2(x_beta_fullRE_DMSL),
                         diagRE_DMSL=select_slope_2(x_beta_diagRE_DMSL),
                         fullRE_M=select_slope_2(x_beta_fullRE_M),
                         beta_type='Slope'),
        cbind.data.frame(fullRE_DMSL=select_intercept(x_beta_fullRE_DMSL),
                         diagRE_DMSL=select_intercept(x_beta_diagRE_DMSL),
                         fullRE_M=select_intercept(x_beta_fullRE_M),
                         beta_type='Intercept')),
        ct=ct)
    }
  ))
  
  ## if something hasn't converged, remove the value
  bad_ct_fullRE_DMSL <- c(enough_samples[sapply(enough_samples,
                                                function(ct) (typeof(model_fullRE_DMSL_list[[ct]])) == 'character')],
                          enough_samples[sapply(enough_samples,
                                                function(ct)  try(model_fullRE_DMSL_list[[ct]]$pdHess)) != "TRUE"])
  bad_ct_diagRE_DMSL <- c(enough_samples[sapply(enough_samples,
                                                function(ct) (typeof(model_diagRE_DMSL_list[[ct]])) == 'character')],
                          enough_samples[sapply(enough_samples, function(ct)  try(model_diagRE_DMSL_list[[ct]]$pdHess)) != "TRUE"])
  bad_ct_fullRE_M <- c(enough_samples[sapply(enough_samples,
                                             function(ct) (typeof(model_fullRE_M_list[[ct]])) == 'character')],
                       enough_samples[sapply(enough_samples, function(ct)  try(model_fullRE_M_list[[ct]]$pdHess)) != "TRUE"])
  
  .x$fullRE_DMSL[(.x$ct %in% bad_ct_fullRE_DMSL)] = NA
  .x$diagRE_DMSL[(.x$ct %in% bad_ct_diagRE_DMSL)] = NA
  .x$fullRE_M[(.x$ct %in% bad_ct_fullRE_M)] = NA
  
  .x$ct2=renaming_pcawg[,2][match(.x$ct, renaming_pcawg[,1])]
  
  return(.x)
  
}

comparison_betas_models_all <- comparison_betas_models(model_fullRE_DMSL_list = fullRE_DMSL,
                                                       model_diagRE_DMSL_list = diagRE_DMSL,
                                                       model_fullRE_M_list = fullRE_M)

comparison_betas_models_nonexo <- comparison_betas_models(model_fullRE_DMSL_list = fullRE_DMSL_nonexo,
                                                          model_diagRE_DMSL_list = diagRE_DMSL_nonexo,
                                                          model_fullRE_M_list = fullRE_M_nonexo)

```


```{r, beta_coef_differences_in_models_plots, echo=F, dependson=c('beta_coef_differences_in_models')}

comparison_betas_models_rbind <- rbind.data.frame(cbind.data.frame(comparison_betas_models_nonexo, sigs='nonexo'),
                        cbind.data.frame(comparison_betas_models_all, sigs='all'))
comparison_betas_models_rbind$fullRE_DMSL = as.numeric(comparison_betas_models_rbind$fullRE_DMSL)
comparison_betas_models_rbind$diagRE_DMSL = as.numeric(comparison_betas_models_rbind$diagRE_DMSL)
comparison_betas_models_rbind$fullRE_M = as.numeric(comparison_betas_models_rbind$fullRE_M)

# saveRDS(fullRE_DMSL_nonexo, "~/Desktop/fullRE_DMSL_nonexoL.RDS")
# saveRDS(diagRE_DMSL_nonexo, "~/Desktop/diagRE_DMSL_nonexo.RDS")
# saveRDS(fullRE_M_nonexo, "~/Desktop/fullRE_M_nonexo.RDS")

ggplot(comparison_betas_models_rbind, aes(x=as.numeric(fullRE_DMSL), y=as.numeric(diagRE_DMSL), col=beta_type))+
  geom_point()+theme_bw()
ggplot(comparison_betas_models_rbind, aes(x=as.numeric(fullRE_DMSL), y=as.numeric(diagRE_DMSL), group=ct, col=beta_type))+
  geom_smooth(method = "lm")+
  geom_point()+theme_bw()
ggplot(comparison_betas_models_rbind, aes(x=as.numeric(fullRE_DMSL), y=as.numeric(fullRE_M), col=beta_type))+
  geom_point()+theme_bw()

ggplot(comparison_betas_models_rbind, aes(x=as.numeric(fullRE_DMSL), y=as.numeric(fullRE_M), col=ct2, shape=beta_type))+
  geom_point()+theme_bw()

ggplot(comparison_betas_models_rbind, aes(x=as.numeric(diagRE_DMSL), y=as.numeric(fullRE_M), col=ct2, shape=beta_type))+
  geom_abline(slope = 1, intercept = 0, lty='dashed')+geom_point()+geom_smooth(method = "lm", aes(group=ct2))+
  theme_bw()+theme(legend.position = "bottom")
```

```{r, beta_coef_differences_in_models_plots_2, echo=F, dependson=c('beta_coef_differences_in_models', 'beta_coef_differences_in_models_plots'), fig.height=2.5, fig.width=3.8, dev='tikz'}

comparison_betas_models_rbind_stats <- rbind.data.frame(
  cbind.data.frame(rmse_diag_full_DMSL=comparison_betas_models_rbind %>% filter(beta_type == 'Slope') %>% summarise(rmse_diag_full_DMSL=sqrt(mean( (diagRE_DMSL-fullRE_DMSL)^2, na.rm = T ))),
  rmse_fullDMSL_fullM=comparison_betas_models_rbind %>% filter(beta_type == 'Slope') %>% 
    summarise(rmse_fullDMSL_fullM=sqrt(mean( (fullRE_M-fullRE_DMSL)^2, na.rm = T ))), beta_type='Slope'),
  cbind.data.frame(rmse_diag_full_DMSL=comparison_betas_models_rbind %>% filter(beta_type == 'Intercept') %>% summarise(rmse_diag_full_DMSL=sqrt(mean( (diagRE_DMSL-fullRE_DMSL)^2, na.rm = T ))),
  rmse_fullDMSL_fullM=comparison_betas_models_rbind %>% filter(beta_type == 'Intercept') %>% 
    summarise(rmse_fullDMSL_fullM=sqrt(mean( (fullRE_M-fullRE_DMSL)^2, na.rm = T ))), beta_type='Intercept'))
# comparison_betas_models_rbind_stats$ct2=renaming_pcawg[,2][match(comparison_betas_models_rbind_stats$ct, renaming_pcawg[,1])]

comparison_betas_models_rbind_stats

ggplot(comparison_betas_models_rbind, aes(x=as.numeric(fullRE_DMSL), y=as.numeric(diagRE_DMSL), col=beta_type))+
  geom_abline(slope = 1, intercept = 0, lty='dashed')+theme_bw()+
  geom_point()+theme_bw()+
  geom_text(data = comparison_betas_models_rbind_stats, aes(x=-Inf, y=-Inf,
                                                            label=paste0('RMSE: ', signif(rmse_diag_full_DMSL, 3))),
            vjust=-1.3, hjust=-0.55,
            )+
  facet_wrap(.~beta_type)+labs(x='Beta values for fullRE DMSL', y='Beta values for diagRE DMSL')+
  theme(legend.title=element_blank(),
        strip.text.x = element_text(size = 10),
        legend.text=element_text(size=10), legend.position = "bottom")+guides(col=FALSE)

ggplot(comparison_betas_models_rbind, aes(x=as.numeric(fullRE_DMSL), y=as.numeric(fullRE_M), col=beta_type))+
  geom_abline(slope = 1, intercept = 0, lty='dashed')+theme_bw()+
  geom_point()+theme_bw()+
  geom_text(data = comparison_betas_models_rbind_stats, aes(x=-Inf, y=-Inf,
                                                            label=paste0('RMSE: ', signif(rmse_fullDMSL_fullM, 3))),
            vjust=-1.3, hjust=-0.55,
            )+
  facet_wrap(.~beta_type)+labs(x='Beta values for fullRE DMSL', y='Beta values for fullRE M')+
  theme(legend.title=element_blank(),
        strip.text.x = element_text(size = 10),
        legend.text=element_text(size=10), legend.position = "bottom")+guides(col=FALSE)

```

```{r, beta_coef_differences_in_models_plots_3, echo=F, dependson=c('beta_coef_differences_in_models', 'beta_coef_differences_in_models_plots', 'beta_coef_differences_in_models_plots_2'), warning=F, error=F, message=F}

comparison_betas_models_rbind_stats_per_ct <- rbind.data.frame(
  cbind.data.frame(comparison_betas_models_rbind %>% filter(beta_type == 'Slope') %>%
                     group_by(ct) %>%
                     summarise(rmse_diag_full_DMSL=sqrt(mean( (diagRE_DMSL-fullRE_DMSL)^2, na.rm = T )),
                               slope_diag_full_DMSL=as.numeric(try(coefficients(lm(y~x, data = cbind.data.frame(x=diagRE_DMSL, y=fullRE_DMSL), na.action = na.omit))[2])),
                               rmse_fullDMSL_fullM=sqrt(mean( (fullRE_M-fullRE_DMSL)^2, na.rm = T )),
                               slope_fullDMSL_fullM=as.numeric(try(coefficients(lm(y~x, data = cbind.data.frame(x=fullRE_M, y=fullRE_DMSL), na.action = na.omit))[2]))),
                   beta_type='Slope'),
  cbind.data.frame(comparison_betas_models_rbind %>% filter(beta_type == 'Intercept') %>%
                     group_by(ct) %>%
                     summarise(rmse_diag_full_DMSL=sqrt(mean( (diagRE_DMSL-fullRE_DMSL)^2, na.rm = T )),
                               slope_diag_full_DMSL=as.numeric(try(coefficients(lm(y~x, data = cbind.data.frame(x=diagRE_DMSL, y=fullRE_DMSL), na.action = na.omit))[2])),
                               rmse_fullDMSL_fullM=sqrt(mean( (fullRE_M-fullRE_DMSL)^2, na.rm = T )),
                               slope_fullDMSL_fullM=as.numeric(try(coefficients(lm(y~x, data = cbind.data.frame(x=fullRE_M, y=fullRE_DMSL), na.action = na.omit))[2]))),
                   beta_type='Intercept'))
comparison_betas_models_rbind_stats_per_ct$ct2=renaming_pcawg[,2][match(comparison_betas_models_rbind_stats_per_ct$ct, renaming_pcawg[,1])]

comparison_betas_models_rbind_stats_per_ct_pool_beta <- cbind.data.frame(comparison_betas_models_rbind%>%
                     group_by(ct) %>%
                     summarise(rmse_diag_full_DMSL=sqrt(mean( (diagRE_DMSL-fullRE_DMSL)^2, na.rm = T )),
                               slope_diag_full_DMSL=as.numeric(try(coefficients(lm(y~x, data = cbind.data.frame(x=diagRE_DMSL, y=fullRE_DMSL), na.action = na.omit))[2])),
                               rmse_fullDMSL_fullM=sqrt(mean( (fullRE_M-fullRE_DMSL)^2, na.rm = T )),
                               slope_fullDMSL_fullM=as.numeric(try(coefficients(lm(y~x, data = cbind.data.frame(x=fullRE_M, y=fullRE_DMSL), na.action = na.omit))[2]))))
comparison_betas_models_rbind_stats_per_ct_pool_beta$ct2=renaming_pcawg[,2][match(comparison_betas_models_rbind_stats_per_ct_pool_beta$ct, renaming_pcawg[,1])]
        
comparison_betas_models_rbind_stats_per_ct
ggplot(comparison_betas_models_rbind, aes(x=as.numeric(fullRE_DMSL), y=as.numeric(fullRE_M), col=ct2))+
  geom_abline(slope = 1, intercept = 0, lty='dashed')+theme_bw()+
  geom_point()+theme_bw()+
  facet_wrap(.~beta_type)+
  labs(x='Beta values for fullRE DMSL', y='Beta values for fullRE M')+
  geom_smooth(aes(group=ct2), method = "lm")+
  theme(legend.title=element_blank(),
        strip.text.x = element_text(size = 10),
        legend.text=element_text(size=10), legend.position = "bottom")+guides(col=FALSE)
```

```{r, beta_coef_differences_in_models_plots_4, echo=F, dependson=c('beta_coef_differences_in_models', 'beta_coef_differences_in_models_plots', 'beta_coef_differences_in_models_plots_2', 'beta_coef_differences_in_models_plots_3'), warning=F, error=F, message=F, fig.height=3, fig.width=3, dev='tikz'}

ggplot(comparison_betas_models_rbind_stats_per_ct_pool_beta, aes(x=rmse_fullDMSL_fullM,
                                                       y=slope_fullDMSL_fullM, col=ct, label=ct2))+
  geom_point()+geom_label_repel()+theme_bw()+labs(x='RMSE of betas between\nfullDMSL and fullM',
                                                  y = 'Slope of linear model of betas\n(fullDMSL ~ fullM)')+guides(col=F)
```

```{r, beta_coef_differences_in_models_plots_5, echo=F, dependson=c('beta_coef_differences_in_models', 'beta_coef_differences_in_models_plots', 'beta_coef_differences_in_models_plots_2', 'beta_coef_differences_in_models_plots_3'), warning=F, error=F, message=F, fig.height=3, fig.width=3.8, dev='tikz'}

ggplot(comparison_betas_models_rbind_stats_per_ct, aes(x=rmse_fullDMSL_fullM,
                                                       y=slope_fullDMSL_fullM, col=ct, label=ct2))+
  geom_point()+geom_label_repel()+theme_bw()+labs(x='RMSE of betas between\nfullRE DMSL and fullRE M',
                                                  y = 'Slope of linear model of betas\n(fullRE DMSL ~ fullRE M)')+guides(col=F)+
  facet_wrap(.~beta_type)+theme(strip.text.x = element_text(size = 10))

head(comparison_betas_models_rbind_stats_per_ct)
pcawg_palette <- pcawg.colour.palette(gsub("\\..*", "", comparison_betas_models_rbind_stats_per_ct$ct),
                                      scheme = "tumour.subtype")

names(pcawg_palette) <- comparison_betas_models_rbind_stats_per_ct$ct

ggplot(comparison_betas_models_rbind_stats_per_ct, aes(x=rmse_fullDMSL_fullM,
                                                       y=slope_fullDMSL_fullM, col=ct, label=ct2))+
  geom_point()+geom_label_repel()+theme_bw()+labs(x='RMSE of betas between\nfullRE DMSL and fullRE M',
                                                  y = 'Slope of linear model of betas\n(fullRE DMSL ~ fullRE M)')+guides(col=F)+
  facet_wrap(.~beta_type)+theme(strip.text.x = element_text(size = 10))+
  scale_color_manual(values = pcawg_palette)
```

Compare the random effects intercepts. We cannot compare across cancer types because the number of observation is different. For each cancer type, compare the intercept fullRE DMSL of each patient to the intercept of fullRE M and diagRE DMSL. I.e. for each cancer type we have a boxplot. 

```{r, random_intercepts_difference, echo=F}

comparison_randomintercepts_models <- function(model_fullRE_DMSL_list, model_diagRE_DMSL_list, model_fullRE_M_list ){
  
  .x <- do.call('rbind.data.frame', lapply(enough_samples, function(ct){
    x_RE_fullRE_DMSL <- try(python_like_select_name(model_fullRE_DMSL_list[[ct]]$par.random, "u_large"))
    x_RE_diagRE_DMSL <- try(python_like_select_name(model_diagRE_DMSL_list[[ct]]$par.random, "u_large"))
    x_RE_fullRE_M <- try(python_like_select_name(model_fullRE_M_list[[ct]]$par.random, "u_large"))
    if( (length(x_RE_fullRE_DMSL) != length(x_RE_diagRE_DMSL)) | (length(x_RE_fullRE_DMSL) != length(x_RE_fullRE_M)) ){
      ## if we don't have results for any, remove from the analysis
      list_RE <- list(x_RE_fullRE_DMSL, x_RE_diagRE_DMSL, x_RE_fullRE_M)
      typeofs_of_RE <- sapply(list_RE, typeof)
      if( all(typeofs_of_RE == "character")  ){
        return(NULL)
      }else{
        ## if we do have results for some, replace the error message by an NA string
        ## replace using the length of the first double entry
        
        if(typeofs_of_RE[1] == "character"){
          x_RE_fullRE_DMSL <- rep(NA, length(list_RE[[which(typeofs_of_RE == "double")[1]]]))
        }
        
        if(typeofs_of_RE[2] == "character"){
          x_RE_diagRE_DMSL <- rep(NA, length(list_RE[[which(typeofs_of_RE == "double")[1]]]))
        }
        
        if(typeofs_of_RE[3] == "character"){
          x_RE_fullRE_M <- rep(NA, length(list_RE[[which(typeofs_of_RE == "double")[1]]]))
        }
        
        if( (length(x_RE_fullRE_DMSL) != length(x_RE_diagRE_DMSL)) | (length(x_RE_fullRE_DMSL) != length(x_RE_fullRE_M)) ){
          warning(paste0(ct, ': the number of log-ratios is not consistent'))
          return(NULL)
        }
      }
      
    }
    
    ## put the coefficients in matrix form
    ## get the number of log-ratios, d-1
    dmin1 <- (names(table(sapply(list(model_fullRE_DMSL_list, model_diagRE_DMSL_list, model_fullRE_M_list), function(i)    as.numeric(try(length(python_like_select_name(i[[ct]]$par.fixed, 'beta'))/2))))))
    if(length(dmin1) == 1){
      ## there should only be one, shared, d-1
      dmin1 <- as.numeric(dmin1)
    }else{
      stop(paste0('Models do not agree on number of log-ratios. CT: ', ct))
    }
    
    x_RE_fullRE_DMSL <- matrix(x_RE_fullRE_DMSL, ncol=dmin1, byrow=F)
    x_RE_diagRE_DMSL <- matrix(x_RE_diagRE_DMSL, ncol=dmin1, byrow=F)
    x_RE_fullRE_M <- matrix(x_RE_fullRE_M, ncol=dmin1, byrow=F)
    
    bad_fullRE_DMSL=F
    bad_diagRE_DMSL=F
    bad_fullRE_M=F
    ## if something hasn't converged, set all the random coefficients to NA
    if((typeof(model_fullRE_DMSL_list[[ct]]) == "character") ){
      bad_fullRE_DMSL=T
    }else{
      if(try(!(model_fullRE_DMSL_list[[ct]]$pdHess))){
        bad_fullRE_DMSL=T
      }
    }
    if(bad_fullRE_DMSL){
      x_RE_fullRE_DMSL <- matrix(NA, nrow = nrow(x_RE_fullRE_DMSL), ncol=ncol(x_RE_fullRE_DMSL))
    }
    #----
    if((typeof(model_diagRE_DMSL_list[[ct]]) == "character") ){
      bad_diagRE_DMSL=T
    }else{
      if(try(!(model_diagRE_DMSL_list[[ct]]$pdHess))){
        bad_diagRE_DMSL=T
      }
    }
    if(bad_diagRE_DMSL){
      x_RE_diagRE_DMSL <- matrix(NA, nrow = nrow(x_RE_diagRE_DMSL), ncol=ncol(x_RE_diagRE_DMSL))
    }
    #-----
    if((typeof(model_fullRE_M_list[[ct]]) == "character") ){
      bad_fullRE_M=T
    }else{
      if(try(!(model_fullRE_M_list[[ct]]$pdHess))){
        bad_fullRE_M=T
      }
    }
    if(bad_fullRE_M){
      x_RE_fullRE_M <- matrix(NA, nrow = nrow(x_RE_fullRE_M), ncol=ncol(x_RE_fullRE_M))
    }

    ## for each patient using the x_RE_fullRE_DMSL intercepts, get the distance to the intercepts of the other two models
    dist_DMSLs <- sapply(1:nrow(x_RE_fullRE_DMSL), function(i){
      if(all(is.na(x_RE_fullRE_DMSL[i,])) | all(is.na(x_RE_diagRE_DMSL[i,]))){
        NA
      }else{
        dist(rbind(x_RE_fullRE_DMSL[i,], x_RE_diagRE_DMSL[i,]))
      }
    })
    dist_fullREs <- sapply(1:nrow(x_RE_fullRE_DMSL), function(i){
      if(all(is.na(x_RE_fullRE_DMSL[i,])) | all(is.na(x_RE_fullRE_M[i,]))){
        NA
      }else{
        dist(rbind(x_RE_fullRE_DMSL[i,], x_RE_fullRE_M[i,]))
      }
    })
    
    cbind.data.frame(melt(list(dist_DMSLs=dist_DMSLs, dist_fullREs=dist_fullREs)),
                     ct=ct)
  }
  ))
  
  .x$ct2=renaming_pcawg[,2][match(.x$ct, renaming_pcawg[,1])]
  
  return(.x)
  
}
```


```{r, random_intercepts_difference_run, echo=F}
comparison_randomintercepts_models_all <- comparison_randomintercepts_models(model_fullRE_DMSL_list = fullRE_DMSL,
                                                       model_diagRE_DMSL_list = diagRE_DMSL,
                                                       model_fullRE_M_list = fullRE_M)
comparison_randomintercepts_models_nonexo <- comparison_randomintercepts_models(model_fullRE_DMSL_list = fullRE_DMSL_nonexo,
                                                       model_diagRE_DMSL_list = diagRE_DMSL_nonexo,
                                                       model_fullRE_M_list = fullRE_M_nonexo)

```

Would like to have the picture below in computer modern, but I cannot make boxplot work with tikz
```{r, random_intercepts_difference_analyse1, echo=F, eval=T, fig.height=2}
## remove cancer types for which we only have one comparison, or no comparison
comparison_randomintercepts_models_nonexo <- comparison_randomintercepts_models_nonexo[comparison_randomintercepts_models_nonexo$ct %in% (comparison_randomintercepts_models_nonexo %>% group_by(ct, L1) %>% summarise(good_dist=any(!is.na(value))) %>% group_by(ct) %>% summarise(good_dist2=sum(good_dist)) %>% filter(good_dist2 == 2) %>% select(ct) %>% unlist()),]
comparison_randomintercepts_models_all <- comparison_randomintercepts_models_all[comparison_randomintercepts_models_all$ct %in% (comparison_randomintercepts_models_all %>% group_by(ct, L1) %>% summarise(good_dist=any(!is.na(value))) %>% group_by(ct) %>% summarise(good_dist2=sum(good_dist)) %>% filter(good_dist2 == 2) %>% select(ct) %>% unlist()),]

comparison_randomintercepts_models_rbind <- rbind.data.frame(cbind.data.frame(comparison_randomintercepts_models_nonexo, sigs='nonexo'),
                        cbind.data.frame(comparison_randomintercepts_models_all, sigs='all'))
comparison_randomintercepts_models_rbind <- comparison_randomintercepts_models_rbind[!(is.na(comparison_randomintercepts_models_rbind$value)),]


comparison_randomintercepts_models_rbind$sigs <- recode_factor(comparison_randomintercepts_models_rbind$sigs ,
              all = "All signatures",
              nonexo = "Non-exogenous signatures")
comparison_randomintercepts_models_rbind$L1 <- recode_factor(comparison_randomintercepts_models_rbind$L1 ,
              dist_DMSLs = "Distance between fullRE DMSL/ diagRE DMSL",
              dist_fullREs = "Distance between fullRE DMSL/ fullRE M")
ggplot(comparison_randomintercepts_models_rbind,
       aes(x=as.character(ct2),
           y=value, col=L1))+
  facet_grid(.~sigs, scales='free_x', space="free_x")+
  geom_boxplot()+
  theme_bw()+theme(legend.position = "bottom", legend.title=element_blank())+labs(x='', y='Distance')

```


```{r, beta_coef_differences_in_models_pcors, echo=F, dependson=c('beta_coef_differences_in_models'), fig.height=3.2, dev='tikz'}
# comparison_betas_models_DMSL = comparison_betas_models %>% group_by(beta_type, ct) %>%
#   summarise(cor_fullRE_DMSL_diagRE_DMSL = cor(fullRE_DMSL, diagRE_DMSL), .groups = 'drop') %>% dcast(ct~beta_type, measure.vars='cor_fullRE_DMSL_diagRE_DMSL')
# 
# 
# comparison_betas_models_fullRE = comparison_betas_models %>% group_by(beta_type, ct) %>%
#   summarise(cor_fullRE_DMSL_fullRE_M = cor(fullRE_DMSL, fullRE_M), .groups = 'drop') %>% dcast(ct~beta_type, measure.vars='cor_fullRE_DMSL_fullRE_M')
# comparison_betas_models_DMSL
# comparison_betas_models_fullRE
# 
# cowplot::plot_grid(
#   ggplot(comparison_betas_models_DMSL, aes(x=intercept, y=slope, col=ct, label=ct2))+geom_point()+geom_label_repel()+theme_bw()+guides(col=F)+labs(x='Pearson correlation (intercept)', y = 'Pearson correlation (slope)'),
#   ggplot(comparison_betas_models_fullRE, aes(x=intercept, y=slope, col=ct, label=ct2))+geom_point()+
#     geom_label_repel(max.overlaps = 2)+theme_bw()+labs(x='Pearson correlation (intercept)', y = 'Pearson correlation (slope)'),
#   rel_widths=c(1, 2))

```


\section{Using subset of active signatures from the PCAWG paper}
```{r, sigs_from_paper, warning=F, echo=F}
cts_for_PCAWG <- gsub("_signaturesPCAWG_ROO.RDS", "",
                                basename(fles_roo[grepl('_signaturesPCAWG_',
                                                        fles_roo)]))
signatures_PCAWG <- sapply(cts_for_PCAWG,
       load_PCAWG, typedata = "signaturesPCAWG",
       path_to_data = "../../data/")
names(signatures_PCAWG) <- cts_for_PCAWG
```

```{r, sigs_from_paper2, warning=F, echo=F, fig.height=2.4}
# give_barplot_from_obj(obj = signatures_PCAWG[[1]], legend_on = FALSE, nrow=1, verbose=F, only_normalised=T)
sapply(cts_for_PCAWG, function(i){
  try(print(give_barplot_from_obj(obj = signatures_PCAWG[[i]], legend_on = T,
                        nrow=1, verbose=F,
                        only_normalised=T, title=i)))})

```

```{r, load_runs_signaturesPCAWG,echo=F}
fullRE_M_SP <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullREM_", ct, "_signaturesPCAWG.RDS")))
}, simplify = F); names(fullRE_M_SP) <- enough_samples
fullRE_DMSL_SP <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullREDMsinglelambda_", ct, "_signaturesPCAWG.RDS")))
}, simplify = F); names(fullRE_DMSL_SP) <- enough_samples

fullRE_M_nonexo_SP <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullREMnonexo_", ct, "_signaturesPCAWG.RDS")))
}, simplify = F); names(fullRE_M_nonexo_SP) <- enough_samples
fullRE_DMSL_nonexo_SP <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullREDMsinglelambdanonexo_", ct, "_signaturesPCAWG.RDS")))
}, simplify = F); names(fullRE_DMSL_nonexo_SP) <- enough_samples

diagRE_DMDL_SP <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/diagREDM_", ct, "_signaturesPCAWG.RDS")))
}, simplify = F); names(diagRE_DMDL_SP) <- enough_samples
diagRE_DMDL_nonexo_SP <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/diagREDMnonexo_", ct, "_signaturesPCAWG.RDS")))
}, simplify = F); names(diagRE_DMDL_nonexo_SP) <- enough_samples
```

```{r, p_vals_SP, dependson=c('load_runs_signaturesPCAWG')}

pvals_diagRE_DMDL_SP <- sapply(diagRE_DMDL_SP, function(i) try(wald_TMB_wrapper(i)))
pvals_diagRE_DMDL_nonexo_SP <- sapply(diagRE_DMDL_nonexo_SP, function(i) try(wald_TMB_wrapper(i)))
pvals_fullRE_M_nonexo_SP <- sapply(fullRE_M_nonexo_SP, function(i) try(wald_TMB_wrapper(i)))
pvals_fullRE_DMSL_nonexo_SP <- sapply(fullRE_DMSL_nonexo_SP, function(i) try(wald_TMB_wrapper(i)))

names(pvals_diagRE_DMDL_SP) <- names(pvals_diagRE_DMDL_nonexo_SP) <- names(pvals_fullRE_M_nonexo_SP) <- 
  names(pvals_fullRE_DMSL_nonexo_SP) <- enough_samples
```

```{r, pvals_diagRE_DMDL_SP_DA, dependson=c('p_vals_SP')}
pvals_diagRE_DMDL_SP

```

diagRE_DMDL_SP is missing
```{r, summary_convergence_SP, dependson=c('read_tmb_runs'), fig.height=4.2, fig.width=7, echo=FALSE, dependson=c('read_tmb_runs', 'load_runs_signaturesPCAWG')}
list_models_SP <- c( 'fullRE_M_SP', 'fullRE_DMSL_SP',
                  'fullRE_M_nonexo_SP','fullRE_DMSL_nonexo_SP', 
                  # 'diagRE_DMDL_SP',
                  'diagRE_DMDL_nonexo_SP')

all_summaries_SP <- lapply(lapply(list_models_SP, get), function(i){
    give_summary_of_runs2(i, long_return = T)})
names(all_summaries_SP) <- list_models_SP

ggplot(melt(all_summaries_SP), aes(x=factor(L1, levels=list_models_SP), y=value, fill=L2))+geom_tile()+
  theme(axis.text.x=element_text(angle = 45, hjust = 1, vjust=1))+
  # theme(legend.position = "bottom")+
  labs(x='')
```


```{r, names_logR_SP, dependson=c('load_runs_signaturesPCAWG'), echo=FALSE}
## for names of betas
colnames_all_sorted_SP <- list()
logR_all_sorted_SP <- list()
colnames_nonexo_sorted_SP <- list()
logR_nonexo_sorted_SP <- list()
colnames_nonexo_notsorted_SP <- list()
logR_nonexo_notsorted_SP <- list()

for(ct in enough_samples){

  colnames_all_sorted_SP[[ct]] <- colnames(sort_columns_TMB(load_PCAWG(ct = ct, typedata = "signaturesPCAWG",
                                     path_to_data = "../../data/"))$Y)
  logR_all_sorted_SP[[ct]] <- vector_cats_to_logR(colnames_all_sorted_SP[[ct]])
  colnames_nonexo_sorted_SP[[ct]] <- colnames(sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signaturesPCAWG",
                                     path_to_data = "../../data/"), nonexogenous$V1))$Y)
  logR_nonexo_sorted_SP[[ct]] <- vector_cats_to_logR(colnames_nonexo_sorted_SP[[ct]])
  colnames_nonexo_notsorted_SP[[ct]] <- colnames(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signaturesPCAWG",
                                     path_to_data = "../../data/"), nonexogenous$V1)$Y)
  logR_nonexo_notsorted_SP[[ct]] <- vector_cats_to_logR(colnames_nonexo_notsorted_SP[[ct]])
}

```

## differences between signatures from sigprofiler from the paper, and the ones I get

- biliary adenoca similar, though not exact
- bladder tcc: very similar
- bone benign: similar
- bone epith: extremely similar
- bone osteosarc: I have a lot of SBS8, which they don't. Other than that, similar
- breast adenicaL I have a lot of SBS9, which  they don't. Other than that, similar
- breast DCIS: I have more SBS40 than they do
- breast lobularca: very similar
- cervix adenoca: very similar
- cervix SCC: very similar, although I have more SBS40
- CNS GBM: very similar, mine seem to be more homogeneous
- CNS medullo: very similar, mine seem to be more homogeneous
- CNS oligo: very similar, mine seem to be more homogeneous
- CNS piloastro: very similar, mine seem to be more homogeneous
- Colorect adenoca: quite similar
- eso adenoca: very similar
- head scc: very similar, mine seem to be more homogeneous
- kidney chrcc: very similar
- kidney rcc.clearcell: very similar, although I have more SBS29
- kidney papillary: only I have it
- liver hcc: different. I have a lot of SBS40 and SBS12, they have mostly SBS5 ***
- lung adenoca: very similar
- lung SCC: very similar, though I have more SBS8
- lymph BNHL: very similar
- Lymph CLL: very similar, althpugh theirs are much more sparse
- myeloid AML: very similar, although I don't have any SBS60 and they seem to have
- myeloid MDS: I don't have it
- myeloid MPN: similar, although mine is much more sparse
- ovary adenoca: different. I have a lot of SBS40, which in their case is rare, and they have much more of SBS3 than I do ***
- panc-adenoca: different. I have a lot of SBS8 that they don't have. ***
- panc-endocrine: sort of similar. I have more SBS8 than they and they have more SBS5
- Prost-adenoca: sort of similar, I have more SBS8
- skin-melanoma.acral: they don't have this category. They have "skin-melanoma", which might be both together? (!!!) Similar exposures...
- softtissue-leiomyo: very similar exposures
- softtissue-liposarc: very similar exposures
- stomach adenoca: very similar, mine seem to be more homogeneous
- thy-adenoca: very similar
- uterus-adenoca: very similar

```{r, signaturesPCAWG_names_sigs,echo=F, dependson=c('load_runs_signaturesPCAWG')}
colnames_notsorted_SP <- list()
logR_notsorted_SP <- list()
colnames_nonexo_notsorted_SP <- list()
logR_nonexo_notsorted_SP <- list()

for(ct in enough_samples){
    colnames_notsorted_SP[[ct]] <- try(colnames(load_PCAWG(ct = ct, typedata = "signaturesPCAWG",
                                                 path_to_data = "../../data/")$Y))
  logR_notsorted_SP[[ct]] <- try(vector_cats_to_logR(colnames_notsorted_SP[[ct]]))
  
  colnames_nonexo_notsorted_SP[[ct]] <- try(colnames(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signaturesPCAWG",
                                                 path_to_data = "../../data/"), nonexogenous$V1)$Y))
  logR_nonexo_notsorted_SP[[ct]] <- try(vector_cats_to_logR(colnames_nonexo_notsorted_SP[[ct]]))
}
```

\section{Betas from PCAWG subset of signatures}
Reminder that the clonesig signatures were a subset of WES data.

```{r, plot_betas_signaturesPCAWG, echo=F, fig.height=2, warning=FALSE, dependson=c('load_runs_signaturesPCAWG')}
logR_notsorted_SP

for(ct in enough_samples){
  grid.arrange(plot_betas(fullRE_M_SP[[ct]], only_slope=T, plot=F,
                          names_cats=logR_notsorted_SP[[ct]])+ggtitle('fullRE M'),
               plot_betas(fullRE_DMSL_SP[[ct]], only_slope=T, plot=F,
                          names_cats=logR_notsorted_SP[[ct]])+ggtitle('fullRE DMSL'),
               plot_betas(fullRE_M_nonexo_SP[[ct]], only_slope=T, plot=F,
                          names_cats=logR_nonexo_notsorted_SP[[ct]])+ggtitle('fullRE M\nnonexo'),
               plot_betas(fullRE_DMSL_nonexo_SP[[ct]], only_slope=T, plot=F,
                          names_cats=logR_nonexo_notsorted_SP[[ct]])+ggtitle('fullRE DMSL\nnonexo'),
               top=ct, nrow=1)
}

```

\section{Overdispersion parameters in double-lambda DM}
```{r, overdispersion_params_groups, dependson=c('load_runs_signaturesPCAWG'), fig.width=8.5, fig.height=7}
sapply(diagRE_DMDL_SP, typeof)
sapply(diagRE_DMDL_nonexo_SP, typeof)
python_like_select(list.files("../../data/pcawg_robjects_cache/tmb_results/nlminb/"), 'diagREDM_')
python_like_select(list.files("../../data/pcawg_robjects_cache/tmb_results/nlminb/"), 'diagREDMnonexo')

ovrdisp <- do.call('rbind.data.frame', lapply(1:length(diagRE_DMDL_nonexo_SP), try(function(idx){
  if(diagRE_DMDL_nonexo_SP[[idx]]$pdHess){
    cbind.data.frame( plot_lambdas(diagRE_DMDL_nonexo_SP[[idx]], return_df=T, plot=F), ct=names(diagRE_DMDL_nonexo_SP)[idx])
  }else{
    c(NA, NA)
  }
})))
ovrdisp
ovrdisp[ovrdisp$name == 'Lambda 1','name'] = 'Early'
ovrdisp[ovrdisp$name == 'Lambda 2','name'] = 'Late'

ggplot(ovrdisp, aes(x=name,  y=`Estimate`))+
  geom_point()+
  geom_errorbar(aes(ymin=`Estimate`-`Std..Error`,
                    ymax=`Estimate`+`Std..Error`), width=.1)+
  theme_bw()+
  facet_wrap(.~ct, scales = "free_y", nrow=6)+
  labs(x='', y='Log lambda')


```

```{r, overdispersion_params_groups_2, dev='tikz', dependson=c('load_runs_signaturesPCAWG')}
ggplot(ovrdisp, aes(x=ct,  y=`Estimate`, group=name, col=name))+
  geom_point(position=position_dodge(width=0.5))+
  geom_errorbar(aes(ymin=`Estimate`-`Std..Error`,
                    ymax=`Estimate`+`Std..Error`), width=.1, position=position_dodge(width=0.5))+
  theme_bw()+
  theme(axis.text.x=element_text(angle = 45, hjust = 1, vjust=1))+
  labs(x='', y='Log lambda', col='Group')+theme(legend.position = "bottom")+
    theme(        legend.margin=margin(0,0,0,0),
                  legend.box.margin=margin(-10,-10,-10,-10),
                  plot.margin = unit(c(1,1,1,1), "cm"))
```

\section{Minimal perturbation}
Note: this is using the original, non SP, signatures (hence not the best version).
```{r, minimal_pert_1, dependson=c('load_runs_signaturesPCAWG')}
minimalpert_L2 <- function(i){
  sum(i)/sum(i^2)
}

betas_breast <- data.frame(plot_betas(diagRE_DMSL_nonexo[["Breast-AdenoCA"]], names_cats= logR_nonexo_notsorted[["Breast-AdenoCA"]],
                           return_df=T, plot=F))

.slopes_minpert <- betas_breast %>% dplyr::filter(type_beta == "Slope") %>% dplyr::select(Estimate) %>% unlist()

# minimalpert_L2(softmax(c(.slopes_minpert, 0)))
median(c(.slopes_minpert, 0))

aa <- plot_betas(diagRE_DMSL_nonexo[["Breast-AdenoCA"]], names_cats= logR_nonexo_notsorted[["Breast-AdenoCA"]],
                           return_df=F, plot=F, only_slope = T, line_zero=F)
# aa <- geom_hline(yintercept = 0)+geom_vline(xintercept = 1)+geom_hline(yintercept = median(c(.slopes_minpert, 0)), lty='dashed', col='blue')
aa + geom_hline(yintercept = median(c(.slopes_minpert, 0)), lty='dashed', col='blue')+
  geom_hline(yintercept = mean(c(.slopes_minpert, 0)), lty='dashed', col='red')

```

For the thesis:
```{r, thesis_minimal_perturbation, echo=F, fig.height=2.4, fig.width=3, dev='tikz', dependson=c('load_runs_signaturesPCAWG')}

# betas_breast <- data.frame(plot_betas(diagRE_DMSL_nonexo[["Breast-AdenoCA"]], names_cats= logR_nonexo_notsorted[["Breast-AdenoCA"]],
#                            return_df=T, plot=F))
# .slopes_minpert <- betas_breast %>% dplyr::filter(type_beta == "Slope") %>% dplyr::select(Estimate) %>% unlist()
# 
# aa <- plot_betas(TMB_obj = diagRE_DMSL_nonexo[["Breast-AdenoCA"]], names_cats= logR_nonexo_notsorted[["Breast-AdenoCA"]],
#                            return_df=F, plot=F, only_slope = T, line_zero=F, add_confint =F)
# aa + geom_hline(yintercept = median(c(.slopes_minpert, 0)), lty='dashed', col='blue')


betas_breast <- data.frame(plot_betas(TMB_obj = diagRE_DMDL_nonexo_SP[["Breast-AdenoCA"]],
                                      names_cats= logR_nonexo_notsorted_SP[["Breast-AdenoCA"]],
                           return_df=T, plot=F))
.slopes_minpert <- betas_breast %>% dplyr::filter(type_beta == "Slope") %>% dplyr::select(Estimate) %>% unlist()
aaa <- plot_betas(TMB_obj = diagRE_DMDL_nonexo_SP[["Breast-AdenoCA"]], names_cats= logR_nonexo_notsorted_SP[["Breast-AdenoCA"]],
                           return_df=F, plot=F, only_slope = T, line_zero=F, add_confint = T)
aaa + geom_hline(yintercept = median(c(.slopes_minpert, 0)), lty='dashed', col='blue')+ggtitle("")+labs(x='Log ratio of signatures')+
  theme(strip.background = element_blank(), strip.text = element_blank()) 

```

\subsection{Minimal perturbation in diagRE_DMDL_nonexo_S}
```{r, minimalperturbation_diagRE_DMDL_nonexo_S, dependson=c('load_runs_signaturesPCAWG')}

perturbed_betas_diagRE_DMDL_nonexo_SP <- lapply(names(diagRE_DMDL_nonexo_SP), try(function(idx_sp){
  .betas_SP <- data.frame(plot_betas(diagRE_DMDL_nonexo_SP[[idx_sp]], names_cats= logR_nonexo_notsorted_SP[[idx_sp]],
                             return_df=T, plot=F))
  
  .slopes_minpert_SP <- .betas_SP %>% dplyr::filter(type_beta == "Slope") %>% dplyr::select(Estimate) %>% unlist()
  # print(.slopes_minpert_SP)
  ## check if the CI of the betas touches this median value
  .summary_betas_slope_SP <- python_like_select_rownames(summary(diagRE_DMDL_nonexo_SP[[idx_sp]]), 'beta')[c(F,T),]
  nrow(.summary_betas_slope_SP)
  # print(.summary_betas_slope_SP)
  # print(logR_nonexo_notsorted_SP[[idx_sp]])
  # print(dim(.summary_betas_slope_SP))
  if(!is.null(dim(.summary_betas_slope_SP))){
    .params_in_ci <- give_params_in_CI(vec_est=.summary_betas_slope_SP[,1],
                      vec_stderr=.summary_betas_slope_SP[,2],
                      vec_true=rep(median(c(.slopes_minpert, 0)), nrow(.summary_betas_slope_SP)))
    names(.params_in_ci) <- sapply(logR_nonexo_notsorted_SP[[idx_sp]], function(i) strsplit(i, '/')[[1]][1])
  }else{
    .params_in_ci <- give_params_in_CI(vec_est=.summary_betas_slope_SP[1],
                      vec_stderr=.summary_betas_slope_SP[2],
                      vec_true=(median(c(.slopes_minpert, 0))))
  }
  .baseline <- strsplit(logR_nonexo_notsorted_SP[[idx_sp]][[1]], '/')[[1]][2]
  return(list(betas_perturbed=.params_in_ci, baseline=.baseline))
}))


```

```{r, minimalperturbation_diagRE_DMDL_nonexo_S_2, dependson=c('minimalperturbation_diagRE_DMDL_nonexo_S', 'load_runs_signaturesPCAWG'), dev='tikz'}
perturbed_betas_diagRE_DMDL_nonexo_SP_vec <- do.call('c', sapply(perturbed_betas_diagRE_DMDL_nonexo_SP, function(i) i[1]))
perturbed_betas_diagRE_DMDL_nonexo_SP_df <- cbind.data.frame(sig=gsub("betas_perturbed.", "", names(perturbed_betas_diagRE_DMDL_nonexo_SP_vec)),
                 perturbed=perturbed_betas_diagRE_DMDL_nonexo_SP_vec)

ggplot(perturbed_betas_diagRE_DMDL_nonexo_SP_df, aes(x=factor(sig, levels=gtools::mixedsort(unique(sig))), fill=factor(perturbed, levels=c(TRUE, FALSE))))+geom_bar(col='black', size=0.001)+theme_bw()+
  theme(axis.text.x=element_text(angle = 45, hjust = 1, vjust=1))+
      scale_fill_manual(values=c('#f08080', '#e7feff'))+theme(legend.position = "bottom")+
  labs(x='Signatures', y='Number of putatively perturbed\n and unperturbed signatures', fill='Perturbed')

```

```{r, minimalperturbation_diagRE_DMDL_nonexo_S_3, dependson=c('minimalperturbation_diagRE_DMDL_nonexo_S', 'load_runs_signaturesPCAWG'), dev='tikz'}
names(perturbed_betas_diagRE_DMDL_nonexo_SP) <- names(diagRE_DMDL_nonexo_SP)
ggplot(reshape2::melt(lapply(perturbed_betas_diagRE_DMDL_nonexo_SP, `[`, 'betas_perturbed')),
       aes(x=L1, fill=factor(value, levels=c(TRUE, FALSE))))+geom_bar(col='black', size=0.001)+theme_bw()+
        scale_fill_manual(values=c('#f08080', '#e7feff'))+theme(legend.position = "bottom")+
    theme(axis.text.x=element_text(angle = 45, hjust = 1, vjust=1))+labs(x='Cancer type',
                                                                         y='Number of putatively perturbed\n and unperturbed signatures')


# ggplot(perturbed_betas_diagRE_DMDL_nonexo_SP_df, aes(x=factor(sig, levels=gtools::mixedsort(unique(sig))), fill=factor(perturbed, levels=c(TRUE, FALSE))))+geom_bar(col='black', size=0.001)+theme_bw()+
#   theme(axis.text.x=element_text(angle = 45, hjust = 1, vjust=1))+
#       scale_fill_manual(values=c('#f08080', '#e7feff'))+theme(legend.position = "bottom")+
#   labs(x='Signatures', y='Number of putatively perturbed and unperturbed signatures', fill='Perturbed')

```

```{r, effectsize1_SP, dependson=c('load_objects_all', 'load_runs_signaturesPCAWG'), echo=F, fig.height=4.5, fig.width=4}
all_objects_SP <- lapply(enough_samples, function(ct){load_PCAWG(ct = ct, typedata = "signaturesPCAWG")})
names(all_objects_SP) <- enough_samples
all_objects_nonexo_SP <- lapply(enough_samples, function(ct){
  try(give_subset_sigs_TMBobj(all_objects_SP[[ct]],
                       sigs_to_remove = unique(nonexogenous$V1)))
})
names(all_objects_nonexo_SP) <- enough_samples

num_samples_all_SP <- sapply(enough_samples, function(ct){
    .xx <- all_objects_SP[[ct]]
    try(nrow(.xx$Y)/2)
})
num_samples_nonexo_SP <- sapply(enough_samples, function(ct){
    .xx <- all_objects_nonexo_SP[[ct]]
    try(nrow(.xx$Y)/2)
})

num_sigs_SP <- sapply(enough_samples, function(ct){
    .xx <- all_objects_SP[[ct]]
    try(ncol(.xx$Y))
})

num_sigs_nonexo_SP <- sapply(enough_samples, function(ct){
    .xx <- all_objects_nonexo_SP[[ct]]
    try(ncol(.xx$Y))
})



effect_size1nonexo_SP <- sapply(enough_samples, function(ct){
  .xx <- all_objects_nonexo_SP[[ct]]
  print(dim(.xx$Y[1:(nrow(.xx$Y)/2),]))
  print(dim(.xx$Y[(1+nrow(.xx$Y)/2):(nrow(.xx$Y)),]))
  try(compute_effect_size_1(mat1 = .xx$Y[1:(nrow(.xx$Y)/2),], mat2 = .xx$Y[(1+nrow(.xx$Y)/2):(nrow(.xx$Y)),]))
})
names(effect_size1nonexo_SP) <- enough_samples

# ggplot(cbind.data.frame(effect_size=as.numeric(effect_size1nonexo_SP),
#                         num_samples=as.numeric(num_samples[match(enough_samples, names(num_samples_all_SP))]),
#                         minlogpval=-log(as.numeric(pvals_diagRE_DMDL_nonexo_SP[match(enough_samples,
#                                                                                      names(pvals_diagRE_DMDL_nonexo_SP))])),
#                         label=enough_samples),
#        aes(x=effect_size1nonexo_SP, y=minlogpval, shape=exp(-minlogpval)<0.05,
#            label=label))+
#   theme_bw()+
#   geom_point(aes(col=num_samples))+geom_label_repel(alpha=0.4)+
#   theme(legend.position = "bottom")+ggtitle('Effect size #1, nonexo')


## another effect size

num_sigs_nonexo_SP

## all sigs
effect_size3_SP <- sapply(enough_samples, function(ct){
  .xx <- all_objects_SP[[ct]]
  try(give_totalperturbation_TMBobj_sigaverage(.xx, addone=T))
})
effect_size3_SP <- as.numeric(effect_size3_SP)

names(effect_size3_SP) <- enough_samples

## nonexo
effect_size3nonexo_SP <- sapply(enough_samples, function(ct){
  .xx <- all_objects_nonexo_SP[[ct]]
  try(give_totalperturbation_TMBobj_sigaverage(.xx, addone=T))
})
effect_size3nonexo_SP <- as.numeric(effect_size3nonexo_SP)

names(effect_size3nonexo_SP) <- enough_samples
```

```{r, effectsize1_SP_2, dependson=c('load_objects_all', 'load_runs_signaturesPCAWG', 'p_vals_SP'), echo=F, fig.height=4.5, fig.width=4}

ggplot(cbind.data.frame(effect_size=as.numeric(effect_size3nonexo_SP),
                        num_samples=as.numeric(num_samples[match(enough_samples, names(num_samples_nonexo_SP))]),
                        minlogpval=-log(as.numeric(pvals_diagRE_DMDL_nonexo_SP[match(enough_samples,
                                                                                     names(pvals_diagRE_DMDL_nonexo_SP))])),
                        label=enough_samples),
       aes(x=effect_size, y=minlogpval, shape=exp(-minlogpval)<0.05,
           label=label))+
  theme_bw()+
  geom_point(aes(col=log(num_samples)))+geom_label_repel(alpha=0.4)+
  theme(legend.position = "bottom")+ggtitle('Total perturbation\nnon-exogenous signatures')+
  jcolors::scale_color_jcolors_contin("pal3", reverse = TRUE, bias = 2.25)+
    labs(x='Effect size', y='Negative log p-value')+
  guides(shape=F)


effect_size3_SP
pvals_diagRE_DMDL_SP
ggplot(cbind.data.frame(effect_size=as.numeric(effect_size3_SP),
                        num_sigs=as.numeric(num_sigs_SP[match(enough_samples, names(num_sigs_SP))]),
                        minlogpval=-log(as.numeric(pvals_diagRE_DMDL_SP[match(enough_samples,
                                                                              names(pvals_diagRE_DMDL_SP))])),
                        label=enough_samples),
       aes(x=effect_size, y=minlogpval, shape=exp(-minlogpval)<0.05,
           label=label))+
  theme_bw()+
  geom_point(aes(col=num_sigs))+geom_label_repel(alpha=0.4, size=3)+
  theme(legend.position = "bottom")+#ggtitle('Total perturbation\nnon-exogenous signatures')+
  jcolors::scale_color_jcolors_contin("pal3", reverse = TRUE)+
    labs(x='Effect size', y='Negative log p-value (all signatures)', col='Number of signatures')+
  guides(shape=F)

ggplot(cbind.data.frame(effect_size=as.numeric(effect_size3nonexo_SP),
                        num_sigs=as.numeric(num_sigs_nonexo_SP[match(enough_samples, names(num_sigs_nonexo_SP))]),
                        minlogpval=-log(as.numeric(pvals_diagRE_DMDL_nonexo_SP[match(enough_samples,
                                                                                     names(pvals_diagRE_DMDL_nonexo_SP))])),
                        label=enough_samples),
       aes(x=effect_size, y=minlogpval, shape=exp(-minlogpval)<0.05,
           label=label))+
  theme_bw()+
  geom_point(aes(col=num_sigs))+geom_label_repel(alpha=0.4, size=3)+
  theme(legend.position = "bottom")+#ggtitle('Total perturbation\nnon-exogenous signatures')+
  jcolors::scale_color_jcolors_contin("pal3", reverse = TRUE)+
    labs(x='Effect size', y='Negative log p-value (non-exogenous signatures)', col='Number of signatures')+
  guides(shape=F)
```

\section{HMP}
Simple HMP tests to see what is differentially abundant
```{r, HMP_pcawg, echo=F}
# source("../1_create_ROO/roo_functions.R")
# signature_roo[[1]]
require(HMP)
HMP_res_sigs <- lapply(signature_roo, function(signature_roo_it){
  HMP::Xdc.sevsample(list(t(signature_roo_it[[1]]),
                      t(signature_roo_it[[2]])))
})
names(HMP_res_sigs) <- names(signature_roo)
# test_HMP_ROOSigs(signature_roo[[1]],  slot='count_matrices_active')
```

```{r, HMP_pcawg_2}
HMP_res_sigs
pvals_diagRE_DM
```

See script `PCAWG_HMP_and_alternative_methods.R` for the analyses of PCAWG data using alternative models.

\section{Tracksig}

```{r, tracksig_comparison, fig.height=6, fig.width=6, dev='tikz'}

tracksig = read.csv("../../data/restricted/tracksig/changepoints_stats_tracksig.csv", stringsAsFactors = FALSE)
tracksig = tracksig %>% group_by(type) %>% dplyr::summarize(count = n(), bool_changepoints=sum(n_changepoints > 0))%>%
  mutate(tracksig_frac= bool_changepoints/count  )
tracksig = cbind.data.frame(pvals_diagRE_DM,
                 tracksig[match(names(pvals_diagRE_DM), tracksig$type),],
                 effect_size3_SP=effect_size3_SP[match(names(pvals_diagRE_DM), names(effect_size3_SP))])
tracksig$ct = rownames(tracksig)
tracksig$minpvals = -log2(tracksig$pvals_diagRE_DM)

ggplot(tracksig, aes(x=pvals_diagRE_DM, y=tracksig_frac, label=ct))+geom_point()+geom_label_repel()+
  labs(x='P-value of diagRE DMDL', y='Fraction of TrackSig samples with some changepoint')+scale_x_continuous(trans = "log2")+theme_bw()

pcawg_palette <- pcawg.colour.palette(gsub("\\..*", "", tracksig$ct), scheme = "tumour.subtype")
names(pcawg_palette) <- tracksig$ct

ggplot(tracksig, aes(x=effect_size3_SP, y=tracksig_frac, label=ct, col=ct))+
  geom_point(aes(size=minpvals))+geom_label_repel(max.overlaps = 5)+
  labs(x='Effect size', y='Fraction of TrackSig samples with some changepoint', col="")+theme_bw()+
  scale_color_manual(values = pcawg_palette)+theme(legend.position = "bottom")+
  guides(col=guide_legend(ncol=4), size=FALSE)

```