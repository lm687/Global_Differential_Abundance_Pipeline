---
title: "Summary of TMB runs"
author: "Lena Morrill"
date: "24/05/2021"
output: pdf_document
header-includes:
   - \usepackage{array}
   - \setlength{\textwidth}{6.7in}
   - \setlength{\oddsidemargin}{-0.1in}
   - \setlength{\textheight}{8.6in}
   - \setlength{\topmargin}{-0.4in}
   - \newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
   - \newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
   - \newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache=TRUE)
```

```{r libraries, echo=FALSE, message=FALSE, cache=TRUE, results='hide'}

library(Ternary)
library(MCMCpack)
library(TMB)
library(dplyr)
library(parallel)
library(umap)
library(gridExtra)
library(pheatmap)
library(ggplot2)
library(ggrepel)
library(RColorBrewer)

source("../2_inference_TMB/helper_TMB.R")
source("../../../CDA_in_Cancer/code/functions/meretricious/pretty_plots/prettySignatures.R")

TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda2.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda2"))
TMB::compile("../2_inference_TMB/mm_multinomial/diagRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/diagRE_dirichletmultinomial_single_lambda"))
TMB::compile("../2_inference_TMB/mm_multinomial/diagRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/diagRE_ME_dirichletmultinomial"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda2.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda2"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial_singlecov.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial_singlecov"))
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_halfdirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_halfdirichletmultinomial"))
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_dirichletmultinomial"))
TMB::compile("../2_inference_TMB/mm_multinomial/diagRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/diagRE_ME_dirichletmultinomial"))
TMB::compile("../2_inference_TMB/mm_multinomial/diagRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/diagRE_ME_multinomial"))
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))


```

```{r,, load_functions, cache=FALSE}

source("../2_inference_TMB/helper_TMB.R")
source("../../../CDA_in_Cancer/code/functions/meretricious/pretty_plots/prettySignatures.R")

```

```{r, read_ct, echo=FALSE}
enough_samples = read.table("../../data/restricted/pcawg/CT_sufficient_samples.txt", comment.char='#')[,1]
nonexogenous = read.table("../../data/cosmic/exogenous_signatures_SBS.txt", sep = "\t",
                          comment.char = "#", fill = F)
subset_sigs_sparse_cov_idx_nonexo <- read.table("../../current/subset_sigs_sparse_cov_idx_nonexo.txt", stringsAsFactors = F, fill = T)
fles_roo <- list.files("../../data/roo/", full.names = T)

```

```{r, dimensionality_reduction, echo=FALSE}
signature_roo <- sapply(fles_roo[grepl('_signatures_', fles_roo)], readRDS)
signature_mutsigextractor_roo <- sapply(fles_roo[grepl('_signaturesmutSigExtractor_', fles_roo)], readRDS)

signature_roo <- sapply(signature_roo, function(i) try(slot(i, 'count_matrices_all')))
names(signature_roo) <- gsub("_signatures_ROO.RDS", "", basename(fles_roo[grepl('_signatures_', fles_roo)]))
signature_roo <- signature_roo[match(enough_samples, names(signature_roo))]
signature_roo <- signature_roo[sapply(signature_roo, typeof) == "list"]

signature_mutsigextractor_roo <- sapply(signature_mutsigextractor_roo, function(i) try(slot(i, 'count_matrices_all')))
names(signature_mutsigextractor_roo) <- gsub("_signaturesmutSigExtractor_ROO.RDS", "", basename(fles_roo[grepl('_signaturesmutSigExtractor_', fles_roo)]))
signature_mutsigextractor_roo <- signature_mutsigextractor_roo[match(enough_samples, names(signature_mutsigextractor_roo))]
signature_mutsigextractor_roo <- signature_mutsigextractor_roo[sapply(signature_mutsigextractor_roo, typeof) == "list"]


signature_roo_all <- do.call('rbind', lapply(signature_roo, function(i) rbind(i[[1]], i[[2]])))
signature_roo_all <- normalise_rw(signature_roo_all)
signature_roo_all_umap <- umap(signature_roo_all)

signature_roo_all_mutsigextractor <- do.call('rbind', lapply(signature_mutsigextractor_roo, function(i) rbind(i[[1]], i[[2]])))
signature_roo_all_mutsigextractor <- normalise_rw(signature_roo_all_mutsigextractor)
signature_roo_all_mutsigextractor_umap <- umap(signature_roo_all_mutsigextractor)


n <- length(signature_roo)
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
names(col_vector) = names(signature_roo)

ggplot(cbind.data.frame(umap=signature_roo_all_umap$layout[,1:2], ct=rep(names(signature_roo), unlist(sapply(signature_roo, function(i) nrow(i[[1]])*2)))),
     aes(x=umap.1, y=umap.2, col=ct))+facet_wrap(.~ct)+
  geom_point(data=do.call('rbind', lapply(names(signature_roo), function(i) cbind.data.frame(umap=signature_roo_all_umap$layout[,1:2], ct=i))),
             col='gray', alpha=0.2)+
  geom_point()+
  scale_color_manual(values = col_vector)+guides(col=FALSE)+theme_bw()+labs(x='UMAP dimension #1',
                                                                            y='UMAP dimension #2')
# ggsave("../../../results/exploratory/umap_exposures.pdf", height = 9, width = 9)


ggplot(cbind.data.frame(umap=signature_roo_all_mutsigextractor_umap$layout[,1:2], ct=rep(names(signature_mutsigextractor_roo), unlist(sapply(signature_mutsigextractor_roo, function(i) nrow(i[[1]])*2)))),
       aes(x=umap.1, y=umap.2, col=ct))+facet_wrap(.~ct)+
  geom_point(data=do.call('rbind', lapply(names(signature_mutsigextractor_roo), function(i) cbind.data.frame(umap=signature_roo_all_mutsigextractor_umap$layout[,1:2], ct=i))),
             col='gray', alpha=0.2)+
  geom_point()+
  scale_color_manual(values = col_vector)+guides(col=FALSE)+theme_bw()+labs(x='UMAP dimension #1',
                                                                            y='UMAP dimension #2')
# ggsave("../../../results/exploratory/umap_exposures_mutsigextractor.pdf", height = 9, width = 9)

```

```{r, read_tmb_runs, warning=FALSE, echo=FALSE, message=FALSE, error=FALSE, results='hide'}
diagRE_DMSL <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/diagRE_DMSL_", ct, "_signatures.RDS")))
}, simplify = F)

diagRE_DMDL <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/optim/diagRE_DM_", ct, "_signatures.RDS")))
}, simplify = F)

fullRE_DMDL <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/optim/fullRE_DM_", ct, "_signatures.RDS")))
}, simplify = F)

fullRE_M_nonexo <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullRE_nonexo_M_", ct, "_signatures.RDS")))
}, simplify = F)

fullRE_M <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/optim/fullRE_M_", ct, "_signatures.RDS")))
}, simplify = F)

diagRE_M <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/optim/diagRE_M_", ct, "_signatures.RDS")))
}, simplify = F)

sparseRE_DMSL <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/sparseRE_DMSL2_", ct, "_signatures.RDS")))
}, simplify = F)

fullRE_DMDL_nonexo <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fulLRE_nonexo_DM_", ct, "_signatures.RDS")))
}, simplify = F)

fullRE_DMDL_sortednonexo <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fulLRE_sortednonexo_DM_", ct, "_signatures.RDS")))
}, simplify = F)

fullRE_DMSL_nonexo <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullRE_nonexo_DMSL_", ct, "_signatures.RDS")))
}, simplify = F)

diagRE_DMSL_nonexo <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/diagRE_nonexo_DMSL_", ct, "_signatures.RDS")))
}, simplify = F)

fullRE_DMSL_SBS1 <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullRE_SBS1baseline_DMSL_", ct, "signatures.RDS")))
}, simplify = F)

fullRE_halfDM <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullRE_halfDM_", ct, "signatures.RDS")))
}, simplify = F)

fullRE_DMSL <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullRE_DMSL_", ct, "_signatures.RDS")))
}, simplify = F)

diagRE_DMSL <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/diagRE_DMSL_", ct, "_signatures.RDS")))
}, simplify = F)

sparseRE_DMSL_nonexo <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/sparseRE_nonexo_DMSL_", ct, "_signatures.RDS")))
}, simplify = F)

```

\tableofcontents

\newpage

\section{Information about models}

\subsection{Default order of categories for each model}
\begin{tabular}{llL{1in}l}
Name model & Extension & Sorted & File in which they were created\\\hline\hline
\verb|fullREDMsinglelambda| &	\verb|fullRE_DMSL_|	& Not sorted &	\verb|run_TMB_PCAWG.R|\\\hline
\verb|fullREDMsinglelambda2|	& \verb|fullRE_DMSL2_|	& Sorted	& \verb|run_TMB_PCAWG.R|\\\hline
\verb|diagREDMsinglelambda| & 	\verb|diagRE_DMSL_|	& Unknown	& \verb|run_TMB_PCAWG.R|\\\hline
\verb|fullRE_M|	& \verb|fullRE_M_| & Sorted in previous version of \verb|wrapper_run_TMB|& \verb|run_TMB_PCAWG.R|\\\hline
\verb|diagRE_DM|	& \verb|diagRE_DM_| & Sorted in previous version of \verb|wrapper_run_TMB|& \verb|run_TMB_PCAWG.R|\\\hline
\verb|fullRE_DM|	& \verb|fullRE_DM_| & Sorted in previous version of \verb|wrapper_run_TMB|& \verb|run_TMB_PCAWG.R|\\\hline
\verb|sparseRE_DMSL2|	& \verb|sparseRE_nonexo_DMSL_| & Sorted & 	\verb|find_subset_signatures.R|\\\hline
\verb|fullREDMsinglelambda| &	\verb|fullRE_nonexo_DMSL_| &	Not sorted &	\verb|find_subset_signatures.R| \\\hline
\verb|fullRE_M| &	\verb|fullRE_nonexo_M_|	& Not sorted &	\verb|find_subset_signatures.R| \\\hline
\verb|diagREDMsinglelambda|	& \verb|diagRE_nonexo_DMSL_| &	Not sorted &	\verb|find_subset_signatures.R| \\\hline
\verb|fullRE_DM| &	\verb|fulLRE_nonexo_DM_| &	Not sorted &	\verb|find_subset_signatures.R| \\\hline
\verb|diagREDMsinglelambda| &	\verb|diagRE_DMSL_| &	Not sorted &	\verb|find_subset_signatures.R|\\\hline
\end{tabular}

\clearpage
\section{General results of all models}
Check the results of all of the models

```{r, summary_convergence, dependson=c('read_tmb_runs'), fig.height=6, echo=FALSE, dependson=c('read_tmb_runs')}
list_models <- c( 'diagRE_M', 'fullRE_M',
                  'diagRE_DMDL','fullRE_halfDM', 'fullRE_DMDL', 
                  'diagRE_DMSL','sparseRE_DMSL', 'fullRE_DMSL', 'fullRE_DMSL_SBS1',
                  'fullRE_M_nonexo','diagRE_DMSL_nonexo','sparseRE_DMSL_nonexo', 'fullRE_DMSL_nonexo',
                  'fullRE_DMDL_nonexo', 'fullRE_DMDL_sortednonexo')

all_summaries <- lapply(lapply(list_models, get), function(i){
    give_summary_of_runs2(i, long_return = T)})
names(all_summaries) <- list_models

ggplot(melt(all_summaries), aes(x=factor(L1, levels=list_models), y=value, fill=L2))+geom_tile()+
  theme(axis.text.x=element_text(angle = 45, hjust = 1, vjust=1))+theme(legend.position = "bottom")+
  labs(x='')

```

\subsection{P-values for all cancer types}

```{r, all_pvals, echo=FALSE, results='hide', warning=FALSE, message=FALSE}
pvals_fullRE_M <- sapply(fullRE_M, function(i) try(wald_TMB_wrapper(i)))
pvals_fullRE_M <- p.adjust(pvals_fullRE_M)
pvals_diagRE_DM <- sapply(diagRE_DMSL, function(i) try(wald_TMB_wrapper(i)))
pvals_diagRE_DM <- p.adjust(pvals_diagRE_DM)
pvals_DM <- sapply(sparseRE_DMSL, function(i) try(wald_TMB_wrapper(i)))
pvals_DM <- p.adjust(pvals_DM)
pvals_DMnonexo <- sapply(sparseRE_DMSL_nonexo, function(i) try(wald_TMB_wrapper(i)))
pvals_DMnonexo <- p.adjust(pvals_DMnonexo)
```

```{r, all_pvals_analysis, echo=FALSE, results='hide', dependson=c('all_pvals')}
num_samples <- sapply(enough_samples, function(ct){
    .xx <- try(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures"),
                                       sigs_to_remove = unique(nonexogenous$V1)))
    try(nrow(.xx$Y)/2)
})

effect_size <- sapply(enough_samples, function(ct){
  .xx <- try(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures"),
                                     sigs_to_remove = unique(nonexogenous$V1)))
  try(sum((normalise_rw(.xx$Y[1:(nrow(.xx$Y)/2),]) - normalise_rw(.xx$Y[(1+nrow(.xx$Y)/2):(nrow(.xx$Y)),]))**2)/(nrow(.xx$Y)/2))
})
```

```{r, all_pvals_analysis_plots, echo=FALSE, dependson=c('all_pvals_analysis'), warning=FALSE, fig.height=4}

grid.arrange(ggplot(cbind.data.frame(pvals_DM=pvals_DM, pvals_DMnonexo=pvals_DMnonexo,
                        num_samples=as.numeric(num_samples),
                        ct=enough_samples),
       aes(x=log(pvals_DM), y=log(pvals_DMnonexo), col=num_samples,
           label=ct))+geom_point()+
  geom_hline(yintercept = log(0.05))+geom_vline(xintercept = log(0.05))+
  geom_label_repel()+theme(legend.position = "bottom"),
ggplot(cbind.data.frame(pvals_DM=pvals_DM, pvals_DMnonexo=pvals_DMnonexo,
                        num_samples=as.numeric(num_samples),
                        ct=enough_samples),
       aes(x=(pvals_DM), y=(pvals_DMnonexo), col=num_samples,
           label=ct))+geom_point()+
  geom_hline(yintercept = (0.05))+geom_vline(xintercept = (0.05))+
  geom_label_repel()+theme(legend.position = "bottom"), ncol=2)

ggplot(cbind.data.frame(effect_size=as.numeric(effect_size),
                        num_samples=as.numeric(num_samples),
                        minlogpval=-log(as.numeric(pvals_DM)),
                        label=enough_samples),
       aes(x=effect_size, y=minlogpval, shape=exp(-minlogpval)<0.05,
           label=label, col=num_samples))+
  geom_point()+geom_label_repel(alpha=0.2)+
  theme(legend.position = "bottom")
# 
# plot(pvals_fullRE_M, pvals_DM)
# 
```

```{r, all_pvals_analysis_plots_2, echo=FALSE, dependson=c('all_pvals_analysis'), warning=FALSE, fig.height=8}

ggplot(cbind.data.frame(pvals_DM=pvals_DM, pvals_DMnonexo=pvals_DMnonexo,
                        num_samples=as.numeric(num_samples),
                        ct=enough_samples,
                        pvals_DM_censored=sapply(-log(pvals_DM),
                                                 function(i) min(i, 25)),
                        pvals_DMnonexo_censored=sapply(-log(pvals_DMnonexo), 
                                                       function(i) min(i, 25))),
       aes(x=pvals_DM_censored, y=pvals_DMnonexo_censored,
           size=num_samples, col=ct,
           label=ct))+geom_point()+
  geom_hline(yintercept = -log(0.05))+geom_vline(xintercept = -log(0.05))+
  geom_label_repel(size=3.2, alpha=0.6)+  theme_bw()+
  theme(legend.position = "bottom", legend.text=element_text(size=8))+
  labs(x='- Log p-value all signatures', y='- Log p-value nonexogenous signatures')+
  guides(size=FALSE, col=guide_legend(ncol=4))

```

\subsection{All betas with SBS1 as baseline}
```{r, SBS1_betas, echo=FALSE, warning=FALSE, message=FALSE, results='hide', fig.height=6}
fullRE_DMSL_SBS1_betas <- lapply(fullRE_DMSL_SBS1, function(i){
  .x <- try(give_betas(i)[2,])
  if((typeof(.x) == 'character')){
    .x <- NA
  }else{
    .sum_i = summary(i)
    .x <- t(python_like_select_rownames(.sum_i, 'beta')[c(F,T),])
  }
  .x
})
for(i in 1:length(fullRE_DMSL_SBS1)){
  if(!(typeof(fullRE_DMSL_SBS1[[i]]) == 'character')){
    .nmes <- colnames(sort_columns_TMB_SBS1(load_PCAWG(ct = enough_samples[i], typedata = "signatures", path_to_data = "../../data/"))$Y)
    colnames(fullRE_DMSL_SBS1_betas[[i]]) = paste0(.nmes[-length(.nmes)], '/', .nmes[length(.nmes)])
      
  }
}

fullRE_DMSL_SBS1_betas_all <- lapply(1:length(fullRE_DMSL_SBS1_betas), function(i) try(data.frame(ct=names(fullRE_DMSL_SBS1_betas[i]), beta=t(fullRE_DMSL_SBS1_betas[[i]]),
                                                                                                               logR=colnames(fullRE_DMSL_SBS1_betas[[i]]))))
fullRE_DMSL_SBS1_betas_all <- do.call('rbind', fullRE_DMSL_SBS1_betas_all[sapply(fullRE_DMSL_SBS1_betas_all, typeof) == 'list'])

# fullRE_DMSL_SBS1_betas_all[!grepl("/SBS1$", fullRE_DMSL_SBS1_betas_all$logR),]
## select only those with SBS1 as baseline
fullRE_DMSL_SBS1_betas_all <- fullRE_DMSL_SBS1_betas_all[grepl("/SBS1$", fullRE_DMSL_SBS1_betas_all$logR),]

fullRE_DMSL_SBS1_betas_all$phHess <- sapply(fullRE_DMSL_SBS1, function(i) try(i$pdHess))[match(fullRE_DMSL_SBS1_betas_all$ct, names(fullRE_DMSL_SBS1))]

```

```{r, SBS1_betas_plots, echo=FALSE, warning=FALSE, message=FALSE, fig.height=10, fig.width=9}

ggplot(fullRE_DMSL_SBS1_betas_all, aes(x=ct, col=logR, y=beta.Estimate))+geom_point()+
  facet_wrap(.~logR, scales = "free_x", nrow=10)+
  geom_errorbar(aes(ymin=`beta.Estimate`-`beta.Std..Error`, ymax=`beta.Estimate`+`beta.Std..Error`), width=.1)+
  geom_hline(yintercept = 0, col='blue', lty='dashed')+
  theme(axis.text.x = element_text(angle = 45, vjust = 1.0, hjust=1), legend.position = "bottom")
```

```{r, SBS1_betas_plotsb, echo=FALSE, warning=FALSE, message=FALSE, fig.height=9, fig.width=9}

sort_with_letters <- function(i){
  .order <- order(as.numeric(gsub("[a-z]", "", i)))
  i[.order]
}

multiple_obs_SBS1_betas <- fullRE_DMSL_SBS1_betas_all %>% dplyr::select(logR) %>% table > 3
ggplot(fullRE_DMSL_SBS1_betas_all %>% filter(logR %in% names(multiple_obs_SBS1_betas[multiple_obs_SBS1_betas])),
       aes(x=ct,
           col=ct, y=beta.Estimate))+geom_point()+
  facet_wrap(.~factor(logR, levels=paste0('SBS', sort_with_letters(unique(gsub('SBS', '', gsub('/.*', '', logR)))), '/SBS1')), scales = "free_x", nrow=4)+
  geom_errorbar(aes(ymin=`beta.Estimate`-`beta.Std..Error`, ymax=`beta.Estimate`+`beta.Std..Error`), width=.1)+
  geom_hline(yintercept = 0, col='blue', lty='dashed')+
  theme_bw()+
  theme(#axis.text.x = element_text(angle = 45, vjust = 1.0, hjust=1),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(), legend.position = "bottom",
        text = element_text(size=20), legend.text=element_text(size=8))
  
ggplot(fullRE_DMSL_SBS1_betas_all %>% filter(logR %in% names(multiple_obs_SBS1_betas[multiple_obs_SBS1_betas])),
       aes(x=ct,
           col=ct, y=beta.Estimate))+geom_point()+
  facet_wrap(.~logR, scales = "free_x", nrow=4)+
  geom_errorbar(aes(ymin=`beta.Estimate`-`beta.Std..Error`, ymax=`beta.Estimate`+`beta.Std..Error`), width=.1)+
  geom_hline(yintercept = 0, col='blue', lty='dashed')+
  theme_bw()+
  theme(#axis.text.x = element_text(angle = 45, vjust = 1.0, hjust=1),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(), legend.position = "bottom",
        text = element_text(size=20), legend.text=element_text(size=8))
  
# ggsave("../../../results/results_TMB/pcawg/all_betas_all_ct.pdf", width = 25, height = 15)
```

```{r, SBS1_betas_plots2, echo=FALSE, warning=FALSE, message=FALSE, fig.height=10, fig.width=8}

fullRE_DMSL_SBS1_betas_all$exogenous = (gsub("/.*", "", fullRE_DMSL_SBS1_betas_all$logR) %in% nonexogenous$V1)
ggplot(fullRE_DMSL_SBS1_betas_all, aes(x=logR, y=beta.Estimate, col=exogenous))+geom_point()+
  facet_wrap(.~ct, scales = "free_x", nrow=5)+
  geom_errorbar(aes(ymin=`beta.Estimate`-`beta.Std..Error`, ymax=`beta.Estimate`+`beta.Std..Error`), width=.1)+
  geom_hline(yintercept = 0, col='blue', lty='dashed')+
  theme(axis.text.x = element_text(angle = 45, vjust = 1.0, hjust=1))
# ggsave("../../../results/results_TMB/pcawg/all_betas_all_ct_byct.pdf", width = 12, height = 12)
```
\newpage


How many signatures so we have in total and how many nonexogenous ones?
```{r, num_cats_sigs, echo=FALSE, warning=FALSE, message=FALSE}
signature_roo0 <- sapply(fles_roo[grepl('_signatures_', fles_roo)], readRDS)
signature_roo_active <- sapply(signature_roo0, function(i) try(slot(i, 'count_matrices_active')))
names(signature_roo_active) <- gsub("_signatures_ROO.RDS", "", basename(fles_roo[grepl('_signatures_', fles_roo)]))

num_cats_nonexo <- lapply(names(signature_roo_active), function(j){
  .nonexoncol <- try(ncol(signature_roo_active[[j]][[1]][,!(colnames(signature_roo_active[[j]][[1]]) %in% nonexogenous$V1)]))
  try(c(ifelse(is.null(ncol(signature_roo_active[[j]][[1]])), yes = NA, no = ncol(signature_roo_active[[j]][[1]])),
        ifelse(is.null(.nonexoncol), NA, .nonexoncol)))})
names(num_cats_nonexo) <- names(signature_roo_active)
num_cats_nonexo <- num_cats_nonexo[ (typeof(num_cats_nonexo) != "character") & sapply(num_cats_nonexo, function(i) typeof(i[[1]]) != "character")]
ggplot(cbind.data.frame(ct=names(num_cats_nonexo),
                      do.call('rbind', num_cats_nonexo)), aes(x=`1`, y=`2`, label=ct))+
  geom_abline(slope = 1, intercept = 0, lty='dashed')+
  geom_point()+
  geom_label_repel(size=3)+labs(x='Number of active signatures', y='Number of nonexogenous active signatures')+theme_bw()
```


\section{Analysis per cancer type}

\subsection{Bone osteosarcoma}

\subsubsection{Barplot and general statistics}
```{r BoneOsteosarc1, echo=FALSE}
ct <- "Bone-Osteosarc"
obj_Bone_Osteosarc <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Bone_Osteosarc, legend_on = TRUE)
```

The number of samples and signatures is:
```{r BoneOsteosarc1b, echo=FALSE}
dim(obj_Bone_Osteosarc$Y)
```

The signatures are:
```{r BoneOsteosarc1c, echo=FALSE}
colnames(obj_Bone_Osteosarc$Y)
```

\subsubsection{Convergence table}

We only have converged results for the multinomial with full RE, and the DM with a single lambda (diag and full RE). It is the same for nonexogenous signatures.

```{r BoneOsteosarc2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Bone-Osteosarc"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}

```{r BoneOsteosarc3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
ct <- "Bone-Osteosarc"

obj <- sort_columns_TMB(load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/"))
sortedM <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj)
sortedM

## use params from ME M for ME DM
dmin1 <- ncol(obj$Y)-1

sortedDM <- wrapper_run_TMB(model = "fullRE_DM",
                           object = obj,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM$par.fixed, 'cov_par_RE'),
                             log_lambda = matrix(c(2,2))))
sortedDM

```

If we use the values of the fullRE M as initial values for the fullRE DM, we also don't get convergence:
```{r BoneOsteosarc3b, echo=FALSE, message=FALSE, dependson=c('BoneOsteosarc3')}
sortedDM$pdHess
```

\subsubsection{Potentially problematic signatures}

We notice that we have several signatures with low exposures, and many zero exposures
```{r, BoneOsteosarc1d}
colSums(obj_Bone_Osteosarc$Y == 0)/nrow(obj_Bone_Osteosarc$Y)
colSums(obj_Bone_Osteosarc$Y)/sum(obj_Bone_Osteosarc$Y)
```

E.g.

\begin{itemize}
\item SBS17b is 0 in `r round( (colSums(obj_Bone_Osteosarc$Y == 0)/nrow(obj_Bone_Osteosarc$Y))['SBS17b'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Bone_Osteosarc$Y)/sum(obj_Bone_Osteosarc$Y))['SBS17b'], digits=3)*100`\%
\item SBS30 is 0 in `r round( (colSums(obj_Bone_Osteosarc$Y == 0)/nrow(obj_Bone_Osteosarc$Y))['SBS30'], digits=3)*100`\% of cases and overal has an exposure of only `r round((colSums(obj_Bone_Osteosarc$Y)/sum(obj_Bone_Osteosarc$Y))['SBS30'], digits=3)*100`\%
\item SBS5 is 0 in `r round( (colSums(obj_Bone_Osteosarc$Y == 0)/nrow(obj_Bone_Osteosarc$Y))['SBS5'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Bone_Osteosarc$Y)/sum(obj_Bone_Osteosarc$Y))['SBS5'], digits=3)*100`\%
\end{itemize}

\subsubsection{Betas}

```{r, BoneOsteosarc_betas}
ct <- "Bone-Osteosarc"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```


```{r, BoneOsteosarc_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Bone-Osteosarc"
pval_bone_osteosarc <- wald_TMB_wrapper(diagRE_DMSL_nonexo[[ct]])
```
We use the results from the diagonal single lambda DM to test for differential abundance, giving a p-value of `r pval_bone_osteosarc`.

\subsubsection{Covariance matrices}

```{r}
ct <- "Bone-Osteosarc"
additional_sortedM <- list()
additional_sortedDM <- list()
additional_sortedM[[ct]] <- sortedM
additional_sortedDM[[ct]] <- sortedDM
```

Note that sortedDM did not convergence.

Nevertheless, both versions of fullRE M -- both of which converged and use the same baseline -- give very different covariances matrices.

```{r, BoneOsteosarc_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7}
ct <- "Bone-Osteosarc"
# models_it_bone_osteosarc <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_bone_osteosarc <- c('fullRE_M', 'fullRE_M_nonexo', 'additional_sortedM', 'additional_sortedDM')
covmats_bone_osteosarc <- lapply(models_it_bone_osteosarc,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_bone_osteosarc) <- models_it_bone_osteosarc
## because it's fullRE_M, it's sorted
colnames(covmats_bone_osteosarc[['fullRE_M']]) <- rownames(covmats_bone_osteosarc[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Bone_Osteosarc)$Y))
colnames(covmats_bone_osteosarc[['additional_sortedM']]) <- rownames(covmats_bone_osteosarc[['additional_sortedM']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Bone_Osteosarc)$Y))
colnames(covmats_bone_osteosarc[['additional_sortedDM']]) <- rownames(covmats_bone_osteosarc[['additional_sortedDM']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Bone_Osteosarc)$Y))
## because it's fullRE_M_nonexo, it's sorted
colnames(covmats_bone_osteosarc[['fullRE_M_nonexo']]) <- rownames(covmats_bone_osteosarc[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Bone_Osteosarc, nonexogenous$V1)$Y))

for(i in 1:length(covmats_bone_osteosarc)){pheatmap(covmats_bone_osteosarc[[i]], cluster_rows = F, cluster_cols = F, main = models_it_bone_osteosarc[i])}
```

\subsubsection{Simulation under inferred data}
Have not been able to simulate
```{r, BoneOsteosarc_sim, echo=FALSE}
# sim_Bone_Osteosarc <- give_sim_from_estimates("Bone-Osteosarc", "signatures",
#                                               sigs_to_remove=unique(nonexogenous$V1),
#                                               bool_give_PCA = T, path_to_data= "../../data/",
#                                               model="sparseRE_DMSL", bool_nonexo = F)
# )
# sim_Bone_Osteosarc[[2]]+ggtitle('Simulation of Bone osteosarcoma samples')
```

\subsubsection{Ranked plot for coverage}

```{r, BoneOsteosarc_ranked_plot}
ct <- "Bone-Osteosarc"
integer_overdispersion_param_DMSL <- 1
obj_Bone_Osteosarc_nonexo <- give_subset_sigs_TMBobj(obj_Bone_Osteosarc, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Bone_Osteosarc_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Bone_Osteosarc_nonexo,
                 loglog = F, title = 'obj_Bone_Osteosarc (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_Bone_Osteosarc_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Bone_Osteosarc_nonexo,
                 loglog = F, title = 'obj_Bone_Osteosarc (DMSL)'), ncol=2)
```

73/359=20\% of values are not included in the confidence interval of the DMSL.

\subsubsection{Correlations of signatures}
To add: the observed values, and the correlations of the normalised signatures
```{r, BoneOsteosarc_correlations, echo=FALSE, fig.height=3.5}

grid.arrange(ggplot(melt(give_all_correlations(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[["Bone-Osteosarc"]],
                 data_object = obj_Bone_Osteosarc_nonexo,
                 print_plot = F, nreps = 2, model = "M")[[1]])), aes(x=value))+geom_density()+
  ggtitle('Correlations of fitted values\n(fullRE M)'),
ggplot(melt(give_all_correlations(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[["Bone-Osteosarc"]],
                 data_object = obj_Bone_Osteosarc_nonexo,
                 print_plot = F, nreps = 2, model = "DMSL", integer_overdispersion_param=1)[[1]])), aes(x=value))+geom_density()+
  ggtitle('Correlations of fitted values\n(diag DMSL)'), ncol=2)

```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are a bit more chaotic:
```{r, BoneOsteosarc_mutsigextractor}
obj_Bone_Osteosarc_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Bone_Osteosarc_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations
```{r, BoneOsteosarc_sortedbynummuts}
createBarplot(normalise_rw(non_duplicated_rows(obj_Bone_Osteosarc$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Bone_Osteosarc$Y)),
                                        decreasing = F)))
```


\subsection{Breast-AdenoCA}
\subsubsection{Barplot and general statistics}
```{r BreastAdenoCA1, echo=FALSE}
ct <- "Breast-AdenoCA"
obj_Breast_AdenoCA <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Breast_AdenoCA, legend_on = TRUE)
```

There are many signatures, and also many samples.


The number of samples and signatures is:
```{r BreastAdenoCA1b, echo=FALSE}
dim(obj_Breast_AdenoCA$Y)
```

The signatures are:
```{r BreastAdenoCA1c, echo=FALSE}
colnames(obj_Breast_AdenoCA$Y)
```

\subsubsection{Convergence table}

We only have converged results for the diagRE_DMSL, with diagonal or sparse covariance structure, and diagonal M.
 This is probably due to the very high number of signatures, which make it impossible to infer the whole covariance structure.

```{r BreastAdenoCA2, echo=FALSE, dependson=c('summary_convergence')}
melt(all_summaries) %>% filter(value=="Breast-AdenoCA")
```

\subsubsection{Re-running of fitting}

```{r obj_Breast_AdenoCA3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
ct <- "Breast-AdenoCA"

obj_Breast_Adeno_sorted <- sort_columns_TMB(load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/"))
sortedM_Breast_Adeno <- wrapper_run_TMB(model = "diagRE_M",
                           object = obj_Breast_Adeno_sorted)
sortedM_Breast_Adeno

## use params from diagME M for diagME DM
sortedDM_Breast_Adeno <- wrapper_run_TMB(model = "diagRE_DM",
                           object = obj_Breast_Adeno_sorted,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_Breast_Adeno$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_Breast_Adeno$par.random, ncol=ncol(obj_Breast_Adeno_sorted$Y)-1),
                             logs_sd_RE=python_like_select_name(sortedM_Breast_Adeno$par.fixed, 'logs_sd_RE'),
                             log_lambda = matrix(c(2,2))))
sortedDM_Breast_Adeno
```

If we use the values of the diagRE M as initial values for the diagRE DM, we that it has converged. This is probably due to a combination of things: we are using the optimiser nlminb (better in general than the alternative, optim) and we are starting with these - better - values, and we are sorting the columns so that the category with highest total value is the baseline.
```{r obj_Breast_AdenoCA3b, echo=FALSE, message=FALSE, dependson=c('BoneOsteosarc3')}
sortedDM_Breast_Adeno$pdHess
```


```{r}
ct <- "Breast-AdenoCA"
additional_sorteddiagM <- list()
additional_sorteddiagDM <- list()
additional_sorteddiagM[[ct]] <- sortedM_Breast_Adeno
additional_sorteddiagDM[[ct]] <- sortedDM_Breast_Adeno
```

\subsubsection{Potentially problematic signatures}

We notice that we have several signatures with low exposures, and many zero exposures
```{r, obj_Breast_AdenoCA3d}
colSums(obj_Breast_AdenoCA$Y == 0)/nrow(obj_Breast_AdenoCA$Y)
colSums(obj_Breast_AdenoCA$Y)/sum(obj_Breast_AdenoCA$Y)
```

E.g.

\begin{itemize}
\item SBS9 is 0 in `r round( (colSums(obj_Breast_AdenoCA$Y == 0)/nrow(obj_Breast_AdenoCA$Y))['SBS9'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Breast_AdenoCA$Y)/sum(obj_Breast_AdenoCA$Y))['SBS9'], digits=3)*100`\%
\item SBS12 is 0 in `r round( (colSums(obj_Breast_AdenoCA$Y == 0)/nrow(obj_Breast_AdenoCA$Y))['SBS12'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Breast_AdenoCA$Y)/sum(obj_Breast_AdenoCA$Y))['SBS12'], digits=3)*100`\%
\item SBS17a is 0 in `r round( (colSums(obj_Breast_AdenoCA$Y == 0)/nrow(obj_Breast_AdenoCA$Y))['SBS17a'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Breast_AdenoCA$Y)/sum(obj_Breast_AdenoCA$Y))['SBS17a'], digits=3)*100`\%
\item SBS17b is 0 in `r round( (colSums(obj_Breast_AdenoCA$Y == 0)/nrow(obj_Breast_AdenoCA$Y))['SBS17b'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Breast_AdenoCA$Y)/sum(obj_Breast_AdenoCA$Y))['SBS17b'], digits=3)*100`\%
\item SBS37 is 0 in `r round( (colSums(obj_Breast_AdenoCA$Y == 0)/nrow(obj_Breast_AdenoCA$Y))['SBS37'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Breast_AdenoCA$Y)/sum(obj_Breast_AdenoCA$Y))['SBS37'], digits=3)*100`\%
\item SBS39 is 0 in `r round( (colSums(obj_Breast_AdenoCA$Y == 0)/nrow(obj_Breast_AdenoCA$Y))['SBS39'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Breast_AdenoCA$Y)/sum(obj_Breast_AdenoCA$Y))['SBS39'], digits=3)*100`\%
\end{itemize}

\subsubsection{Betas}

```{r, Breast_AdenoCA_betas, echo=FALSE, fig.height=10}
ct <- "Breast-AdenoCA"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')),
plot_betas(additional_sorteddiagM[[ct]])+ggtitle(paste0(ct, '\n additional_sorteddiagM')),
plot_betas(additional_sorteddiagDM[[ct]])+ggtitle(paste0(ct, '\n additional_sorteddiagDM')),
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
  plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
  plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=5)

```

```{r, Breast_AdenoCA_betasb, echo=FALSE, fig.height=4}
ct <- "Breast-AdenoCA"
betas_breast_AdenoCA_sparseRE_DMSL_nonexo <- python_like_select_rownames(summary(sparseRE_DMSL_nonexo[[ct]]), 'beta')
rownames(betas_breast_AdenoCA_sparseRE_DMSL_nonexo) <- rep(vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Breast_AdenoCA, sigs_to_remove = nonexogenous$V1)$Y)), each=2)
ggplot(cbind(melt(betas_breast_AdenoCA_sparseRE_DMSL_nonexo),
             group=c('Intercept', 'Slope')) %>% filter(Var2=='Estimate', group=='Slope'), aes(x=Var1, y=value))+
  geom_hline(yintercept = 0, lty='dashed', col='blue')+geom_point()+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
```

```{r, Breast_AdenoCA_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Breast-AdenoCA"
diagRE_DMSL_nonexo[[ct]]$phHess
pval_Breast_AdenoCA <- wald_TMB_wrapper(diagRE_DMSL_nonexo[[ct]])
```
We use the results from the diagonal single lambda DM to test for differential abundance, giving a p-value of `r pval_Breast_AdenoCA`.



\subsubsection{Covariance matrices}

```{r, Breast_AdenoCA_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7}
ct <- "Breast-AdenoCA"
models_it_Breast_AdenoCA <- c('fullRE_M', 'fullRE_M_nonexo')
covmats_Breast_AdenoCA <- lapply(models_it_Breast_AdenoCA,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Breast_AdenoCA) <- models_it_Breast_AdenoCA
## because it's fullRE_M, it's sorted
colnames(covmats_Breast_AdenoCA[['fullRE_M']]) <- rownames(covmats_Breast_AdenoCA[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Breast_AdenoCA)$Y))
## because it's fullRE_M_nonexo, it's sorted
colnames(covmats_Breast_AdenoCA[['fullRE_M_nonexo']]) <- rownames(covmats_Breast_AdenoCA[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Breast_AdenoCA, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Breast_AdenoCA)){pheatmap(covmats_Breast_AdenoCA[[i]], cluster_rows = F, cluster_cols = F, main = models_it_bone_osteosarc[i])}
```

\subsubsection{Simulation under inferred data}

```{r, Breast_AdenoCA_sim, echo=FALSE}
sim_Breast_AdenoCA <- give_sim_from_estimates("Breast-AdenoCA", "signatures", sigs_to_remove=unique(nonexogenous$V1),
                                              bool_give_PCA = T, path_to_data= "../../data/")
sim_Breast_AdenoCA[[2]]+ggtitle('Simulation of Breast Adenocarcinoma samples')
```

\subsubsection{Ranked plot for coverage}

```{r, Breast_AdenoCA_ranked_plot}
ct <- "Breast-AdenoCA"
integer_overdispersion_param_DMSL <- 1
obj_Breast_AdenoCA_nonexo <- give_subset_sigs_TMBobj(obj_Breast_AdenoCA, sigs_to_remove = nonexogenous$V1)

for(loglog_it in c(T,F)){
  grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Breast_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Breast_AdenoCA_nonexo,
                 loglog = loglog_it, title = 'Breast_AdenoCA_nonexo (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_Breast_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Breast_AdenoCA_nonexo,
                 loglog = loglog_it, title = 'Breast_AdenoCA_nonexo (DMSL)'), ncol=2)
}
```


\subsubsection{Signatures from mutSigExtractor}

```{r, Breast_AdenoCA_mutsigextractor}
obj_Breast_AdenoCA_mutSigExtractor <- load_PCAWG(ct = "Breast-AdenoCA",
                                                 typedata = "signaturesmutSigExtractor",
                                                 path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Breast_AdenoCA_mutSigExtractor, legend_on = FALSE)
```





\subsection{Cervix-SCC}

\subsubsection{Barplot and general statistics}
```{r Cervix_SCC1, echo=FALSE}
ct <- "Cervix-SCC"
obj_Cervix_SCC <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Cervix_SCC, legend_on = TRUE)
```

The number of samples and signatures is:
```{r Cervix_SCC1b, echo=FALSE}
dim(obj_Cervix_SCC$Y)
```

The signatures are:
```{r Cervix_SCC1c, echo=FALSE}
colnames(obj_Cervix_SCC$Y)
```

\subsubsection{Convergence table}


```{r Cervix_SCC2, echo=FALSE, dependson=c('summary_convergence')}
melt(all_summaries) %>% filter(value=="Cervix-SCC")
```


\subsubsection{Potentially problematic signatures}

SBS33 is a potentially problematic signature, being 0 in `r round( (colSums(obj_Cervix_SCC$Y == 0)/nrow(obj_Cervix_SCC$Y))['SBS33'], digits=3)*100`\% of cases and with an overall exposure of `r round((colSums(obj_Cervix_SCC$Y)/sum(obj_Cervix_SCC$Y))['SBS33'], digits=3)*100`\%.

```{r, Cervix_SCC1d}
colSums(obj_Cervix_SCC$Y == 0)/nrow(obj_Cervix_SCC$Y)
colSums(obj_Cervix_SCC$Y)/sum(obj_Cervix_SCC$Y)
```

\subsubsection{Betas}

```{r, Cervix_SCC_betas}
ct <- "Cervix-SCC"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
             plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
             plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
             plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
  plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
  plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```

```{r, Cervix_SCC_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Cervix-SCC"
pval_Cervix_SCC <- wald_TMB_wrapper(fullRE_DMSL_nonexo[[ct]])
```
We use the results from the fullRE single lambda DM to test for differential abundance, giving a p-value of `r pval_bone_osteosarc`.

\subsubsection{Covariance matrices}

```{r}
# ct <- "Bone-Osteosarc"
# additional_sortedM <- list()
# additional_sortedDM <- list()
# additional_sortedM[[ct]] <- sortedM
# additional_sortedDM[[ct]] <- sortedDM
```


```{r, Cervix_SCC_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7}
ct <- "Cervix-SCC"

models_it_bone_Cervix_SCC <- c('fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_bone_Cervix_SCC <- lapply(models_it_bone_Cervix_SCC,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_bone_Cervix_SCC) <- models_it_bone_Cervix_SCC
## because it's fullRE_M_nonexo, it's not sorted
colnames(covmats_bone_Cervix_SCC[['fullRE_M_nonexo']]) <- rownames(covmats_bone_Cervix_SCC[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Cervix_SCC, nonexogenous$V1)$Y))
## because it's fullRE_DMSL_nonexo, it's sorted
colnames(covmats_bone_Cervix_SCC[['fullRE_DMSL_nonexo']]) <- rownames(covmats_bone_Cervix_SCC[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Cervix_SCC, nonexogenous$V1)$Y))

for(i in 1:length(covmats_bone_Cervix_SCC)){pheatmap(covmats_bone_Cervix_SCC[[i]], cluster_rows = F, cluster_cols = F, main = models_it_bone_Cervix_SCC[i])}
```

\subsubsection{Simulation under inferred data}

```{r}
unique(nonexogenous$V1)
```

```{r, Cervix_SCC_sim, echo=FALSE}
sim_Cervix_SCC <- give_sim_from_estimates( "Cervix-SCC", "signatures", 
                                          sigs_to_remove=unique(nonexogenous$V1),
                                          bool_give_PCA = T, path_to_data= "../../data/",
                                          sig_of_interest = "SBS2")
sim_Cervix_SCC[[2]]+ggtitle('Simulation of Cervix SCC samples')
```

\subsubsection{Ranked plot for coverage}

```{r, Cervix_SCC_ranked_plot}
ct <- "Cervix-SCC"
integer_overdispersion_param_DMSL <- 1
obj_Cervix_SCC_nonexo <- give_subset_sigs_TMBobj(obj_Cervix_SCC, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Cervix_SCC_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Cervix_SCC_nonexo,
                 loglog = F, title = 'obj_Cervix_SCC_nonexo (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_Cervix_SCC_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Cervix_SCC_nonexo,
                 loglog = F, title = 'obj_Cervix_SCC_nonexo (DMSL)'), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

```{r, Cervix_SCC_mutsigextractor}
obj_Cervix_SCC_mutSigExtractor <- load_PCAWG(ct = "Cervix-SCC", typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Cervix_SCC_mutSigExtractor, legend_on = TRUE)
```

\subsection{CNS-GBM}
\subsubsection{Barplot and general statistics}
```{r CNSGBM1, echo=FALSE}
ct <- "CNS-GBM"
obj_CNS_GBM <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_GBM, legend_on = TRUE)
```



The number of samples and signatures is:
```{r CNSGBM1b, echo=FALSE}
dim(obj_CNS_GBM$Y)
```

The signatures are:
```{r CNSGBM1c, echo=FALSE}
colnames(obj_CNS_GBM$Y)
```


\subsubsection{Convergence table}

We only have converged results for the multinomial with full RE, and the DM with a single lambda (diag and sparse RE). It is the same for nonexogenous signatures.

```{r CNSGBM2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "CNS-GBM"
melt(all_summaries) %>% filter(value==ct)
```


\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo
```{r CNSGBM3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "CNS-GBM"

obj_CNSGBM <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_CNSGBM <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_CNSGBM)
sortedM_CNSGBM
```

```{r CNSGBM3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_CNSGBM$Y)-1

sortedDM_CNSGBM <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_CNSGBM,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_CNSGBM$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_CNSGBM$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_CNSGBM$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_CNSGBM$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_CNSGBM

```


If we use the values of the fullRE M exo as initial values for the fullRE DMSL exo do converge:
```{r CNSGBM3b, echo=FALSE, message=FALSE, dependson=c('CNSGBM3')}
sortedDM_CNSGBM$pdHess
```


\subsubsection{Potentially problematic signatures}

We notice that there are no truly problematic signatures (SBS15 has the most zeros; 50\%).
```{r, CNSGBM1d}
colSums(obj_CNS_GBM$Y == 0)/nrow(obj_CNS_GBM$Y)
colSums(obj_CNS_GBM$Y)/sum(obj_CNS_GBM$Y)
```

```{r, additional_runs}
additional_sortedMnonexo <- list()
additional_sortedDMSLnonexo <- list()
```

```{r, CNS_GBM_additional_runs, dependson=c('additional_runs')}
additional_sortedMnonexo[["CNS-GBM"]] <- sortedM_CNSGBM
additional_sortedDMSLnonexo[["CNS-GBM"]] <- sortedDM_CNSGBM
```

\subsubsection{Betas}

```{r, CNSGBM_betas}
ct <- "CNS-GBM"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(sortedDM_CNSGBM)+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```



```{r, CNSGBM_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "CNS-GBM"
pval_CNS_GBM <- wald_TMB_wrapper(sortedDM_CNSGBM)
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_CNS_GBM`.

\subsubsection{Covariance matrices}



```{r, CNSGBM_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('CNS_GBM_additional_runs')}
ct <- "CNS-GBM"
# models_it_CNS_GBM <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_CNS_GBM <- c('fullRE_M', 'fullRE_M_nonexo', 'additional_sortedDMSLnonexo')
covmats_CNS_GBM <- lapply(models_it_CNS_GBM,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_CNS_GBM) <- models_it_CNS_GBM
## because it's fullRE_M, it's sorted
colnames(covmats_CNS_GBM[['fullRE_M']]) <- rownames(covmats_CNS_GBM[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_CNS_GBM)$Y))
colnames(covmats_CNS_GBM[['fullRE_M_nonexo']]) <- rownames(covmats_CNS_GBM[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_CNS_GBM, nonexogenous$V1)$Y))
colnames(covmats_CNS_GBM[['additional_sortedDMSLnonexo']]) <- rownames(covmats_CNS_GBM[['additional_sortedDMSLnonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_CNS_GBM, nonexogenous$V1)$Y))

for(i in 1:length(covmats_CNS_GBM)){pheatmap(covmats_CNS_GBM[[i]], cluster_rows = F, cluster_cols = F, main = models_it_CNS_GBM[i])}
```



\subsubsection{Simulation under inferred data}
```{r, CNSGBM_sim, echo=FALSE}
sim_CNS_GBM <- give_sim_from_estimates("CNS-GBM", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = F,
                                       tmb_object=sortedDM_CNSGBM)
sim_CNS_GBM[[2]]+ggtitle('Simulation of CNS-GBM samples')

```


\subsubsection{Ranked plot for coverage}

```{r, CNSGBM_ranked_plot}
ct <- "CNS-GBM"
integer_overdispersion_param_DMSL <- 1
obj_CNS_GBM_nonexo <- give_subset_sigs_TMBobj(obj_CNS_GBM, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_CNS_GBM_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNS_GBM_nonexo,
                 loglog = F, title = 'obj_CNS_GBM (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = sortedDM_CNSGBM,
                 data_object = obj_CNS_GBM_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNS_GBM_nonexo,
           loglog = F, title = 'obj_CNS_GBM (DMSL)'), ncol=2)
```

Surprisingly, the values for DMSL look even worse than the multinomial, for high values

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are a bit more chaotic:
```{r, CNSGBM_mutsigextractor}
obj_CNS_GBM_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_GBM_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.
```{r, CNSGBM_sortedbynummuts}
createBarplot(normalise_rw(non_duplicated_rows(obj_CNS_GBM$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_CNS_GBM$Y)),
                                        decreasing = F)))
```

<!-- -------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------- -->

\subsection{CNS-Medullo}
\subsubsection{Barplot and general statistics}
```{r CNSMedullo1, echo=FALSE}
ct <- "CNS-Medullo"
obj_CNS_Medullo <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_Medullo, legend_on = TRUE)
```


The number of samples and signatures is:
```{r CNSMedullo1b, echo=FALSE}
dim(obj_CNS_Medullo$Y)
```

The signatures are:
```{r CNSMedullo1c, echo=FALSE}
colnames(obj_CNS_Medullo$Y)
```



\subsubsection{Convergence table}

Pretty much everything has converged in this case
```{r CNSMedullo2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "CNS-Medullo"
melt(all_summaries) %>% filter(value==ct)
```

As nonexo DMSL has already converged, we don't re-run anything.

\subsubsection{Potentially problematic signatures}

We notice that there are no truly problematic signatures 
```{r, CNSMedullo1d}
colSums(obj_CNS_Medullo$Y == 0)/nrow(obj_CNS_Medullo$Y)
colSums(obj_CNS_Medullo$Y)/sum(obj_CNS_Medullo$Y)
```


\subsubsection{Betas}

```{r, CNSMedullo_betas}
ct <- "CNS-Medullo"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```



```{r, CNSMedullo_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "CNS-Medullo"
pval_CNS_Medullo <- wald_TMB_wrapper(fullRE_DMSL_nonexo[[ct]])
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_CNS_Medullo`.


\subsubsection{Covariance matrices}

```{r, CNSMedullo_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('CNS_Medullo_additional_runs')}
ct <- "CNS-Medullo"
# models_it_CNS_Medullo <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_CNS_Medullo <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_CNS_Medullo <- lapply(models_it_CNS_Medullo,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_CNS_Medullo) <- models_it_CNS_Medullo
## because it's fullRE_M, it's sorted
colnames(covmats_CNS_Medullo[['fullRE_M']]) <- rownames(covmats_CNS_Medullo[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_CNS_Medullo)$Y))
colnames(covmats_CNS_Medullo[['fullRE_M_nonexo']]) <- rownames(covmats_CNS_Medullo[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_CNS_Medullo, nonexogenous$V1)$Y))
colnames(covmats_CNS_Medullo[['fullRE_DMSL_nonexo']]) <- rownames(covmats_CNS_Medullo[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_CNS_Medullo, nonexogenous$V1)$Y))

for(i in 1:length(covmats_CNS_Medullo)){pheatmap(covmats_CNS_Medullo[[i]], cluster_rows = F, cluster_cols = F, main = models_it_CNS_Medullo[i])}
```


\subsubsection{Simulation under inferred data}
```{r, CNSMedullo_sim, echo=FALSE}
sim_CNS_Medullo <- give_sim_from_estimates("CNS-Medullo", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = F,
                                       tmb_object=fullRE_DMSL_nonexo[["CNS-Medullo"]])
sim_CNS_Medullo[[2]]+ggtitle('Simulation of CNS-Medullo samples')

```


\subsubsection{Ranked plot for coverage}

```{r, CNSMedullo_ranked_plot}
ct <- "CNS-Medullo"
integer_overdispersion_param_DMSL <- 1
obj_CNS_Medullo_nonexo <- give_subset_sigs_TMBobj(obj_CNS_Medullo, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_CNS_Medullo_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNS_Medullo_nonexo,
                 loglog = F, title = 'obj_CNS_Medullo (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[["CNS-Medullo"]],
                 data_object = obj_CNS_Medullo_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNS_Medullo_nonexo,
           loglog = F, title = 'obj_CNS_Medullo (DMSL)'), ncol=2)
```



\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are a bit more chaotic:
```{r, CNSMedullo_mutsigextractor}
obj_CNS_Medullo_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_Medullo_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.
```{r, CNSMedullo_sortedbynummuts}
createBarplot(normalise_rw(non_duplicated_rows(obj_CNS_Medullo$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_CNS_Medullo$Y)),
                                        decreasing = F)))
```


<!-- -------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------- -->

\subsection{CNS-Oligo}

\subsubsection{Barplot and general statistics}
```{r CNSOligo1, echo=FALSE}
ct <- "CNS-Oligo"
obj_CNS_Oligo <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_Oligo, legend_on = TRUE)
```


The number of samples and signatures is:
```{r CNSOligo1b, echo=FALSE}
dim(obj_CNS_Oligo$Y)
```

The signatures are:
```{r CNSOligo1c, echo=FALSE}
colnames(obj_CNS_Oligo$Y)
```


\subsubsection{Convergence table}

Pretty much everything has converged
```{r CNSOligo2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "CNS-Oligo"
melt(all_summaries) %>% filter(value==ct)
```


<!-- \subsubsection{Potentially problematic signatures} -->

<!-- We notice that there are no truly problematic signatures (SBS15 has the most zeros; 50\%). -->
<!-- ```{r, CNSOligo1d} -->
<!-- colSums(obj_CNS_Oligo$Y == 0)/nrow(obj_CNS_Oligo$Y) -->
<!-- colSums(obj_CNS_Oligo$Y)/sum(obj_CNS_Oligo$Y) -->
<!-- ``` -->



\subsubsection{Betas}

```{r, CNSOligo_betas}
ct <- "CNS-Oligo"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_M[[ct]])+ggtitle(paste0(ct, '\n fullRE_M')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
  plot_betas(fullRE_DMDL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMDL_nonexo')), nrow=2)
```



```{r, CNSOligo_DA, echo=FALSE, message=FALSE, results='hide'}
pval_CNS_Oligo <- wald_TMB_wrapper(fullRE_DMSL_nonexo[["CNS-Oligo"]])
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_CNS_Oligo`.

\subsubsection{Covariance matrices}



```{r, CNSOligo_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('CNS_Oligo_additional_runs')}
ct <- "CNS-Oligo"
models_it_CNS_Oligo <- c('fullRE_M', 'fullRE_DMSL', 'fullRE_DMSL_nonexo')
covmats_CNS_Oligo <- lapply(models_it_CNS_Oligo,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_CNS_Oligo) <- models_it_CNS_Oligo

## because it's fullRE_M, it's sorted
colnames(covmats_CNS_Oligo[['fullRE_M']]) <- rownames(covmats_CNS_Oligo[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_CNS_Oligo)$Y))
colnames(covmats_CNS_Oligo[['fullRE_DMSL']]) <- rownames(covmats_CNS_Oligo[['fullRE_DMSL']]) <- vector_cats_to_logR(colnames(obj_CNS_Oligo$Y))
colnames(covmats_CNS_Oligo[['fullRE_DMSL_nonexo']]) <- rownames(covmats_CNS_Oligo[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_CNS_Oligo, nonexogenous$V1)$Y))

for(i in 1:length(covmats_CNS_Oligo)){pheatmap(covmats_CNS_Oligo[[i]], cluster_rows = F, cluster_cols = F, main = models_it_CNS_Oligo[i])}
```





\subsubsection{Simulation under inferred data}
```{r, CNSOligo_sim, echo=FALSE}
sim_CNS_Oligo <- give_sim_from_estimates("CNS-Oligo", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = F,
                                       tmb_object=fullRE_DMSL_nonexo[["CNS-Oligo"]])
sim_CNS_Oligo[[2]]+ggtitle('Simulation of CNS-Oligo samples')

```



\subsubsection{Ranked plot for coverage}
The values for DMSL nonexo look considerably better than for M nonexo.
```{r, CNSOligo_ranked_plot}
ct <- "CNS-Oligo"
integer_overdispersion_param_DMSL <- 1
obj_CNS_Oligo_nonexo <- give_subset_sigs_TMBobj(obj_CNS_Oligo, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_CNS_Oligo_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNS_Oligo_nonexo,
                 loglog = F, title = 'obj_CNS_Oligo (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_CNS_Oligo_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNS_Oligo_nonexo,
           loglog = F, title = 'obj_CNS_Oligo (DMSL)'), ncol=2)
```


\subsubsection{Signatures from mutSigExtractor}

These are the signatures from mutSigExtractor:
```{r, CNSOligo_mutsigextractor}
obj_CNS_Oligo_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_Oligo_mutSigExtractor, legend_on = FALSE)
```


Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.
```{r, CNSOligo_sortedbynummuts, fig.height=3}
createBarplot(normalise_rw(non_duplicated_rows(obj_CNS_Oligo$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_CNS_Oligo$Y)),
                                        decreasing = F)))
```

<!-- -------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------- -->

\subsection{CNS-PiloAstro}

\subsection{CNS-PiloAstro}
\subsubsection{Barplot and general statistics}
```{r CNSPiloAstro1, echo=FALSE}
ct <- "CNS-PiloAstro"
obj_CNS_PiloAstro <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_PiloAstro, legend_on = TRUE)
```



The number of samples and signatures is:
```{r CNSPiloAstro1b, echo=FALSE}
dim(obj_CNS_PiloAstro$Y)
```

The signatures are:
```{r CNSPiloAstro1c, echo=FALSE}
colnames(obj_CNS_PiloAstro$Y)
```


\subsubsection{Convergence table}

We have converged results for everything except for full RE DM, in the case of all signatures (with only nonexo everything has).

```{r CNSPiloAstro2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "CNS-PiloAstro"
melt(all_summaries) %>% filter(value==ct)
```



\subsubsection{Re-running of fitting}
Using fullRE_M to fit fullRE_DMSL (all sigs, as the one with nonexo has already converged)
```{r CNSPiloAstro3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "CNS-PiloAstro"

obj_CNSPiloAstro <- sort_columns_TMB(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"))
sortedM_CNSPiloAstro <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_CNSPiloAstro)
sortedM_CNSPiloAstro
```


```{r CNSPiloAstro3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_CNSPiloAstro$Y)-1

sortedDM_CNSPiloAstro <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_CNSPiloAstro,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_CNSPiloAstro$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_CNSPiloAstro$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_CNSPiloAstro$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_CNSPiloAstro$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_CNSPiloAstro

```



If we use the values of the fullRE M as initial values for the fullRE DMSL still do not converge:
```{r CNSPiloAstro3b, echo=FALSE, message=FALSE, dependson=c('CNSPiloAstro3')}
sortedDM_CNSPiloAstro$pdHess
```




\subsubsection{Potentially problematic signatures}

We notice that there are no truly problematic signatures (SBS15 has the most zeros; 50\%).
```{r, CNSPiloAstro1d}
colSums(obj_CNS_PiloAstro$Y == 0)/nrow(obj_CNS_PiloAstro$Y)
colSums(obj_CNS_PiloAstro$Y)/sum(obj_CNS_PiloAstro$Y)
```

SBS19 and SBS23 are quite sparse.



```{r, CNS_PiloAstro_additional_runs, dependson=c('additional_runs')}
additional_sortedMnonexo[["CNS-PiloAstro"]] <- sortedM_CNSPiloAstro
additional_sortedDMSLnonexo[["CNS-PiloAstro"]] <- sortedDM_CNSPiloAstro
```

\subsubsection{Betas}

```{r, CNSPiloAstro_betas}
ct <- "CNS-PiloAstro"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
  plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
  plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```




```{r, CNSPiloAstro_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "CNS-PiloAstro"
pval_CNS_PiloAstro <- wald_TMB_wrapper(fullRE_DMSL_nonexo[[ct]])
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_CNS_PiloAstro`.


\subsubsection{Covariance matrices}



```{r, CNSPiloAstro_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('CNS_PiloAstro_additional_runs')}
ct <- "CNS-PiloAstro"
# models_it_CNS_PiloAstro <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_CNS_PiloAstro <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_CNS_PiloAstro <- lapply(models_it_CNS_PiloAstro,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_CNS_PiloAstro) <- models_it_CNS_PiloAstro
## because it's fullRE_M, it's sorted
colnames(covmats_CNS_PiloAstro[['fullRE_M']]) <- rownames(covmats_CNS_PiloAstro[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_CNS_PiloAstro)$Y))
colnames(covmats_CNS_PiloAstro[['fullRE_M_nonexo']]) <- rownames(covmats_CNS_PiloAstro[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_CNS_PiloAstro, nonexogenous$V1)$Y))
colnames(covmats_CNS_PiloAstro[['fullRE_DMSL_nonexo']]) <- rownames(covmats_CNS_PiloAstro[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_CNS_PiloAstro, nonexogenous$V1)$Y))

for(i in 1:length(covmats_CNS_PiloAstro)){pheatmap(covmats_CNS_PiloAstro[[i]], cluster_rows = F, cluster_cols = F, main = models_it_CNS_PiloAstro[i])}
```



\subsubsection{Simulation under inferred data}
```{r, CNSPiloAstro_sim, echo=FALSE}
sim_CNS_PiloAstro <- give_sim_from_estimates(ct = "CNS-PiloAstro", typedata = "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = F,
                                      tmb_object=fullRE_DMSL_nonexo[["CNS-PiloAstro"]])
sim_CNS_PiloAstro[[2]]+ggtitle('Simulation of CNS-PiloAstro samples')

```



\subsubsection{Ranked plot for coverage}

```{r, CNSPiloAstro_ranked_plot}
ct <- "CNS-PiloAstro"
integer_overdispersion_param_DMSL <- 1
obj_CNS_PiloAstro_nonexo <- give_subset_sigs_TMBobj(obj_CNS_PiloAstro, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_CNS_PiloAstro_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNS_PiloAstro_nonexo,
                 loglog = F, title = 'obj_CNS_PiloAstro (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_CNS_PiloAstro_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNS_PiloAstro_nonexo,
           loglog = F, title = 'obj_CNS_PiloAstro (DMSL)'), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are a bit more chaotic:
```{r, CNSPiloAstro_mutsigextractor}
obj_CNS_PiloAstro_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_PiloAstro_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations, with perhaps SBS9 being slightly found in the rightmost side preferentially.
```{r, CNSPiloAstro_sortedbynummuts}
createBarplot(normalise_rw(non_duplicated_rows(obj_CNS_PiloAstro$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_CNS_PiloAstro$Y)),
                                        decreasing = F)))
```


\subsection{ColoRect-AdenoCA}

\subsection{ColoRect-AdenoCA}
\subsubsection{Barplot and general statistics}
```{r ColoRectAdenoCA1, echo=FALSE}
ct <- "ColoRect-AdenoCA"
obj_ColoRect_AdenoCA <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_ColoRect_AdenoCA, legend_on = TRUE)
```



The number of samples and signatures is:
```{r ColoRectAdenoCA1b, echo=FALSE}
dim(obj_ColoRect_AdenoCA$Y)
```

The signatures are:
```{r ColoRectAdenoCA1c, echo=FALSE}
colnames(obj_ColoRect_AdenoCA$Y)
```



\subsubsection{Convergence table}

We only have converged results for the multinomial with diag RE, when including all mutations. For exogenous mutations, full DMSL is has not converged.

```{r ColoRectAdenoCA2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "ColoRect-AdenoCA"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo
```{r ColoRectAdenoCA3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}

TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "ColoRect-AdenoCA"

obj_ColoRectAdenoCA <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct,
                                                                           typedata = "signatures",
                                                                           path_to_data = "../../data/"),
                                                                nonexogenous$V1))
colnames(obj_ColoRectAdenoCA)
sortedM_ColoRectAdenoCA <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_ColoRectAdenoCA)
sortedM_ColoRectAdenoCA
```


Now the fullM doesn't converge (even though the original fullRE M nonexo did converge?), so I cannot use all the parameters to find the starting parameters of the DM, as some are NA. I can however use some, such as beta.


What parameters are NA?
```{r ColoRectAdenoCA3a1, echo=FALSE, message=FALSE, dependson=c('libraries')}
sortedM_ColoRectAdenoCA$par.fixed
```

Betas, logsd and covariances are not NA. Therefore, we use these values as starting values, and give an empty random effects matrix.

```{r ColoRectAdenoCA3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide', eval=T}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_ColoRectAdenoCA$Y)-1

initial_params_colorect <- list(
                             beta = matrix(python_like_select_name(sortedM_ColoRectAdenoCA$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(0, nrow=length(sortedM_ColoRectAdenoCA$par.random) %/% dmin1,
                                              ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_ColoRectAdenoCA$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_ColoRectAdenoCA$par.fixed, 'cov_par_RE'),
                             log_lambda = 2)

# sortedDM_ColoRectAdenoCA <- wrapper_run_TMB(model = "fullREDMsinglelambda",
#                            object = obj_ColoRectAdenoCA,
#                            smart_init_vals = F, use_nlminb = T,
#                            initial_params = initial_params_colorect)
# sortedDM_ColoRectAdenoCA

```

I get the error "gradient function must rerurn a number vector of length 43" for some reason I don't understand - it's as though the initial values I am giving are not correct.

```{r ColoRectAdenoCA3b, echo=FALSE, message=FALSE, dependson=c('ColoRectAdenoCA3')}
# sortedDM_ColoRectAdenoCA$pdHess
```

\subsubsection{Potentially problematic signatures}

```{r, ColoRectAdenoCA1d}
colSums(obj_ColoRect_AdenoCA$Y == 0)/nrow(obj_ColoRect_AdenoCA$Y)
colSums(obj_ColoRect_AdenoCA$Y)/sum(obj_ColoRect_AdenoCA$Y)
```

\subsubsection{Betas}

```{r, ColoRectAdenoCA_betas}
ct <- "ColoRect-AdenoCA"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
  plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
  plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')
                                                 ), nrow=2)
```

```{r, ColoRectAdenoCA_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "ColoRect-AdenoCA"
pval_ColoRect_AdenoCA <- wald_TMB_wrapper(diagRE_DMSL_nonexo[[ct]])
```
We use the results from the diagonal RE single lambda DM nonexo to test for differential abundance, giving a p-value of `r pval_ColoRect_AdenoCA`.

\subsubsection{Covariance matrices}

```{r, ColoRectAdenoCA_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('ColoRect_AdenoCA_additional_runs')}
ct <- "ColoRect-AdenoCA"
models_it_ColoRect_AdenoCA <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_ColoRect_AdenoCA <- lapply(models_it_ColoRect_AdenoCA,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_ColoRect_AdenoCA) <- models_it_ColoRect_AdenoCA
## because it's fullRE_M, it's sorted
colnames(covmats_ColoRect_AdenoCA[['fullRE_M']]) <- rownames(covmats_ColoRect_AdenoCA[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_ColoRect_AdenoCA)$Y))
colnames(covmats_ColoRect_AdenoCA[['fullRE_M_nonexo']]) <- rownames(covmats_ColoRect_AdenoCA[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_ColoRect_AdenoCA, nonexogenous$V1)$Y))
colnames(covmats_ColoRect_AdenoCA[['fullRE_DMSL_nonexo']]) <- rownames(covmats_ColoRect_AdenoCA[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_ColoRect_AdenoCA, nonexogenous$V1)$Y))

for(i in 1:length(covmats_ColoRect_AdenoCA)){pheatmap(covmats_ColoRect_AdenoCA[[i]], cluster_rows = F, cluster_cols = F, main = models_it_ColoRect_AdenoCA[i])}
```


\subsubsection{Simulation under inferred data}
I am simulating using the full effects multinomial, because the function <give_sim_from_estimates> needs to be adapted to diagDMSL.

```{r, ColoRectAdenoCA_sim, echo=FALSE}
sim_ColoRect_AdenoCA <- give_sim_from_estimates("ColoRect-AdenoCA", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_M", bool_nonexo = F,
                                      tmb_object=(fullRE_M_nonexo[["ColoRect-AdenoCA"]]),
                                      sig_of_interest = "SBS14")
sim_ColoRect_AdenoCA[[2]]+ggtitle('Simulation of ColoRect-AdenoCA samples')

```


\subsubsection{Ranked plot for coverage}

```{r, ColoRectAdenoCA_ranked_plot}
ct <- "ColoRect-AdenoCA"
integer_overdispersion_param_DMSL <- 1
obj_ColoRect_AdenoCA_nonexo <- give_subset_sigs_TMBobj(obj_ColoRect_AdenoCA, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_ColoRect_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_ColoRect_AdenoCA_nonexo,
                 loglog = F, title = 'obj_ColoRect_AdenoCA (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                 data_object = obj_ColoRect_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_ColoRect_AdenoCA_nonexo,
           loglog = F, title = 'obj_ColoRect_AdenoCA (diag DMSL)'), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

```{r, ColoRectAdenoCA_mutsigextractor}
obj_ColoRect_AdenoCA_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_ColoRect_AdenoCA_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: very clearly there are a few samples with very high number of mutations that also have a completely different mutational signature exposure.
```{r, ColoRectAdenoCA_sortedbynummuts, fig.height=2, fig.width=4}
createBarplot(normalise_rw(non_duplicated_rows(obj_ColoRect_AdenoCA$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_ColoRect_AdenoCA$Y)),
                                        decreasing = F)))
```

\subsection{Eso-AdenoCA}

\subsubsection{Barplot and general statistics}
```{r EsoAdenoCA1, echo=FALSE}
ct <- "Eso-AdenoCA"
obj_Eso_AdenoCA <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Eso_AdenoCA, legend_on = TRUE)
```

The number of samples and signatures is:
```{r EsoAdenoCA1b, echo=FALSE}
dim(obj_Eso_AdenoCA$Y)
```

The signatures are:
```{r EsoAdenoCA1c, echo=FALSE}
colnames(obj_Eso_AdenoCA$Y)
```


\subsubsection{Convergence table}

None of the fullRE have converged when including all signatures. When including nonexo, all but fullRE_DMSL_nonexo (using either the highest absolute signature or SBS1) have converged.
```{r EsoAdenoCA2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Eso-AdenoCA"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo
```{r EsoAdenoCA3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Eso-AdenoCA"

obj_EsoAdenoCA <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                      nonexogenous$V1))
sortedM_EsoAdenoCA <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_EsoAdenoCA, use_nlminb=T)
sortedM_EsoAdenoCA

```

which has a positive-semidefinite covariance matrix, i.e. has converged

```{r EsoAdenoCA3convergence, echo=FALSE, message=FALSE, dependson=c('libraries')}
sortedM_EsoAdenoCA$pdHess
```

The fullRE DMSL hasn't, though: 
```{r EsoAdenoCA3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_EsoAdenoCA$Y)-1

sortedDM_EsoAdenoCA <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_EsoAdenoCA,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_EsoAdenoCA$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_EsoAdenoCA$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_EsoAdenoCA$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_EsoAdenoCA$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_EsoAdenoCA
```

```{r EsoAdenoCA3b, echo=FALSE, message=FALSE, dependson=c('EsoAdenoCA3')}
sortedDM_EsoAdenoCA$pdHess
```


\subsubsection{Potentially problematic signatures}

We notice that there are no truly problematic signatures (SBS30 has the most zeros; 54.6\%).
```{r, EsoAdenoCA1d}
colSums(obj_Eso_AdenoCA$Y == 0)/nrow(obj_Eso_AdenoCA$Y)
colSums(obj_Eso_AdenoCA$Y)/sum(obj_Eso_AdenoCA$Y)
```

\subsubsection{Betas}

```{r, EsoAdenoCA_betas}
ct <- "Eso-AdenoCA"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```


```{r, EsoAdenoCA_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Eso_AdenoCA <- wald_TMB_wrapper(diagRE_DMSL_nonexo[["Eso-AdenoCA"]])
```
We use the results from the diag RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Eso_AdenoCA`.

\subsubsection{Covariance matrices}

```{r, EsoAdenoCA_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Eso_AdenoCA_additional_runs')}
ct <- "Eso-AdenoCA"
# models_it_Eso_AdenoCA <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Eso_AdenoCA <- c('fullRE_M', 'fullRE_M_nonexo')
covmats_Eso_AdenoCA <- lapply(models_it_Eso_AdenoCA,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Eso_AdenoCA) <- models_it_Eso_AdenoCA
## because it's fullRE_M, it's sorted
colnames(covmats_Eso_AdenoCA[['fullRE_M']]) <- rownames(covmats_Eso_AdenoCA[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Eso_AdenoCA)$Y))
colnames(covmats_Eso_AdenoCA[['fullRE_M_nonexo']]) <- rownames(covmats_Eso_AdenoCA[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Eso_AdenoCA, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Eso_AdenoCA)){pheatmap(covmats_Eso_AdenoCA[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Eso_AdenoCA[i])}
```


\subsubsection{Simulation under inferred data}
```{r, EsoAdenoCA_sim, echo=FALSE}
sim_Eso_AdenoCA <- give_sim_from_estimates("Eso-AdenoCA", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="diagRE_DMSL", bool_nonexo = F,
                                       tmb_object=diagRE_DMSL_nonexo[[ct]],
                                      sig_of_interest='SBS2')
sim_Eso_AdenoCA[[2]]+ggtitle('Simulation of Eso-AdenoCA samples')
```

\subsubsection{Ranked plot for coverage}

```{r, EsoAdenoCA_ranked_plot}
ct <- "Eso-AdenoCA"
integer_overdispersion_param_DMSL <- 1
obj_Eso_AdenoCA_nonexo <- give_subset_sigs_TMBobj(obj_Eso_AdenoCA, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Eso_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Eso_AdenoCA_nonexo,
                 loglog = F, title = 'obj_Eso_AdenoCA (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                 data_object = obj_Eso_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Eso_AdenoCA_nonexo,
           loglog = F, title = 'obj_Eso_AdenoCA (DMSL)'), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, EsoAdenoCA_mutsigextractor}
obj_Eso_AdenoCA_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Eso_AdenoCA_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is a trend of samples with more mutations having more SBS17b and less SBS5, relatively.
```{r, EsoAdenoCA_sortedbynummuts, fig.height=2, fig.width=6}
createBarplot(normalise_rw(non_duplicated_rows(obj_Eso_AdenoCA$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Eso_AdenoCA$Y)),
                                        decreasing = F)))
```


\subsection{Head-SCC}

\subsubsection{Barplot and general statistics}
```{r HeadSCC1, echo=FALSE}
ct <- "Head-SCC"
obj_Head_SCC <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Head_SCC, legend_on = TRUE)
```

The number of samples and signatures is:
```{r HeadSCC1b, echo=FALSE}
dim(obj_Head_SCC$Y)
```

The signatures are:
```{r HeadSCC1c, echo=FALSE}
colnames(obj_Head_SCC$Y)
```

\subsubsection{Convergence table}

We don't have converged results for the multinomial with full RE, but for nonexogenous signatures everything has.

```{r HeadSCC2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Head-SCC"
melt(all_summaries) %>% filter(value==ct)
```


\subsubsection{Re-running of fitting}
We don't need refitting, as the results have already converged.


\subsubsection{Potentially problematic signatures}

SBS33 is likely to be problematic.
```{r, HeadSCC1d}
colSums(obj_Head_SCC$Y == 0)/nrow(obj_Head_SCC$Y)
colSums(obj_Head_SCC$Y)/sum(obj_Head_SCC$Y)
```

\subsubsection{Betas}

```{r, HeadSCC_betas}
ct <- "Head-SCC"

grid.arrange(plot_betas(fullRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
             plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
             plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
             plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
  plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
  plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```


```{r, HeadSCC_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Head_SCC <- wald_TMB_wrapper(fullRE_DMSL_nonexo[["Head-SCC"]])
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Head_SCC`.

\subsubsection{Covariance matrices}

```{r, HeadSCC_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Head_SCC_additional_runs')}
ct <- "Head-SCC"
# models_it_Head_SCC <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Head_SCC <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_Head_SCC <- lapply(models_it_Head_SCC,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Head_SCC) <- models_it_Head_SCC
## because it's fullRE_M, it's sorted
colnames(covmats_Head_SCC[['fullRE_M']]) <- rownames(covmats_Head_SCC[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Head_SCC)$Y))
colnames(covmats_Head_SCC[['fullRE_M_nonexo']]) <- rownames(covmats_Head_SCC[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Head_SCC, nonexogenous$V1)$Y))
colnames(covmats_Head_SCC[['fullRE_DMSL_nonexo']]) <- rownames(covmats_Head_SCC[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Head_SCC, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Head_SCC)){pheatmap(covmats_Head_SCC[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Head_SCC[i])}
```

\subsubsection{Simulation under inferred data}
```{r, HeadSCC_sim, echo=FALSE}
sim_Head_SCC <- give_sim_from_estimates("Head-SCC", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = F, sig_of_interest="SBS2",
                                       tmb_object=fullRE_DMSL_nonexo[["Head-SCC"]])
sim_Head_SCC[[2]]+ggtitle('Simulation of Head-SCC samples')

```

\subsubsection{Ranked plot for coverage}

```{r, HeadSCC_ranked_plot}
ct <- "Head-SCC"
integer_overdispersion_param_DMSL <- 1
obj_Head_SCC_nonexo <- give_subset_sigs_TMBobj(obj_Head_SCC, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Head_SCC_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Head_SCC_nonexo,
                 loglog = F, title = 'obj_Head_SCC (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_Head_SCC_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Head_SCC_nonexo,
           loglog = F, title = 'obj_Head_SCC (DMSL)'), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, HeadSCC_mutsigextractor}
obj_Head_SCC_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Head_SCC_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.
```{r, HeadSCC_sortedbynummuts, fig.height=2, fig.width=6}
createBarplot(normalise_rw(non_duplicated_rows(obj_Head_SCC$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Head_SCC$Y)),
                                        decreasing = F)))
```

\subsection{Kidney-ChRCC}

\subsubsection{Barplot and general statistics}
```{r KidneyChRCC1, echo=FALSE}
ct <- "Kidney-ChRCC"
obj_Kidney_ChRCC <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Kidney_ChRCC, legend_on = TRUE)
```

The number of samples and signatures is:
```{r KidneyChRCC1b, echo=FALSE}
dim(obj_Kidney_ChRCC$Y)
```

The signatures are:
```{r KidneyChRCC1c, echo=FALSE}
colnames(obj_Kidney_ChRCC$Y)
```

\subsubsection{Convergence table}

For all signatures, no fullRE model has converged. For nonexogenous ones, all have.
```{r KidneyChRCC2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Kidney-ChRCC"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}
We do not need to re-run any model fitting.

\subsubsection{Potentially problematic signatures}

We notice that SBS17a and SBS17b are perhaps problematic.
```{r, KidneyChRCC1d}
colSums(obj_Kidney_ChRCC$Y == 0)/nrow(obj_Kidney_ChRCC$Y)
colSums(obj_Kidney_ChRCC$Y)/sum(obj_Kidney_ChRCC$Y)
```


\subsubsection{Betas}

```{r, KidneyChRCC_betas}
ct <- "Kidney-ChRCC"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```


```{r, KidneyChRCC_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Kidney-ChRCC"
pval_Kidney_ChRCC <- wald_TMB_wrapper(fullRE_DMSL_nonexo[[ct]])
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Kidney_ChRCC`.

\subsubsection{Covariance matrices}

```{r, KidneyChRCC_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Kidney_ChRCC_additional_runs')}
ct <- "Kidney-ChRCC"
# models_it_Kidney_ChRCC <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Kidney_ChRCC <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_Kidney_ChRCC <- lapply(models_it_Kidney_ChRCC,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Kidney_ChRCC) <- models_it_Kidney_ChRCC
## because it's fullRE_M, it's sorted
colnames(covmats_Kidney_ChRCC[['fullRE_M']]) <- rownames(covmats_Kidney_ChRCC[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Kidney_ChRCC)$Y))
colnames(covmats_Kidney_ChRCC[['fullRE_M_nonexo']]) <- rownames(covmats_Kidney_ChRCC[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Kidney_ChRCC, nonexogenous$V1)$Y))
colnames(covmats_Kidney_ChRCC[['fullRE_DMSL_nonexo']]) <- rownames(covmats_Kidney_ChRCC[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Kidney_ChRCC, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Kidney_ChRCC)){pheatmap(covmats_Kidney_ChRCC[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Kidney_ChRCC[i])}
```


\subsubsection{Simulation under inferred data}
```{r, KidneyChRCC_sim, echo=FALSE}
sim_Kidney_ChRCC <- give_sim_from_estimates("Kidney-ChRCC", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = F,
                                       tmb_object=fullRE_DMSL_nonexo[["Kidney-ChRCC"]], sig_of_interest='SBS17b')
sim_Kidney_ChRCC[[2]]+ggtitle('Simulation of Kidney-ChRCC samples')

```


\subsubsection{Ranked plot for coverage}

```{r, KidneyChRCC_ranked_plot}
ct <- "Kidney-ChRCC"
integer_overdispersion_param_DMSL <- 1
obj_Kidney_ChRCC_nonexo <- give_subset_sigs_TMBobj(obj_Kidney_ChRCC, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Kidney_ChRCC_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Kidney_ChRCC_nonexo,
                 loglog = F, title = 'obj_Kidney_ChRCC (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[["Kidney-ChRCC"]],
                 data_object = obj_Kidney_ChRCC_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Kidney_ChRCC_nonexo,
           loglog = F, title = 'obj_Kidney_ChRCC (DMSL)'), ncol=2)
```


\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, KidneyChRCC_mutsigextractor}
obj_Kidney_ChRCC_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Kidney_ChRCC_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.
```{r, KidneyChRCC_sortedbynummuts, fig.height=2, fig.width=6}
createBarplot(normalise_rw(non_duplicated_rows(obj_Kidney_ChRCC$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Kidney_ChRCC$Y)),
                                        decreasing = F)))
```

\subsection{Kidney-RCC.clearcell}
\subsubsection{Barplot and general statistics}
```{r KidneyRCCclearcell1, echo=FALSE}
ct <- "Kidney-RCC.clearcell"
obj_Kidney_RCCclearcell <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Kidney_RCCclearcell, legend_on = TRUE)
```


The number of samples and signatures is:
```{r KidneyRCCclearcell1b, echo=FALSE}
dim(obj_Kidney_RCCclearcell$Y)
```

The signatures are:
```{r KidneyRCCclearcell1c, echo=FALSE}
colnames(obj_Kidney_RCCclearcell$Y)
```

\subsubsection{Convergence table}

Essentially, everything has converged.

```{r KidneyRCCclearcell2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Kidney-RCC.clearcell"
melt(all_summaries) %>% filter(value==ct)
```



\subsubsection{Potentially problematic signatures}

There are no problematic signatures.
```{r, KidneyRCCclearcell1d}
colSums(obj_Kidney_RCCclearcell$Y == 0)/nrow(obj_Kidney_RCCclearcell$Y)
colSums(obj_Kidney_RCCclearcell$Y)/sum(obj_Kidney_RCCclearcell$Y)
```

We would need to run \verb|fullRE_DMSL|, because it timed out.

\subsubsection{Betas}

```{r, KidneyRCCclearcell_betas}
ct <- "Kidney-RCC.clearcell"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```


```{r, KidneyRCCclearcell_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Kidney-RCC.clearcell"
pval_Kidney_RCCclearcell <- wald_TMB_wrapper(fullRE_DMSL_nonexo[[ct]])
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Kidney_RCCclearcell`.

\subsubsection{Covariance matrices}

```{r, KidneyRCCclearcell_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Kidney_RCCclearcell_additional_runs')}
ct <- "Kidney-RCC.clearcell"
# models_it_Kidney_RCCclearcell <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Kidney_RCCclearcell <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_Kidney_RCCclearcell <- lapply(models_it_Kidney_RCCclearcell,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Kidney_RCCclearcell) <- models_it_Kidney_RCCclearcell
## because it's fullRE_M, it's sorted
colnames(covmats_Kidney_RCCclearcell[['fullRE_M']]) <- rownames(covmats_Kidney_RCCclearcell[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Kidney_RCCclearcell)$Y))
colnames(covmats_Kidney_RCCclearcell[['fullRE_M_nonexo']]) <- rownames(covmats_Kidney_RCCclearcell[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Kidney_RCCclearcell, nonexogenous$V1)$Y))
colnames(covmats_Kidney_RCCclearcell[['fullRE_DMSL_nonexo']]) <- rownames(covmats_Kidney_RCCclearcell[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Kidney_RCCclearcell, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Kidney_RCCclearcell)){pheatmap(covmats_Kidney_RCCclearcell[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Kidney_RCCclearcell[i])}
```

\subsubsection{Simulation under inferred data}
```{r, KidneyRCCclearcell_sim, echo=FALSE}
sim_Kidney_RCCclearcell <- give_sim_from_estimates("Kidney-RCC.clearcell", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = F, sig_of_interest='SBS12',
                                       tmb_object=fullRE_DMSL_nonexo[["Kidney-RCC.clearcell"]])
sim_Kidney_RCCclearcell[[2]]+ggtitle('Simulation of Kidney-RCC.clearcell samples')

```


\subsubsection{Ranked plot for coverage}

```{r, KidneyRCCclearcell_ranked_plot}
ct <- "Kidney-RCC.clearcell"
integer_overdispersion_param_DMSL <- 1
obj_Kidney_RCCclearcell_nonexo <- give_subset_sigs_TMBobj(obj_Kidney_RCCclearcell, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Kidney_RCCclearcell_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Kidney_RCCclearcell_nonexo,
                 loglog = F, title = 'obj_Kidney_RCCclearcell (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_Kidney_RCCclearcell_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Kidney_RCCclearcell_nonexo,
           loglog = F, title = 'obj_Kidney_RCCclearcell (DMSL)'), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, KidneyRCCclearcell_mutsigextractor}
obj_Kidney_RCCclearcell_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Kidney_RCCclearcell_mutSigExtractor, legend_on = FALSE)
```

I should check if this grey exposure corresponds to SBS40.

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations except for perhaps the very few with highest exposure.
```{r, KidneyRCCclearcell_sortedbynummuts, fig.height=2, fig.width=6}
createBarplot(normalise_rw(non_duplicated_rows(obj_Kidney_RCCclearcell$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Kidney_RCCclearcell$Y)),
                                        decreasing = F)))
```


\subsection{Kidney-RCC.papillary}
It looks very similar to clear cell, looking generally at the signatures.

\subsubsection{Barplot and general statistics}
```{r KidneyRCCpapillary1, echo=FALSE}
ct <- "Kidney-RCC.papillary"
obj_Kidney_RCCpapillary <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Kidney_RCCpapillary, legend_on = TRUE)
```

The number of samples and signatures is:
```{r KidneyRCCpapillary1b, echo=FALSE}
dim(obj_Kidney_RCCpapillary$Y)
```

The signatures are:
```{r KidneyRCCpapillary1c, echo=FALSE}
colnames(obj_Kidney_RCCpapillary$Y)
```

\subsubsection{Convergence table}

Although fulLRE DMSL has in one case converged, it hasn't when using SBS1 as baseline. The nonexogenous version has not converged, but M has.


```{r KidneyRCCpapillary2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Kidney-RCC.papillary"
melt(all_summaries) %>% filter(value==ct)
```


\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo. We first re-run M.
```{r KidneyRCCpapillary3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Kidney-RCC.papillary"

obj_KidneyRCCpapillary <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_KidneyRCCpapillary <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_KidneyRCCpapillary)
sortedM_KidneyRCCpapillary
```

The we use it to re-run DM.
```{r KidneyRCCpapillary3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_KidneyRCCpapillary$Y)-1

sortedDM_KidneyRCCpapillary <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_KidneyRCCpapillary,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_KidneyRCCpapillary$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_KidneyRCCpapillary$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_KidneyRCCpapillary$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_KidneyRCCpapillary$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_KidneyRCCpapillary

```


If we use the values of the fullRE M exo as initial values for the fullRE DMSL exo do converge:
```{r KidneyRCCpapillary3b, echo=FALSE, message=FALSE, dependson=c('KidneyRCCpapillary3')}
sortedDM_KidneyRCCpapillary$pdHess
```


\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures:
```{r, KidneyRCCpapillary1d}
colSums(obj_Kidney_RCCpapillary$Y == 0)/nrow(obj_Kidney_RCCpapillary$Y)
colSums(obj_Kidney_RCCpapillary$Y)/sum(obj_Kidney_RCCpapillary$Y)
```
SBS29 is found in relatively small quantities.

```{r, Kidney_RCCpapillary_additional_runs, dependson=c('additional_runs'), echo=FALSE}
additional_sortedMnonexo[["Kidney-RCC.papillary"]] <- sortedM_KidneyRCCpapillary
additional_sortedDMSLnonexo[["Kidney-RCC.papillary"]] <- sortedDM_KidneyRCCpapillary
```

\subsubsection{Betas}

```{r, KidneyRCCpapillary_betas}
ct <- "Kidney-RCC.papillary"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(sortedDM_KidneyRCCpapillary)+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```



```{r, KidneyRCCpapillary_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Kidney-RCC.papillary"
pval_Kidney_RCCpapillary <- wald_TMB_wrapper(sortedDM_KidneyRCCpapillary)
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Kidney_RCCpapillary`.

\subsubsection{Covariance matrices}

```{r, KidneyRCCpapillary_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Kidney_RCCpapillary_additional_runs')}
ct <- "Kidney-RCC.papillary"
# models_it_Kidney_RCCpapillary <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Kidney_RCCpapillary <- c('fullRE_M', 'fullRE_M_nonexo', 'additional_sortedDMSLnonexo')
covmats_Kidney_RCCpapillary <- lapply(models_it_Kidney_RCCpapillary,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Kidney_RCCpapillary) <- models_it_Kidney_RCCpapillary
## because it's fullRE_M, it's sorted
colnames(covmats_Kidney_RCCpapillary[['fullRE_M']]) <- rownames(covmats_Kidney_RCCpapillary[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Kidney_RCCpapillary)$Y))
colnames(covmats_Kidney_RCCpapillary[['fullRE_M_nonexo']]) <- rownames(covmats_Kidney_RCCpapillary[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Kidney_RCCpapillary, nonexogenous$V1)$Y))
colnames(covmats_Kidney_RCCpapillary[['additional_sortedDMSLnonexo']]) <- rownames(covmats_Kidney_RCCpapillary[['additional_sortedDMSLnonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Kidney_RCCpapillary, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Kidney_RCCpapillary)){pheatmap(covmats_Kidney_RCCpapillary[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Kidney_RCCpapillary[i])}
```


\subsubsection{Simulation under inferred data}
```{r, KidneyRCCpapillary_sim, echo=FALSE}
sim_Kidney_RCCpapillary <- give_sim_from_estimates("Kidney-RCC.papillary", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = F,
                                      sig_of_interest='SBS22',
                                       tmb_object=sortedDM_KidneyRCCpapillary)
sim_Kidney_RCCpapillary[[2]]+ggtitle('Simulation of Kidney-RCC.papillary samples')

```


\subsubsection{Ranked plot for coverage}

What has happened here?

```{r, KidneyRCCpapillary_ranked_plot, echo=FALSE}
ct <- "Kidney-RCC.papillary"
integer_overdispersion_param_DMSL <- 1
obj_Kidney_RCCpapillary_nonexo <- give_subset_sigs_TMBobj(obj_Kidney_RCCpapillary, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Kidney_RCCpapillary_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Kidney_RCCpapillary_nonexo,
                 loglog = F, title = 'obj_Kidney_RCCpapillary (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = sortedDM_KidneyRCCpapillary,
                 data_object = obj_Kidney_RCCpapillary_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Kidney_RCCpapillary_nonexo,
           loglog = F, title = 'obj_Kidney_RCCpapillary (DMSL)'), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, KidneyRCCpapillary_mutsigextractor}
obj_Kidney_RCCpapillary_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Kidney_RCCpapillary_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.
```{r, KidneyRCCpapillary_sortedbynummuts, fig.height=2, fig.width=6}
createBarplot(normalise_rw(non_duplicated_rows(obj_Kidney_RCCpapillary$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Kidney_RCCpapillary$Y)),
                                        decreasing = F)))
```

\subsection{Liver-HCC}
\subsubsection{Barplot and general statistics}
```{r LiverHCC1, echo=FALSE}
ct <- "Liver-HCC"
obj_Liver_HCC <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Liver_HCC, legend_on = TRUE)
```


The number of samples and signatures is:
```{r LiverHCC1b, echo=FALSE}
dim(obj_Liver_HCC$Y)
```

The signatures are:
```{r LiverHCC1c, echo=FALSE}
colnames(obj_Liver_HCC$Y)
```


\subsubsection{Convergence table}

The fullRE versions with all signatures have not converged. Neither has \verb|fullRE_M_nonexo|, but \verb|fullRE_DMSL_nonexo| has.
```{r LiverHCC2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Liver-HCC"
melt(all_summaries) %>% filter(value==ct)
```


\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures:
```{r, LiverHCC1d}
colSums(obj_Liver_HCC$Y == 0)/nrow(obj_Liver_HCC$Y)
colSums(obj_Liver_HCC$Y)/sum(obj_Liver_HCC$Y)
```

SBS28 is only present in 7\% of samples and has extremely low exposure - we could consider removing it.


\subsubsection{Betas}

```{r, LiverHCC_betas}
ct <- "Liver-HCC"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```

```{r, LiverHCC_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Liver-HCC"
pval_Liver_HCC <- wald_TMB_wrapper(fullRE_DMSL_nonexo[[ct]])
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Liver_HCC`.

\subsubsection{Covariance matrices}

```{r, LiverHCC_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Liver_HCC_additional_runs')}
ct <- "Liver-HCC"
# models_it_Liver_HCC <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Liver_HCC <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_Liver_HCC <- lapply(models_it_Liver_HCC,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Liver_HCC) <- models_it_Liver_HCC
## because it's fullRE_M, it's sorted
colnames(covmats_Liver_HCC[['fullRE_M']]) <- rownames(covmats_Liver_HCC[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Liver_HCC)$Y))
colnames(covmats_Liver_HCC[['fullRE_M_nonexo']]) <- rownames(covmats_Liver_HCC[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Liver_HCC, nonexogenous$V1)$Y))
colnames(covmats_Liver_HCC[['fullRE_DMSL_nonexo']]) <- rownames(covmats_Liver_HCC[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Liver_HCC, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Liver_HCC)){pheatmap(covmats_Liver_HCC[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Liver_HCC[i])}
```

\subsubsection{Simulation under inferred data}
```{r, LiverHCC_sim, echo=FALSE}
sim_Liver_HCC <- give_sim_from_estimates("Liver-HCC", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = F,
                                      sig_of_interest='SBS19',
                                       tmb_object=fullRE_DMSL_nonexo[["Liver-HCC"]])
sim_Liver_HCC[[2]]+ggtitle('Simulation of Liver-HCC samples')

```



\subsubsection{Ranked plot for coverage}

Remember that fullRE M has not converged, and it should be re-run:
```{r, LiverHCC_ranked_plot}
ct <- "Liver-HCC"
integer_overdispersion_param_DMSL <- 1
obj_Liver_HCC_nonexo <- give_subset_sigs_TMBobj(obj_Liver_HCC, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Liver_HCC_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Liver_HCC_nonexo,
                 loglog = F, title = 'obj_Liver_HCC (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_Liver_HCC_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Liver_HCC_nonexo,
           loglog = F, title = 'obj_Liver_HCC (DMSL)'), ncol=2)
```


\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, LiverHCC_mutsigextractor}
obj_Liver_HCC_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Liver_HCC_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.
```{r, LiverHCC_sortedbynummuts, fig.height=2, fig.width=6}
createBarplot(normalise_rw(non_duplicated_rows(obj_Liver_HCC$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Liver_HCC$Y)),
                                        decreasing = F)))
```

\subsection{Lung-AdenoCA}
How can we have such few samples?
\subsubsection{Barplot and general statistics}
```{r LungAdenoCA1, echo=FALSE}
ct <- "Lung-AdenoCA"
obj_Lung_AdenoCA <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Lung_AdenoCA, legend_on = TRUE)
```



The number of samples and signatures is:
```{r LungAdenoCA1b, echo=FALSE}
dim(obj_Lung_AdenoCA$Y)
```

The signatures are:
```{r LungAdenoCA1c, echo=FALSE}
colnames(obj_Lung_AdenoCA$Y)
```


\subsubsection{Convergence table}

No fullRE DMSL have converged.
```{r LungAdenoCA2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Lung-AdenoCA"
melt(all_summaries) %>% filter(value==ct)
```


\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo. We re-run fullRE_M_nonexo and it has converged:
```{r LungAdenoCA3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Lung-AdenoCA"

obj_LungAdenoCA <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_LungAdenoCA <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_LungAdenoCA)
sortedM_LungAdenoCA
```

But fullRE DMSL hasn't:
```{r LungAdenoCA3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_LungAdenoCA$Y)-1

sortedDM_LungAdenoCA <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_LungAdenoCA,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_LungAdenoCA$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_LungAdenoCA$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_LungAdenoCA$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_LungAdenoCA$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_LungAdenoCA
```

If we use the values of the fullRE M exo as initial values for the fullRE DMSL exo does not converge:
```{r LungAdenoCA3b, echo=FALSE, message=FALSE, dependson=c('LungAdenoCA3')}
sortedDM_LungAdenoCA$pdHess
```

\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures:
```{r, LungAdenoCA1d}
colSums(obj_Lung_AdenoCA$Y == 0)/nrow(obj_Lung_AdenoCA$Y)
colSums(obj_Lung_AdenoCA$Y)/sum(obj_Lung_AdenoCA$Y)
```
None seem to be problematic.


\subsubsection{Betas}

```{r, LungAdenoCA_betas}
ct <- "Lung-AdenoCA"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```


```{r, LungAdenoCA_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Lung-AdenoCA"
pval_Lung_AdenoCA <- wald_TMB_wrapper(diagRE_DMSL_nonexo[[ct]])
```
We use the results from the diag RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Lung_AdenoCA`.

\subsubsection{Covariance matrices}

```{r, LungAdenoCA_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Lung_AdenoCA_additional_runs')}
ct <- "Lung-AdenoCA"
# models_it_Lung_AdenoCA <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Lung_AdenoCA <- c('fullRE_M', 'fullRE_M_nonexo')
covmats_Lung_AdenoCA <- lapply(models_it_Lung_AdenoCA,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Lung_AdenoCA) <- models_it_Lung_AdenoCA
## because it's fullRE_M, it's sorted
colnames(covmats_Lung_AdenoCA[['fullRE_M']]) <- rownames(covmats_Lung_AdenoCA[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Lung_AdenoCA)$Y))
colnames(covmats_Lung_AdenoCA[['fullRE_M_nonexo']]) <- rownames(covmats_Lung_AdenoCA[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Lung_AdenoCA, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Lung_AdenoCA)){pheatmap(covmats_Lung_AdenoCA[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Lung_AdenoCA[i])}
```



\subsubsection{Simulation under inferred data}
```{r, LungAdenoCA_sim, echo=FALSE}
sim_Lung_AdenoCA <- give_sim_from_estimates("Lung-AdenoCA", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="diagRE_DMSL", bool_nonexo = F,
                                      sig_of_interest='SBS9',
                                       tmb_object=diagRE_DMSL_nonexo[["Lung-AdenoCA"]])
sim_Lung_AdenoCA[[2]]+ggtitle('Simulation of Lung-AdenoCA samples')

```

\subsubsection{Ranked plot for coverage}

THIS IS PROBABLY INCORRECT! THE OBJECT SHOULD BE SORTED
```{r, LungAdenoCA_ranked_plot}
ct <- "Lung-AdenoCA"
integer_overdispersion_param_DMSL <- 1
obj_Lung_AdenoCA_nonexo <- give_subset_sigs_TMBobj(obj_Lung_AdenoCA, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Lung_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Lung_AdenoCA_nonexo,
                 loglog = F, title = 'obj_Lung_AdenoCA (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                 data_object = obj_Lung_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Lung_AdenoCA_nonexo,
           loglog = F, title = 'obj_Lung_AdenoCA (DMSL)'), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, LungAdenoCA_mutsigextractor}
obj_Lung_AdenoCA_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Lung_AdenoCA_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is a trend in which SBS5 decreases and SBS4 increases with the number of mutations.
```{r, LungAdenoCA_sortedbynummuts, fig.height=2, fig.width=6}
createBarplot(normalise_rw(non_duplicated_rows(obj_Lung_AdenoCA$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Lung_AdenoCA$Y)),
                                        decreasing = F)))
```


\subsection{Lung-SCC}
\subsubsection{Barplot and general statistics}
```{r LungSCC1, echo=FALSE}
ct <- "Lung-SCC"
obj_Lung_SCC <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Lung_SCC, legend_on = TRUE)
```



The number of samples and signatures is:
```{r LungSCC1b, echo=FALSE}
dim(obj_Lung_SCC$Y)
```

The signatures are:
```{r LungSCC1c, echo=FALSE}
colnames(obj_Lung_SCC$Y)
```

\subsubsection{Convergence table}

We have converged results in most cases, and all in nonexo.

```{r LungSCC2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Lung-SCC"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures; none are.
```{r, LungSCC1d}
colSums(obj_Lung_SCC$Y == 0)/nrow(obj_Lung_SCC$Y)
colSums(obj_Lung_SCC$Y)/sum(obj_Lung_SCC$Y)
```

\subsubsection{Betas}

Very clear example of only one signature changing:
```{r, LungSCC_betas}
ct <- "Lung-SCC"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```

```{r, LungSCC_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Lung-SCC"
pval_Lung_SCC <- wald_TMB_wrapper(fullRE_DMSL_nonexo[[ct]])
```

We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Lung_SCC`.

\subsubsection{Covariance matrices}

```{r, LungSCC_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Lung_SCC_additional_runs')}
ct <- "Lung-SCC"
# models_it_Lung_SCC <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Lung_SCC <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_Lung_SCC <- lapply(models_it_Lung_SCC,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Lung_SCC) <- models_it_Lung_SCC
## because it's fullRE_M, it's sorted
colnames(covmats_Lung_SCC[['fullRE_M']]) <- rownames(covmats_Lung_SCC[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Lung_SCC)$Y))
colnames(covmats_Lung_SCC[['fullRE_M_nonexo']]) <- rownames(covmats_Lung_SCC[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Lung_SCC, nonexogenous$V1)$Y))
colnames(covmats_Lung_SCC[['fullRE_DMSL_nonexo']]) <- rownames(covmats_Lung_SCC[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Lung_SCC, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Lung_SCC)){pheatmap(covmats_Lung_SCC[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Lung_SCC[i])}
```


\subsubsection{Ranked plot for coverage}

```{r, LungSCC_ranked_plot, echo=FALSE}
ct <- "Lung-SCC"
integer_overdispersion_param_DMSL <- 1
obj_Lung_SCC_nonexo <- give_subset_sigs_TMBobj(obj_Lung_SCC, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Lung_SCC_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Lung_SCC_nonexo,
                 loglog = F, title = 'obj_Lung_SCC (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_Lung_SCC_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Lung_SCC_nonexo,
           loglog = F, title = 'obj_Lung_SCC (DMSL)'), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, LungSCC_mutsigextractor}
obj_Lung_SCC_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Lung_SCC_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.
```{r, LungSCC_sortedbynummuts, fig.height=2, fig.width=6}
createBarplot(normalise_rw(non_duplicated_rows(obj_Lung_SCC$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Lung_SCC$Y)),
                                        decreasing = F)))
```

\subsection{Lymph-BNHL}
\subsubsection{Barplot and general statistics}
```{r LymphBNHL1, echo=FALSE}
ct <- "Lymph-BNHL"
obj_Lymph_BNHL <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Lymph_BNHL, legend_on = TRUE)
```



The number of samples and signatures is:
```{r LymphBNHL1b, echo=FALSE}
dim(obj_Lymph_BNHL$Y)
```

The signatures are:
```{r LymphBNHL1c, echo=FALSE}
colnames(obj_Lymph_BNHL$Y)
```


\subsubsection{Convergence table}

fullRE_DMSL_nonexo had not run, and fullRE_M_nonexo didn't converge.
```{r LymphBNHL2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Lymph-BNHL"
melt(all_summaries) %>% filter(value==ct)
```



\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo. Very clearly there are too many signatures.
```{r LymphBNHL3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Lymph-BNHL"

obj_LymphBNHL <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_LymphBNHL <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_LymphBNHL)
sortedM_LymphBNHL
```

Which signatures should be omitted from the analysis?

```{r, LymphBNHL_remove_small_signatures, fig.height=2}

ggplot(melt(obj_LymphBNHL$Y), aes(x=Var2, y=value+1))+geom_violin()+scale_y_continuous(trans = "log2")

```

SBS13 and SBS39 should definitely be removed.

```{r LymphBNHL3_subset, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Lymph-BNHL"

obj_LymphBNHL <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                c(nonexogenous$V1, 'SBS13', 'SBS39')))
sortedM_LymphBNHL <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_LymphBNHL, use_nlminb=T)
sortedM_LymphBNHL
```

Has fullRE M now converged?
converge:
```{r LymphBNHL3_subset_conv, echo=FALSE, message=FALSE, dependson=c('LymphBNHL3')}
sortedM_LymphBNHL$pdHess
```

it has. I now run DM with this subset

```{r LymphBNHL3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_LymphBNHL$Y)-1

sortedDM_LymphBNHL <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_LymphBNHL,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_LymphBNHL$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_LymphBNHL$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_LymphBNHL$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_LymphBNHL$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_LymphBNHL

```

Its convergence is as follows:

```{r LymphBNHL3b, echo=FALSE, message=FALSE, dependson=c('LymphBNHL3')}
sortedDM_LymphBNHL$pdHess
```

it has also converged

```{r, Lymph_BNHL_additional_runs, dependson=c('additional_runs')}
additional_sortedMnonexo[["Lymph-BNHL"]] <- sortedM_LymphBNHL
additional_sortedDMSLnonexo[["Lymph-BNHL"]] <- sortedDM_LymphBNHL
```


\subsubsection{Betas}

```{r, LymphBNHL_betas}
ct <- "Lymph-BNHL"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(additional_sortedMnonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(additional_sortedDMSLnonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```


```{r, LymphBNHL_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Lymph-BNHL"
pval_Lymph_BNHL <- wald_TMB_wrapper(sortedDM_LymphBNHL)
```
We use the results from the full RE single lambda DM with the subset of signatures (removing thw two problematic ones) to test for differential abundance, giving a p-value of `r pval_Lymph_BNHL`.

\subsubsection{Covariance matrices}

```{r, LymphBNHL_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Lymph_BNHL_additional_runs')}
ct <- "Lymph-BNHL"
models_it_Lymph_BNHL <- c('fullRE_M', 'additional_sortedMnonexo', 'additional_sortedDMSLnonexo')
covmats_Lymph_BNHL <- lapply(models_it_Lymph_BNHL,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Lymph_BNHL) <- models_it_Lymph_BNHL
## because it's fullRE_M, it's sorted
colnames(covmats_Lymph_BNHL[['fullRE_M']]) <- rownames(covmats_Lymph_BNHL[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Lymph_BNHL)$Y))
colnames(covmats_Lymph_BNHL[['additional_sortedMnonexo']]) <- rownames(covmats_Lymph_BNHL[['additional_sortedMnonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Lymph_BNHL,c(nonexogenous$V1, 'SBS13', 'SBS39'))$Y))
colnames(covmats_Lymph_BNHL[['additional_sortedDMSLnonexo']]) <- rownames(covmats_Lymph_BNHL[['additional_sortedDMSLnonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Lymph_BNHL,c(nonexogenous$V1, 'SBS13', 'SBS39'))$Y))
for(i in 1:length(covmats_Lymph_BNHL)){pheatmap(covmats_Lymph_BNHL[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Lymph_BNHL[i])}
```

\subsubsection{Simulation under inferred data}
```{r, LymphBNHL_sim, echo=FALSE}
sim_Lymph_BNHL <- give_sim_from_estimates("Lymph-BNHL", "signatures",
                                      sigs_to_remove=c(unique(nonexogenous$V1), 'SBS13', 'SBS39'),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = F,
                                      sig_of_interest='SBS6',
                                       tmb_object=sortedDM_LymphBNHL)
sim_Lymph_BNHL[[2]]+ggtitle('Simulation of Lymph-BNHL samples')

```


\subsubsection{Ranked plot for coverage}
Should it be simply give_subset_sigs_TMBobj or additionally also sort_columns_TMB? If I only use give_subset_sigs_TMBobj I get very strange results. This should perhaps be changed to all chunks above!!
```{r, LymphBNHL_ranked_plot}
ct <- "Lymph-BNHL"
integer_overdispersion_param_DMSL <- 1
obj_Lymph_BNHL_nonexo <- sort_columns_TMB(give_subset_sigs_TMBobj(obj_Lymph_BNHL,
                                                 sigs_to_remove = c(nonexogenous$V1, 'SBS13', 'SBS39')))
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = sortedM_LymphBNHL,
                 data_object = obj_Lymph_BNHL_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Lymph_BNHL_nonexo,
                 loglog = F, title = 'obj_Lymph_BNHL (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = sortedDM_LymphBNHL,
                 data_object = obj_Lymph_BNHL_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Lymph_BNHL_nonexo,
           loglog = F, title = 'obj_Lymph_BNHL (DMSL)'), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, LymphBNHL_mutsigextractor}
obj_Lymph_BNHL_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Lymph_BNHL_mutSigExtractor, legend_on = FALSE)
```
something must have gone wrong here.


Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.
```{r, LymphBNHL_sortedbynummuts, fig.height=2, fig.width=6}
createBarplot(normalise_rw(non_duplicated_rows(obj_Lymph_BNHL$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Lymph_BNHL$Y)),
                                        decreasing = F)))
```

\subsection{Lymph-CLL}

\subsubsection{Barplot and general statistics}
```{r LymphCLL1, echo=FALSE}
ct <- "Lymph-CLL"
obj_Lymph_CLL <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Lymph_CLL, legend_on = TRUE)
```



The number of samples and signatures is:
```{r LymphCLL1b, echo=FALSE}
dim(obj_Lymph_CLL$Y)
```

The signatures are:
```{r LymphCLL1c, echo=FALSE}
colnames(obj_Lymph_CLL$Y)
```


\subsubsection{Convergence table}

We have converged results in most cases

```{r LymphCLL2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Lymph-CLL"
melt(all_summaries) %>% filter(value==ct)
```


\subsubsection{Potentially problematic signatures}
SBS9 has quite a lot of zeros.
```{r, LymphCLL1d}
colSums(obj_Lymph_CLL$Y == 0)/nrow(obj_Lymph_CLL$Y)
colSums(obj_Lymph_CLL$Y)/sum(obj_Lymph_CLL$Y)
```



\subsubsection{Betas}

It's interesting the very high correlation between intercept and slope betas.

```{r, LymphCLL_betas}
ct <- "Lymph-CLL"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
  plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')), nrow=2)
```




```{r, LymphCLL_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Lymph-CLL"
pval_Lymph_CLL <- wald_TMB_wrapper(fullRE_DMSL_nonexo[[ct]])
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Lymph_CLL`.


\subsubsection{Covariance matrices}



```{r, LymphCLL_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Lymph_CLL_additional_runs')}
ct <- "Lymph-CLL"
# models_it_Lymph_CLL <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Lymph_CLL <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_Lymph_CLL <- lapply(models_it_Lymph_CLL,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Lymph_CLL) <- models_it_Lymph_CLL
## because it's fullRE_M, it's sorted
colnames(covmats_Lymph_CLL[['fullRE_M']]) <- rownames(covmats_Lymph_CLL[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Lymph_CLL)$Y))
colnames(covmats_Lymph_CLL[['fullRE_M_nonexo']]) <- rownames(covmats_Lymph_CLL[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Lymph_CLL, nonexogenous$V1)$Y))
colnames(covmats_Lymph_CLL[['fullRE_DMSL_nonexo']]) <- rownames(covmats_Lymph_CLL[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Lymph_CLL, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Lymph_CLL)){pheatmap(covmats_Lymph_CLL[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Lymph_CLL[i])}
```




\subsubsection{Simulation under inferred data}
```{r, LymphCLL_sim, echo=FALSE}
sim_Lymph_CLL <- give_sim_from_estimates("Lymph-CLL", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = F,
                                       tmb_object=fullRE_DMSL_nonexo[["Lymph-CLL"]], sig_of_interest='SBS9')
sim_Lymph_CLL[[2]]+ggtitle('Simulation of Lymph-CLL samples')

```



\subsubsection{Ranked plot for coverage}

```{r, LymphCLL_ranked_plot}
ct <- "Lymph-CLL"
integer_overdispersion_param_DMSL <- 1
obj_Lymph_CLL_nonexo <- give_subset_sigs_TMBobj(obj_Lymph_CLL, sigs_to_remove = nonexogenous$V1)
for(loglog_bool_it in c(T,F)){
  .full_rankedplot <-    give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[["Lymph-CLL"]],
                   data_object = obj_Lymph_CLL_nonexo,
                   print_plot = F, nreps = 100, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                     lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                            rank_number=1:length(j)) )})[[1]],
                   data_object = obj_Lymph_CLL_nonexo,
             loglog = loglog_bool_it, title = 'obj_Lymph_CLL nonexo (fullRE DMSL)')
  grid.arrange(
    give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                   data_object = obj_Lymph_CLL_nonexo,
                   print_plot = F, nreps = 100, model = "M")), function(i){
                     lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                            rank_number=1:length(j)) )})[[1]],
                   data_object = obj_Lymph_CLL_nonexo,
                   loglog = loglog_bool_it, title = 'obj_Lymph_CLL nonexo (M)'),
    .full_rankedplot, ncol=2)

  grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                   data_object = obj_Lymph_CLL_nonexo,
                   print_plot = F, nreps = 100, model = "DMSL",
                   integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                     lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                            rank_number=1:length(j)) )})[[1]],
                   data_object = obj_Lymph_CLL_nonexo,
                   loglog = loglog_bool_it, title = 'obj_Lymph_CLL nonexo (diagRE DMSL)'),
               .full_rankedplot, ncol=2)

}
```


\subsubsection{Signatures from mutSigExtractor}

These are the signatures from mutSigExtractor:
```{r, LymphCLL_mutsigextractor}
obj_Lymph_CLL_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Lymph_CLL_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: SBS9 and SBS25 seem to be somewhat associated with samples with a high number of mutations.
```{r, LymphCLL_sortedbynummuts, fig.height=2}
createBarplot(normalise_rw(non_duplicated_rows(obj_Lymph_CLL$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Lymph_CLL$Y)),
                                        decreasing = F)))
```



\subsection{Myeloid-MPN}

\subsubsection{Barplot and general statistics}
```{r MyeloidMPN1, echo=FALSE}
ct <- "Myeloid-MPN"
obj_Myeloid_MPN <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Myeloid_MPN, legend_on = TRUE)
```

The number of samples and signatures is:
```{r MyeloidMPN1b, echo=FALSE}
dim(obj_Myeloid_MPN$Y)
```

The signatures are:
```{r MyeloidMPN1c, echo=FALSE}
colnames(obj_Myeloid_MPN$Y)
```

\subsubsection{Convergence table}

These are the results for the convergence of models fits. The fullRE DMSL have not converged, or have not run.

```{r MyeloidMPN2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Myeloid-MPN"
melt(all_summaries) %>% filter(value==ct)
```


\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo.
```{r MyeloidMPN3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Myeloid-MPN"

obj_MyeloidMPN <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_MyeloidMPN <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_MyeloidMPN)
sortedM_MyeloidMPN
```

```{r MyeloidMPN3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_MyeloidMPN$Y)-1

sortedDM_MyeloidMPN <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_MyeloidMPN,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_MyeloidMPN$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_MyeloidMPN$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_MyeloidMPN$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_MyeloidMPN$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_MyeloidMPN

```

If we use the values of the fullRE M exo as initial values for the fullRE DMSL exo do converge:
```{r MyeloidMPN3b, echo=FALSE, message=FALSE, dependson=c('MyeloidMPN3')}
sortedDM_MyeloidMPN$pdHess
```


\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures. There are none.
```{r, MyeloidMPN1d}
colSums(obj_Myeloid_MPN$Y == 0)/nrow(obj_Myeloid_MPN$Y)
colSums(obj_Myeloid_MPN$Y)/sum(obj_Myeloid_MPN$Y)
```

```{r, Myeloid_MPN_additional_runs, dependson=c('additional_runs')}
additional_sortedMnonexo[["Myeloid-MPN"]] <- sortedM_MyeloidMPN
additional_sortedDMSLnonexo[["Myeloid-MPN"]] <- sortedDM_MyeloidMPN
```


```{r, MyeloidMPN_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Myeloid-MPN"
pval_Myeloid_MPN <- wald_TMB_wrapper(sortedDM_MyeloidMPN)
```

We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Myeloid_MPN`.


\subsubsection{Betas}

```{r, MyeloidMPN_betas}
ct <- "Myeloid-MPN"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(sortedDM_MyeloidMPN)+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')), nrow=2)
```

\subsubsection{Covariance matrices}

```{r, MyeloidMPN_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Myeloid_MPN_additional_runs')}
ct <- "Myeloid-MPN"
models_it_Myeloid_MPN <- c('fullRE_M', 'fullRE_M_nonexo', 'additional_sortedDMSLnonexo')
covmats_Myeloid_MPN <- lapply(models_it_Myeloid_MPN,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Myeloid_MPN) <- models_it_Myeloid_MPN
## because it's fullRE_M, it's sorted
colnames(covmats_Myeloid_MPN[['fullRE_M']]) <- rownames(covmats_Myeloid_MPN[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Myeloid_MPN)$Y))
colnames(covmats_Myeloid_MPN[['fullRE_M_nonexo']]) <- rownames(covmats_Myeloid_MPN[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Myeloid_MPN, nonexogenous$V1)$Y))
colnames(covmats_Myeloid_MPN[['additional_sortedDMSLnonexo']]) <- rownames(covmats_Myeloid_MPN[['additional_sortedDMSLnonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Myeloid_MPN, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Myeloid_MPN)){pheatmap(covmats_Myeloid_MPN[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Myeloid_MPN[i])}
```


\subsubsection{Simulation under inferred data}
```{r, MyeloidMPN_sim, echo=FALSE}
sim_Myeloid_MPN <- give_sim_from_estimates("Myeloid-MPN", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = F,
                                       tmb_object=sortedDM_MyeloidMPN)
sim_Myeloid_MPN[[2]]+ggtitle('Simulation of Myeloid-MPN samples')

```


\subsubsection{Ranked plot for coverage}

```{r, MyeloidMPN_ranked_plot}
ct <- "Myeloid-MPN"
integer_overdispersion_param_DMSL <- 1
obj_Myeloid_MPN_nonexo <- (give_subset_sigs_TMBobj(obj_Myeloid_MPN, sigs_to_remove = nonexogenous$V1))
obj_Myeloid_MPN_nonexo_sorted <- sort_columns_TMB(give_subset_sigs_TMBobj(obj_Myeloid_MPN, sigs_to_remove = nonexogenous$V1))
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Myeloid_MPN_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Myeloid_MPN_nonexo,
                 loglog = F, title = 'obj_Myeloid_MPN (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = sortedDM_MyeloidMPN,
                 data_object = obj_Myeloid_MPN_nonexo_sorted,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Myeloid_MPN_nonexo_sorted,
           loglog = F, title = 'obj_Myeloid_MPN (DMSL)'), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, MyeloidMPN_mutsigextractor}
obj_Myeloid_MPN_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Myeloid_MPN_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.
```{r, MyeloidMPN_sortedbynummuts, fig.height=2, fig.width=6, echo=FALSE}
createBarplot(normalise_rw(non_duplicated_rows(obj_Myeloid_MPN$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Myeloid_MPN$Y)),
                                        decreasing = F)))
```

\subsection{Ovary-AdenoCA}
\subsubsection{Barplot and general statistics}
```{r OvaryAdenoCA1, echo=FALSE}
ct <- "Ovary-AdenoCA"
obj_Ovary_AdenoCA <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Ovary_AdenoCA, legend_on = TRUE)
```



The number of samples and signatures is:
```{r OvaryAdenoCA1b, echo=FALSE}
dim(obj_Ovary_AdenoCA$Y)
```

The signatures are:
```{r OvaryAdenoCA1c, echo=FALSE}
colnames(obj_Ovary_AdenoCA$Y)
```

\subsubsection{Convergence table}

These are the results for the convergence of models fits. None of the all-signatures models converged (we do have many signatures!) but nonexo generally have, except fullRE_DMSL_nonexo.

```{r OvaryAdenoCA2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Ovary-AdenoCA"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo.
```{r OvaryAdenoCA3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Ovary-AdenoCA"

obj_OvaryAdenoCA <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_OvaryAdenoCA <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_OvaryAdenoCA)
sortedM_OvaryAdenoCA
```

```{r OvaryAdenoCA3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_OvaryAdenoCA$Y)-1

sortedDM_OvaryAdenoCA <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_OvaryAdenoCA,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_OvaryAdenoCA$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_OvaryAdenoCA$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_OvaryAdenoCA$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_OvaryAdenoCA$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_OvaryAdenoCA
```


If we use the values of the fullRE M exo as initial values for the fullRE DMSL exo do not yet converge:
```{r OvaryAdenoCA3b, echo=FALSE, message=FALSE, dependson=c('OvaryAdenoCA3')}
sortedDM_OvaryAdenoCA$pdHess

```


\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures. There doesn't seem to be.
```{r, OvaryAdenoCA1d}
colSums(obj_Ovary_AdenoCA$Y == 0)/nrow(obj_Ovary_AdenoCA$Y)
colSums(obj_Ovary_AdenoCA$Y)/sum(obj_Ovary_AdenoCA$Y)
```


\subsubsection{Betas}

```{r, OvaryAdenoCA_betas}
ct <- "Ovary-AdenoCA"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(sortedDM_OvaryAdenoCA)+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```


```{r, OvaryAdenoCA_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Ovary-AdenoCA"
pval_Ovary_AdenoCA <- wald_TMB_wrapper(diagRE_DMSL_nonexo[[ct]])
```

We use the results from the diag RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Ovary_AdenoCA`.

\subsubsection{Covariance matrices}

Keep in mind that fullRE DMSL nonexo has not converged.
```{r, OvaryAdenoCA_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Ovary_AdenoCA_additional_runs')}
ct <- "Ovary-AdenoCA"
# models_it_Ovary_AdenoCA <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Ovary_AdenoCA <- c('fullRE_M_nonexo')
covmats_Ovary_AdenoCA <- lapply(models_it_Ovary_AdenoCA,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Ovary_AdenoCA) <- models_it_Ovary_AdenoCA
## because it's fullRE_M, it's sorted
# colnames(covmats_Ovary_AdenoCA[['fullRE_M']]) <- rownames(covmats_Ovary_AdenoCA[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Ovary_AdenoCA)$Y))
colnames(covmats_Ovary_AdenoCA[['fullRE_M_nonexo']]) <- rownames(covmats_Ovary_AdenoCA[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Ovary_AdenoCA, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Ovary_AdenoCA)){pheatmap(covmats_Ovary_AdenoCA[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Ovary_AdenoCA[i])}
```


\subsubsection{Simulation under inferred data}
Using diagRE DMSL nonexo.

```{r, OvaryAdenoCA_sim, echo=FALSE}
sim_Ovary_AdenoCA <- give_sim_from_estimates("Ovary-AdenoCA", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="diagRE_DMSL", bool_nonexo = F,
                                       tmb_object=diagRE_DMSL_nonexo[[ct]])
sim_Ovary_AdenoCA[[2]]+ggtitle('Simulation of Ovary-AdenoCA samples')

```

\subsubsection{Ranked plot for coverage}

```{r, OvaryAdenoCA_ranked_plot}
ct <- "Ovary-AdenoCA"
integer_overdispersion_param_DMSL <- 1
obj_Ovary_AdenoCA_nonexo <- give_subset_sigs_TMBobj(obj_Ovary_AdenoCA, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Ovary_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Ovary_AdenoCA_nonexo,
                 loglog = F, title = 'obj_Ovary_AdenoCA (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                 data_object = obj_Ovary_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Ovary_AdenoCA_nonexo,
           loglog = F, title = 'obj_Ovary_AdenoCA (DMSL)'), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, OvaryAdenoCA_mutsigextractor}
obj_Ovary_AdenoCA_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Ovary_AdenoCA_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.
```{r, OvaryAdenoCA_sortedbynummuts, fig.height=2, fig.width=6}
createBarplot(normalise_rw(non_duplicated_rows(obj_Ovary_AdenoCA$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Ovary_AdenoCA$Y)),
                                        decreasing = F)))
```


\subsection{Panc-AdenoCA}
\subsubsection{Barplot and general statistics}
```{r PancAdenoCA1, echo=FALSE}
ct <- "Panc-AdenoCA"
obj_Panc_AdenoCA <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Panc_AdenoCA, legend_on = TRUE)
```



The number of samples and signatures is:
```{r PancAdenoCA1b, echo=FALSE}
dim(obj_Panc_AdenoCA$Y)
```

The signatures are:
```{r PancAdenoCA1c, echo=FALSE}
colnames(obj_Panc_AdenoCA$Y)
```

\subsubsection{Convergence table}

These are the results for the convergence of models fits. Most runs have converged. fullRE_DMSL_nonexo hadn't run.

```{r PancAdenoCA2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Panc-AdenoCA"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo. M hasn't converged.
```{r PancAdenoCA3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Panc-AdenoCA"

obj_PancAdenoCA <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_PancAdenoCA <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_PancAdenoCA)
sortedM_PancAdenoCA
```



\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures. SBS17a is potentially problematic.
```{r, PancAdenoCA1d}
colSums(obj_Panc_AdenoCA$Y == 0)/nrow(obj_Panc_AdenoCA$Y)
colSums(obj_Panc_AdenoCA$Y)/sum(obj_Panc_AdenoCA$Y)
```

From the violin plot, none seem too problematic.
```{r, obj_Panc_AdenoCA_remove_small_signatures, fig.height=2}
ggplot(melt(obj_Panc_AdenoCA$Y), aes(x=Var2, y=value+1))+geom_violin()+scale_y_continuous(trans = "log2")
```

\subsubsection{Betas}

```{r, PancAdenoCA_betas}
ct <- "Panc-AdenoCA"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```


```{r, PancAdenoCA_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Panc-AdenoCA"
pval_Panc_AdenoCA <- wald_TMB_wrapper(diagRE_DMSL_nonexo[[ct]])
```

We use the results from the diag RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Panc_AdenoCA`.

\subsubsection{Covariance matrices}

```{r, PancAdenoCA_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Panc_AdenoCA_additional_runs')}
ct <- "Panc-AdenoCA"
# models_it_Panc_AdenoCA <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Panc_AdenoCA <- c('fullRE_M', 'fullRE_M_nonexo')
covmats_Panc_AdenoCA <- lapply(models_it_Panc_AdenoCA,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Panc_AdenoCA) <- models_it_Panc_AdenoCA
## because it's fullRE_M, it's sorted
colnames(covmats_Panc_AdenoCA[['fullRE_M']]) <- rownames(covmats_Panc_AdenoCA[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Panc_AdenoCA)$Y))
colnames(covmats_Panc_AdenoCA[['fullRE_M_nonexo']]) <- rownames(covmats_Panc_AdenoCA[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Panc_AdenoCA, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Panc_AdenoCA)){pheatmap(covmats_Panc_AdenoCA[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Panc_AdenoCA[i])}
```


\subsubsection{Simulation under inferred data}
That's not a good simulation, using diagRE DMSL!

```{r, PancAdenoCA_sim, echo=FALSE}
sim_Panc_AdenoCA <- give_sim_from_estimates("Panc-AdenoCA", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="diagRE_DMSL", bool_nonexo = F,
                                       tmb_object=diagRE_DMSL_nonexo[["Panc-AdenoCA"]])
sim_Panc_AdenoCA[[2]]+ggtitle('Simulation of Panc-AdenoCA samples')

```

Multinomial doesn't look great either
```{r, PancAdenoCA_sim_M, echo=FALSE}
sim_Panc_AdenoCA <- give_sim_from_estimates("Panc-AdenoCA", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_M", bool_nonexo = F,
                                       tmb_object=fullRE_M_nonexo[["Panc-AdenoCA"]])
sim_Panc_AdenoCA[[2]]+ggtitle('Simulation of Panc-AdenoCA samples\nUsing multinomial')

```

\subsubsection{Ranked plot for coverage}

```{r, PancAdenoCA_ranked_plot}
ct <- "Panc-AdenoCA"
integer_overdispersion_param_DMSL <- 1
obj_Panc_AdenoCA_nonexo <- give_subset_sigs_TMBobj(obj_Panc_AdenoCA, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Panc_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Panc_AdenoCA_nonexo,
                 loglog = F, title = 'obj_Panc_AdenoCA (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                 data_object = obj_Panc_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Panc_AdenoCA_nonexo,
           loglog = F, title = 'obj_Panc_AdenoCA (DMSL)'), ncol=2)
```


\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, PancAdenoCA_mutsigextractor}
obj_Panc_AdenoCA_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Panc_AdenoCA_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.
```{r, PancAdenoCA_sortedbynummuts, fig.height=2, fig.width=6}
createBarplot(normalise_rw(non_duplicated_rows(obj_Panc_AdenoCA$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Panc_AdenoCA$Y)),
                                        decreasing = F)))
```


\subsection{Panc-Endocrine}


\subsubsection{Barplot and general statistics}
```{r PancEndocrine1, echo=FALSE}
ct <- "Panc-Endocrine"
obj_Panc_Endocrine <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Panc_Endocrine, legend_on = TRUE)
```



The number of samples and signatures is:
```{r PancEndocrine1b, echo=FALSE}
dim(obj_Panc_Endocrine$Y)
```

The signatures are:
```{r PancEndocrine1c, echo=FALSE}
colnames(obj_Panc_Endocrine$Y)
```


\subsubsection{Convergence table}

These are the results for the convergence of models fits. fullRE_DMSL and fullRE_DMSL_nonexo haven't.

```{r PancEndocrine2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Panc-Endocrine"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo.
```{r PancEndocrine3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Panc-Endocrine"

obj_PancEndocrine <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_PancEndocrine <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_PancEndocrine)
sortedM_PancEndocrine
```

```{r PancEndocrine3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_PancEndocrine$Y)-1

sortedDM_PancEndocrine <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_PancEndocrine,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_PancEndocrine$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_PancEndocrine$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_PancEndocrine$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_PancEndocrine$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_PancEndocrine

```


If we use the values of the fullRE M exo as initial values for the fullRE DMSL exo doesn't converge:
```{r PancEndocrine3b, echo=FALSE, message=FALSE, dependson=c('PancEndocrine3')}
sortedDM_PancEndocrine$pdHess
```

\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures:
```{r, PancEndocrine1d}
colSums(obj_Panc_Endocrine$Y == 0)/nrow(obj_Panc_Endocrine$Y)
colSums(obj_Panc_Endocrine$Y)/sum(obj_Panc_Endocrine$Y)
```


\subsubsection{Betas}

```{r, PancEndocrine_betas}
ct <- "Panc-Endocrine"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(sortedDM_PancEndocrine)+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```



```{r, PancEndocrine_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Panc-Endocrine"
pval_Panc_Endocrine <- wald_TMB_wrapper(diagRE_DMSL_nonexo[[ct]])
```

We use the results from the diag RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Panc_Endocrine`.

\subsubsection{Covariance matrices}

```{r, PancEndocrine_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Panc_Endocrine_additional_runs')}
ct <- "Panc-Endocrine"
# models_it_Panc_Endocrine <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Panc_Endocrine <- c('fullRE_M', 'fullRE_M_nonexo')
covmats_Panc_Endocrine <- lapply(models_it_Panc_Endocrine,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Panc_Endocrine) <- models_it_Panc_Endocrine
## because it's fullRE_M, it's sorted
colnames(covmats_Panc_Endocrine[['fullRE_M']]) <- rownames(covmats_Panc_Endocrine[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Panc_Endocrine)$Y))
colnames(covmats_Panc_Endocrine[['fullRE_M_nonexo']]) <- rownames(covmats_Panc_Endocrine[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Panc_Endocrine, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Panc_Endocrine)){pheatmap(covmats_Panc_Endocrine[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Panc_Endocrine[i])}
```

\subsubsection{Simulation under inferred data}
```{r, PancEndocrine_sim, echo=FALSE}
sim_Panc_Endocrine <- give_sim_from_estimates("Panc-Endocrine", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="diagRE_DMSL", bool_nonexo = F,
                                       tmb_object=diagRE_DMSL_nonexo[[ct]])
sim_Panc_Endocrine[[2]]+ggtitle('Simulation of Panc-Endocrine samples')

```

\subsubsection{Ranked plot for coverage}

```{r, PancEndocrine_ranked_plot}
ct <- "Panc-Endocrine"
integer_overdispersion_param_DMSL <- 1
obj_Panc_Endocrine_nonexo <- give_subset_sigs_TMBobj(obj_Panc_Endocrine, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Panc_Endocrine_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Panc_Endocrine_nonexo,
                 loglog = F, title = 'obj_Panc_Endocrine (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                 data_object = obj_Panc_Endocrine_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Panc_Endocrine_nonexo,
           loglog = F, title = 'obj_Panc_Endocrine (DMSL)'), ncol=2)
```


\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, PancEndocrine_mutsigextractor}
obj_Panc_Endocrine_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Panc_Endocrine_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is a trend with one signature only being present, and in very large amounts, in hyeprmutated samples.
```{r, PancEndocrine_sortedbynummuts, fig.height=2, fig.width=6}
createBarplot(normalise_rw(non_duplicated_rows(obj_Panc_Endocrine$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Panc_Endocrine$Y)),
                                        decreasing = F)))
```


\subsection{Prost-AdenoCA}


\subsubsection{Barplot and general statistics}
```{r ProstAdenoCA1, echo=FALSE}
ct <- "Prost-AdenoCA"
obj_Prost_AdenoCA <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Prost_AdenoCA, legend_on = TRUE)
```



The number of samples and signatures is:
```{r ProstAdenoCA1b, echo=FALSE}
dim(obj_Prost_AdenoCA$Y)
```

The signatures are:
```{r ProstAdenoCA1c, echo=FALSE}
colnames(obj_Prost_AdenoCA$Y)
```


\subsubsection{Convergence table}

These are the results for the convergence of models fits. Most have converged. fullRE_DMSL_nonexo hasn't run and needs to be re-run.

```{r ProstAdenoCA2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Prost-AdenoCA"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo.
```{r ProstAdenoCA3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Prost-AdenoCA"

obj_ProstAdenoCA <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_ProstAdenoCA <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_ProstAdenoCA, use_nlminb=T)
sortedM_ProstAdenoCA
```

But DMSL hasn't:
```{r ProstAdenoCA3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_ProstAdenoCA$Y)-1

sortedDM_ProstAdenoCA <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_ProstAdenoCA,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_ProstAdenoCA$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_ProstAdenoCA$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_ProstAdenoCA$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_ProstAdenoCA$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_ProstAdenoCA

```

```{r ProstAdenoCA3b, echo=FALSE, message=FALSE, dependson=c('ProstAdenoCA3')}
sortedDM_ProstAdenoCA$pdHess
```


\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures. None seem to be, although SBS33 is absent in 60\% of samples.
```{r, ProstAdenoCA1d}
colSums(obj_Prost_AdenoCA$Y == 0)/nrow(obj_Prost_AdenoCA$Y)
colSums(obj_Prost_AdenoCA$Y)/sum(obj_Prost_AdenoCA$Y)
```


\subsubsection{Betas}

```{r, ProstAdenoCA_betas}
ct <- "Prost-AdenoCA"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(sortedDM_ProstAdenoCA)+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```



```{r, ProstAdenoCA_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Prost-AdenoCA"
pval_Prost_AdenoCA <- wald_TMB_wrapper(diagRE_DMSL_nonexo[[ct]])
```

We use the results from the diag RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Prost_AdenoCA`.

\subsubsection{Covariance matrices}

```{r, ProstAdenoCA_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Prost_AdenoCA_additional_runs')}
ct <- "Prost-AdenoCA"
# models_it_Prost_AdenoCA <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Prost_AdenoCA <- c('fullRE_M', 'fullRE_M_nonexo')
covmats_Prost_AdenoCA <- lapply(models_it_Prost_AdenoCA,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Prost_AdenoCA) <- models_it_Prost_AdenoCA
## because it's fullRE_M, it's sorted
colnames(covmats_Prost_AdenoCA[['fullRE_M']]) <- rownames(covmats_Prost_AdenoCA[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Prost_AdenoCA)$Y))
colnames(covmats_Prost_AdenoCA[['fullRE_M_nonexo']]) <- rownames(covmats_Prost_AdenoCA[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Prost_AdenoCA, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Prost_AdenoCA)){pheatmap(covmats_Prost_AdenoCA[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Prost_AdenoCA[i])}
```



\subsubsection{Simulation under inferred data}
It doesn't look great! Both seem quite different
```{r, ProstAdenoCA_sim, echo=FALSE}
sim_Prost_AdenoCA <- give_sim_from_estimates("Prost-AdenoCA", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="diagRE_DMSL", bool_nonexo = F,
                                       tmb_object=diagRE_DMSL_nonexo[[ct]])
sim_Prost_AdenoCA[[2]]+ggtitle('Simulation of Prost-AdenoCA samples')

```

\subsubsection{Ranked plot for coverage}

```{r, ProstAdenoCA_ranked_plot}
ct <- "Prost-AdenoCA"
integer_overdispersion_param_DMSL <- 1
obj_Prost_AdenoCA_nonexo <- give_subset_sigs_TMBobj(obj_Prost_AdenoCA, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Prost_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Prost_AdenoCA_nonexo,
                 loglog = F, title = 'obj_Prost_AdenoCA (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                 data_object = obj_Prost_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Prost_AdenoCA_nonexo,
           loglog = F, title = 'obj_Prost_AdenoCA (DMSL)'), ncol=2)
```


\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, ProstAdenoCA_mutsigextractor}
obj_Prost_AdenoCA_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Prost_AdenoCA_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations, except perhaps SBS3 in the hypermutated ones.
```{r, ProstAdenoCA_sortedbynummuts, fig.height=2, fig.width=6}
createBarplot(normalise_rw(non_duplicated_rows(obj_Prost_AdenoCA$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Prost_AdenoCA$Y)),
                                        decreasing = F)))
```


\subsection{Skin-Melanoma.acral}

\subsubsection{Barplot and general statistics}
```{r SkinMelanomaacral1, echo=FALSE}
ct <- "Skin-Melanoma.acral"
obj_Skin_Melanomaacral <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Skin_Melanomaacral, legend_on = TRUE)
```



The number of samples and signatures is:
```{r SkinMelanomaacral1b, echo=FALSE}
dim(obj_Skin_Melanomaacral$Y)
```

The signatures are:
```{r SkinMelanomaacral1c, echo=FALSE}
colnames(obj_Skin_Melanomaacral$Y)
```


\subsubsection{Convergence table}

These are the results for the convergence of models fits. They have converged even though very clearly we have very few observations and too many parameters. I thought I would have excluded this cancer type? In CT_sufficient_samples.txt it does appear but shouldn't - I don't continue the analyses for this cancer type.

```{r SkinMelanomaacral2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Skin-Melanoma.acral"
melt(all_summaries) %>% filter(value==ct)
```


\subsection{Skin-Melanoma.cutaneous}

\subsubsection{Barplot and general statistics}
```{r SkinMelanomacutaneous1, echo=FALSE}
ct <- "Skin-Melanoma.cutaneous"
obj_Skin_Melanomacutaneous <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Skin_Melanomacutaneous, legend_on = TRUE)
```



The number of samples and signatures is:
```{r SkinMelanomacutaneous1b, echo=FALSE}
dim(obj_Skin_Melanomacutaneous$Y)
```

The signatures are:
```{r SkinMelanomacutaneous1c, echo=FALSE}
colnames(obj_Skin_Melanomacutaneous$Y)
```

\subsubsection{Convergence table}

These are the results for the convergence of models fits. fullRE_DMSL have not converged.

```{r SkinMelanomacutaneous2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Skin-Melanoma.cutaneous"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo.
```{r SkinMelanomacutaneous3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Skin-Melanoma.cutaneous"

obj_SkinMelanomacutaneous <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_SkinMelanomacutaneous <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_SkinMelanomacutaneous)
sortedM_SkinMelanomacutaneous
```


```{r SkinMelanomacutaneous3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_SkinMelanomacutaneous$Y)-1

sortedDM_SkinMelanomacutaneous <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_SkinMelanomacutaneous,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_SkinMelanomacutaneous$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_SkinMelanomacutaneous$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_SkinMelanomacutaneous$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_SkinMelanomacutaneous$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_SkinMelanomacutaneous

```


If we use the values of the fullRE M exo as initial values for the fullRE DMSL exo do converge:
```{r SkinMelanomacutaneous3b, echo=FALSE, message=FALSE, dependson=c('SkinMelanomacutaneous3')}
sortedDM_SkinMelanomacutaneous$pdHess
```

It has converged.


\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures; there are none.
```{r, SkinMelanomacutaneous1d}
colSums(obj_Skin_Melanomacutaneous$Y == 0)/nrow(obj_Skin_Melanomacutaneous$Y)
colSums(obj_Skin_Melanomacutaneous$Y)/sum(obj_Skin_Melanomacutaneous$Y)
```

```{r, Skin_Melanomacutaneous_additional_runs, dependson=c('additional_runs'), echo=FALSE}
additional_sortedMnonexo[["Skin-Melanoma.cutaneous"]] <- sortedM_SkinMelanomacutaneous
additional_sortedDMSLnonexo[["Skin-Melanoma.cutaneous"]] <- sortedDM_SkinMelanomacutaneous
```

\subsubsection{Betas}

```{r, SkinMelanomacutaneous_betas, echo=FALSE}
ct <- "Skin-Melanoma.cutaneous"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(sortedDM_SkinMelanomacutaneous)+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')), nrow=1)
```




```{r, SkinMelanomacutaneous_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Skin-Melanoma.cutaneous"
pval_Skin_Melanomacutaneous <- wald_TMB_wrapper(sortedDM_SkinMelanomacutaneous)
```

We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Skin_Melanomacutaneous`.

\subsubsection{Covariance matrices}
```{r, SkinMelanomacutaneous_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Skin_Melanomacutaneous_additional_runs')}
ct <- "Skin-Melanoma.cutaneous"
# models_it_Skin_Melanomacutaneous <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Skin_Melanomacutaneous <- c('fullRE_M', 'fullRE_M_nonexo', 'additional_sortedDMSLnonexo')
covmats_Skin_Melanomacutaneous <- lapply(models_it_Skin_Melanomacutaneous,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Skin_Melanomacutaneous) <- models_it_Skin_Melanomacutaneous
## because it's fullRE_M, it's sorted
colnames(covmats_Skin_Melanomacutaneous[['fullRE_M']]) <- rownames(covmats_Skin_Melanomacutaneous[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Skin_Melanomacutaneous)$Y))
colnames(covmats_Skin_Melanomacutaneous[['fullRE_M_nonexo']]) <- rownames(covmats_Skin_Melanomacutaneous[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Skin_Melanomacutaneous, nonexogenous$V1)$Y))
colnames(covmats_Skin_Melanomacutaneous[['additional_sortedDMSLnonexo']]) <- rownames(covmats_Skin_Melanomacutaneous[['additional_sortedDMSLnonexo']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(give_subset_sigs_TMBobj(obj_Skin_Melanomacutaneous, nonexogenous$V1))$Y))

for(i in 1:length(covmats_Skin_Melanomacutaneous)){pheatmap(covmats_Skin_Melanomacutaneous[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Skin_Melanomacutaneous[i])}
```



\subsubsection{Simulation under inferred data}
```{r, SkinMelanomacutaneous_sim, echo=FALSE}
sim_Skin_Melanomacutaneous <- give_sim_from_estimates("Skin-Melanoma.cutaneous", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = F,
                                      sig_of_interest='SBS2',
                                       tmb_object=sortedDM_SkinMelanomacutaneous)
sim_Skin_Melanomacutaneous[[2]]+ggtitle('Simulation of Skin-Melanoma.cutaneous samples')

```


\subsubsection{Ranked plot for coverage}

```{r, SkinMelanomacutaneous_ranked_plot}
ct <- "Skin-Melanoma.cutaneous"
integer_overdispersion_param_DMSL <- 1
obj_Skin_Melanomacutaneous_nonexo <- give_subset_sigs_TMBobj(obj_Skin_Melanomacutaneous, sigs_to_remove = nonexogenous$V1)
obj_Skin_Melanomacutaneous_nonexo_sorted <- sort_columns_TMB(give_subset_sigs_TMBobj(obj_Skin_Melanomacutaneous, sigs_to_remove = nonexogenous$V1))
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Skin_Melanomacutaneous_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Skin_Melanomacutaneous_nonexo,
                 loglog = F, title = 'obj_Skin_Melanomacutaneous (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = sortedDM_SkinMelanomacutaneous,
                 data_object = obj_Skin_Melanomacutaneous_nonexo_sorted,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Skin_Melanomacutaneous_nonexo_sorted,
           loglog = F, title = 'obj_Skin_Melanomacutaneous (DMSL)'), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, SkinMelanomacutaneous_mutsigextractor}
obj_Skin_Melanomacutaneous_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Skin_Melanomacutaneous_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: SBS40 is crearly prevalent in samples with few mutations.
```{r, SkinMelanomacutaneous_sortedbynummuts, fig.height=2, fig.width=6}
createBarplot(normalise_rw(non_duplicated_rows(obj_Skin_Melanomacutaneous$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Skin_Melanomacutaneous$Y)),
                                        decreasing = F)))
```



\subsection{Stomach-AdenoCA}

\subsubsection{Barplot and general statistics}
```{r StomachAdenoCA1, echo=FALSE}
ct <- "Stomach-AdenoCA"
obj_Stomach_AdenoCA <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Stomach_AdenoCA, legend_on = TRUE)
```


The number of samples and signatures is:
```{r StomachAdenoCA1b, echo=FALSE}
dim(obj_Stomach_AdenoCA$Y)
```

The signatures are:
```{r StomachAdenoCA1c, echo=FALSE}
colnames(obj_Stomach_AdenoCA$Y)
```


\subsubsection{Convergence table}

These are the results for the convergence of models fits. Besides fullRE_DMSL_nonexo, we have convergence with almost everything.

```{r StomachAdenoCA2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Stomach-AdenoCA"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo, but M hasn't converged. We should include fewer signatures.
```{r StomachAdenoCA3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Stomach-AdenoCA"

obj_StomachAdenoCA <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_StomachAdenoCA <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_StomachAdenoCA,
                           use_nlminb=T)
sortedM_StomachAdenoCA
```


\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures:
```{r, StomachAdenoCA1d}
colSums(obj_Stomach_AdenoCA$Y == 0)/nrow(obj_Stomach_AdenoCA$Y)
colSums(obj_Stomach_AdenoCA$Y)/sum(obj_Stomach_AdenoCA$Y)
```

```{r, StomachAdenoCA_remove_small_signatures, fig.height=4}
ggplot(melt(obj_Stomach_AdenoCA$Y), aes(x=Var2, y=value+1))+geom_violin()+scale_y_continuous(trans = "log2")+facet_wrap(.~Var2, nrow=2, scales="free_x")
```

- Removing SBS20, SBS26, fullM still hasn't converged
- Removing SBS20, SBS26, SBS9 fullM still hasn't converged
- Removing SBS20, SBS26, SBS9, SBS13 fullM still hasn't converged
- Removing SBS20, SBS26, SBS9, SBS13, SBS44 fullM still hasn't converged

```{r StomachAdenoCA3_subset, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Stomach-AdenoCA"

obj_StomachAdenoCA_subset <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                c(nonexogenous$V1, 'SBS20', 'SBS26', 'SBS9', 'SBS13')))
obj_StomachAdenoCA_subset <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_StomachAdenoCA, use_nlminb=T)
obj_StomachAdenoCA_subset
```

\subsubsection{Betas}

```{r, StomachAdenoCA_betas}
ct <- "Stomach-AdenoCA"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```



```{r, StomachAdenoCA_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Stomach-AdenoCA"
pval_Stomach_AdenoCA <- wald_TMB_wrapper(diagRE_DMSL_nonexo[[ct]])
```

We use the results from the diag RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Stomach_AdenoCA`.

\subsubsection{Covariance matrices}
I do not include this section as I have had to use ony diagonal matrices.

\subsubsection{Simulation under inferred data}
```{r, StomachAdenoCA_sim, echo=FALSE}
sim_Stomach_AdenoCA <- give_sim_from_estimates("Stomach-AdenoCA", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="diagRE_DMSL", bool_nonexo = F,
                                      sig_of_interest="SBS2",
                                       tmb_object=diagRE_DMSL_nonexo[["Stomach-AdenoCA"]])
sim_Stomach_AdenoCA[[2]]+ggtitle('Simulation of Stomach-AdenoCA samples')

```
\subsubsection{Ranked plot for coverage}
Comparing for now only diagRE_DMSL_nonexo and sparse for nonexo. It doesn't look good.

```{r, StomachAdenoCA_ranked_plot}
ct <- "Stomach-AdenoCA"
integer_overdispersion_param_DMSL <- 1
obj_Stomach_AdenoCA_nonexo <- sort_columns_TMB(give_subset_sigs_TMBobj(obj_Stomach_AdenoCA, sigs_to_remove = nonexogenous$V1))
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = sparseRE_DMSL_nonexo[[ct]], integer_overdispersion_param=1,
                 data_object = obj_Stomach_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Stomach_AdenoCA_nonexo,
                 loglog = F, title = 'obj_Stomach_AdenoCA (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                 data_object = obj_Stomach_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Stomach_AdenoCA_nonexo,
           loglog = F, title = 'obj_Stomach_AdenoCA (DMSL)'), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, StomachAdenoCA_mutsigextractor}
obj_Stomach_AdenoCA_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Stomach_AdenoCA_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is no clear trend of signatures being associated with the number of mutations.
```{r, StomachAdenoCA_sortedbynummuts, fig.height=2, fig.width=6}
createBarplot(normalise_rw(non_duplicated_rows(obj_Stomach_AdenoCA$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Stomach_AdenoCA$Y)),
                                        decreasing = F)))
```



\subsection{Thy-AdenoCA}


\subsubsection{Barplot and general statistics}
```{r ThyAdenoCA1, echo=FALSE}
ct <- "Thy-AdenoCA"
obj_Thy_AdenoCA <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Thy_AdenoCA, legend_on = TRUE)
```



The number of samples and signatures is:
```{r ThyAdenoCA1b, echo=FALSE}
dim(obj_Thy_AdenoCA$Y)
```

The signatures are:
```{r ThyAdenoCA1c, echo=FALSE}
colnames(obj_Thy_AdenoCA$Y)
```


\subsubsection{Convergence table}

These are the results for the convergence of models fits. Practically everything timed-out.

```{r ThyAdenoCA2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Thy-AdenoCA"
melt(all_summaries) %>% filter(value==ct)
```



\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo.
```{r ThyAdenoCA3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Thy-AdenoCA"

obj_ThyAdenoCA <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_ThyAdenoCA <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_ThyAdenoCA, use_nlminb=T)
sortedM_ThyAdenoCA
```


```{r ThyAdenoCA3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_ThyAdenoCA$Y)-1

sortedDM_ThyAdenoCA <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_ThyAdenoCA,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_ThyAdenoCA$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_ThyAdenoCA$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_ThyAdenoCA$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_ThyAdenoCA$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_ThyAdenoCA
```


If we use the values of the fullRE M exo as initial values for the fullRE DMSL exo do not converge, even though there aren't many signatures:
```{r ThyAdenoCA3b, echo=FALSE, message=FALSE, dependson=c('ThyAdenoCA3')}
sortedDM_ThyAdenoCA$pdHess

```



\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures:
```{r, ThyAdenoCA1d}
colSums(obj_Thy_AdenoCA$Y == 0)/nrow(obj_Thy_AdenoCA$Y)
colSums(obj_Thy_AdenoCA$Y)/sum(obj_Thy_AdenoCA$Y)
```

```{r, Thy_AdenoCAL_remove_small_signatures, fig.height=2}
ggplot(melt(obj_Thy_AdenoCA$Y), aes(x=Var2, y=value+1))+geom_violin()+scale_y_continuous(trans = "log2")
```


\subsubsection{Betas}

```{r, ThyAdenoCA_betas}
ct <- "Thy-AdenoCA"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(sortedM_ThyAdenoCA)+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(sortedDM_ThyAdenoCA)+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```



```{r, ThyAdenoCA_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Thy-AdenoCA"
pval_Thy_AdenoCA <- wald_TMB_wrapper(diagRE_DMSL_nonexo[[ct]])
```

We use the results from the diag RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Thy_AdenoCA`.

\subsubsection{Covariance matrices}
I do not include those.



\subsubsection{Simulation under inferred data}
```{r, ThyAdenoCA_sim, echo=FALSE}
sim_Thy_AdenoCA <- give_sim_from_estimates("Thy-AdenoCA", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="diagRE_DMSL", bool_nonexo = F,
                                       tmb_object=diagRE_DMSL_nonexo[[ct]])
sim_Thy_AdenoCA[[2]]+ggtitle('Simulation of Thy-AdenoCA samples')

```


\subsubsection{Ranked plot for coverage}

```{r, ThyAdenoCA_ranked_plot}
ct <- "Thy-AdenoCA"
integer_overdispersion_param_DMSL <- 1
obj_Thy_AdenoCA_nonexo <- give_subset_sigs_TMBobj(obj_Thy_AdenoCA, sigs_to_remove = nonexogenous$V1)
obj_Thy_AdenoCA_nonexo_sorted <- sort_columns_TMB(give_subset_sigs_TMBobj(obj_Thy_AdenoCA, sigs_to_remove = nonexogenous$V1))
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = sortedM_ThyAdenoCA,
                 data_object = obj_Thy_AdenoCA_nonexo_sorted,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Thy_AdenoCA_nonexo_sorted,
                 loglog = F, title = 'obj_Thy_AdenoCA (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                 data_object = obj_Thy_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Thy_AdenoCA_nonexo,
           loglog = F, title = 'obj_Thy_AdenoCA (DMSL)'), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, ThyAdenoCA_mutsigextractor}
obj_Thy_AdenoCA_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Thy_AdenoCA_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.
```{r, ThyAdenoCA_sortedbynummuts, fig.height=2, fig.width=6}
createBarplot(normalise_rw(non_duplicated_rows(obj_Thy_AdenoCA$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Thy_AdenoCA$Y)),
                                        decreasing = F)))
```

\subsection{Uterus-AdenoCA}

\subsubsection{Barplot and general statistics}
```{r Uterus-AdenoCA1, echo=FALSE}
ct <- "Uterus-AdenoCA"
obj_Uterus_AdenoCA <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Uterus_AdenoCA, legend_on = TRUE)
```



The number of samples and signatures is:
```{r Uterus-AdenoCA1b, echo=FALSE}
dim(obj_Uterus_AdenoCA$Y)
```

The signatures are:
```{r Uterus-AdenoCA1c, echo=FALSE}
colnames(obj_Uterus_AdenoCA$Y)
```


\subsubsection{Convergence table}

These are the results for the convergence of models fits. Almost everything has converged.

```{r Uterus-AdenoCA2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Uterus-AdenoCA"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo.
```{r UterusAdenoCA3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Uterus-AdenoCA"

obj_UterusAdenoCA <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_UterusAdenoCA <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_UterusAdenoCA)
sortedM_UterusAdenoCA
```


```{r UterusAdenoCA3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_UterusAdenoCA$Y)-1

sortedDM_UterusAdenoCA <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_UterusAdenoCA,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_UterusAdenoCA$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_UterusAdenoCA$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_UterusAdenoCA$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_UterusAdenoCA$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_UterusAdenoCA

```

If we use the values of the fullRE M exo as initial values for the fullRE DMSL exo doesn't converge:
```{r UterusAdenoCA3b, echo=FALSE, message=FALSE, dependson=c('UterusAdenoCA3')}
sortedDM_UterusAdenoCA$pdHess
```

\subsubsection{Potentially problematic signatures}

We explore whether there are problematic signatures:
```{r, UterusAdenoCA1d}
colSums(obj_Uterus_AdenoCA$Y == 0)/nrow(obj_Uterus_AdenoCA$Y)
colSums(obj_Uterus_AdenoCA$Y)/sum(obj_Uterus_AdenoCA$Y)
```


\subsubsection{Betas}

```{r, UterusAdenoCA_betas}
ct <- "Uterus-AdenoCA"

grid.arrange(plot_betas(fullRE_M[[ct]])+ggtitle(paste0(ct, '\n fullRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(sortedDM_UterusAdenoCA)+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```



```{r, UterusAdenoCA_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Uterus-AdenoCA"
pval_Uterus_AdenoCA <- wald_TMB_wrapper(diagRE_DMSL_nonexo[[ct]])
```

We use the results from the diag RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Uterus_AdenoCA`.

\subsubsection{Covariance matrices}

```{r, UterusAdenoCA_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Uterus_AdenoCA_additional_runs')}
ct <- "Uterus-AdenoCA"
# models_it_Uterus_AdenoCA <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Uterus_AdenoCA <- c('fullRE_M', 'fullRE_M_nonexo')
covmats_Uterus_AdenoCA <- lapply(models_it_Uterus_AdenoCA,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Uterus_AdenoCA) <- models_it_Uterus_AdenoCA
## because it's fullRE_M, it's sorted
colnames(covmats_Uterus_AdenoCA[['fullRE_M']]) <- rownames(covmats_Uterus_AdenoCA[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Uterus_AdenoCA)$Y))
colnames(covmats_Uterus_AdenoCA[['fullRE_M_nonexo']]) <- rownames(covmats_Uterus_AdenoCA[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Uterus_AdenoCA, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Uterus_AdenoCA)){pheatmap(covmats_Uterus_AdenoCA[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Uterus_AdenoCA[i])}
```



\subsubsection{Simulation under inferred data}
```{r, UterusAdenoCA_sim, echo=FALSE}
sim_Uterus_AdenoCA <- give_sim_from_estimates("Uterus-AdenoCA", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="diagRE_DMSL", bool_nonexo = F,
                                      sig_of_interest='SBS6',
                                       tmb_object=diagRE_DMSL_nonexo[["Uterus-AdenoCA"]])
sim_Uterus_AdenoCA[[2]]+ggtitle('Simulation of Uterus-AdenoCA samples')

```


\subsubsection{Ranked plot for coverage}

```{r, UterusAdenoCA_ranked_plot}
ct <- "Uterus-AdenoCA"
integer_overdispersion_param_DMSL <- 1
obj_Uterus_AdenoCA_nonexo <- give_subset_sigs_TMBobj(obj_Uterus_AdenoCA, sigs_to_remove = nonexogenous$V1)
obj_Uterus_AdenoCA_nonexo_sorted <- sort_columns_TMB(give_subset_sigs_TMBobj(obj_Uterus_AdenoCA, sigs_to_remove = nonexogenous$V1))
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Uterus_AdenoCA_nonexo_sorted,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Uterus_AdenoCA_nonexo,
                 loglog = F, title = 'obj_Uterus_AdenoCA (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                 data_object = obj_Uterus_AdenoCA_nonexo_sorted,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Uterus_AdenoCA_nonexo,
           loglog = F, title = 'obj_Uterus_AdenoCA (DMSL)'), ncol=2)
```


\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, UterusAdenoCA_mutsigextractor}
obj_Uterus_AdenoCA_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Uterus_AdenoCA_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is a trend of hypermutated samples being very chaotic.
```{r, UterusAdenoCA_sortedbynummuts, fig.height=2, fig.width=6}
createBarplot(normalise_rw(non_duplicated_rows(obj_Uterus_AdenoCA$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Uterus_AdenoCA$Y)),
                                        decreasing = F)))
```


\section{All p-values for non-exogenous signatures}

```{r, all_pvals_improved, echo=FALSE, results='asis'}
all_pvals <- rbind.data.frame(cbind.data.frame(ct='Bone-Osteosarc', pvalue=pval_bone_osteosarc, model='diagRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Breast-AdenoCA', pvalue=pval_Breast_AdenoCA, model='diagRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Cervix-SCC', pvalue=pval_Cervix_SCC, model='fullRE_DMSL_nonexo') ,
                              cbind.data.frame(ct='CNS-Oligo', pvalue=pval_CNS_Oligo, model='fullRE_DMSL_nonexo')
                              )

xtable::print.xtable(xtable::xtable(all_pvals), digits=c(0,10,0))

```


\section{Dirichlet-Multinomial Mixtures}

We run the software \verb|MicrobeDMMv1.0| to determine whether we are facing DMM mixtures or not.

We save the files in two ways: all of the samples - early or not - together, and separately.

In some cases DMM says that there is an error with the input file - in this case the AIC or BIC is not plotted. If all of them are missing, all BIC and AIC are set to zero.


```{r, save_files_dmm, echo=FALSE}

roo_obj <- sapply(fles_roo[grepl('_signatures_', fles_roo)], readRDS)
for(i in 1:length(roo_obj)){
  if(!rlang::is_empty(attr(roo_obj[[i]], "count_matrices_active")[[1]])){
    write.table(cbind.data.frame(c('Taxa', colnames(attr(roo_obj[[i]], "count_matrices_active")[[1]])),
                                 rbind.data.frame(rownames(attr(roo_obj[[i]],
                                                                "count_matrices_active")[[1]]),
                                                  round(t(attr(roo_obj[[i]], "count_matrices_active")[[1]])))),
                file = paste0("../../data/roo_for_DMM/", gsub("_ROO.RDS", "", basename(names(roo_obj)))[i], "_early.csv"), sep = ",", row.names = FALSE, col.names = FALSE, quote = FALSE)
    
    write.table(cbind.data.frame(c('Taxa', colnames(attr(roo_obj[[i]], "count_matrices_active")[[2]])),
                                 rbind.data.frame(rownames(attr(roo_obj[[i]],
                                                                "count_matrices_active")[[2]]),
                                                  round(t(attr(roo_obj[[i]], "count_matrices_active")[[2]])))),
                file = paste0("../../data/roo_for_DMM/", gsub("_ROO.RDS", "", basename(names(roo_obj)))[i], "_late.csv"), sep = ",", row.names = FALSE, col.names = FALSE, quote = FALSE)
    
    ## write all
      write.table(cbind.data.frame(c('Taxa', colnames(attr(roo_obj[[i]], "count_matrices_active")[[1]])),
         rbind.data.frame(c(paste0(rownames(attr(roo_obj[[i]],
                                                 "count_matrices_active")[[1]]), '-early'),
                            paste0(rownames(attr(roo_obj[[i]],
                                                 "count_matrices_active")[[2]]), '-late')),
                          round(cbind.data.frame(t(attr(roo_obj[[i]],
                                                        "count_matrices_active")[[1]]),
                                                 t(attr(roo_obj[[i]],
                                                        "count_matrices_active")[[2]]))))),
         file = paste0("../../data/roo_for_DMM/",
                       gsub("_ROO.RDS", "", basename(names(roo_obj)))[i], "_all.csv"),
         sep = ",", row.names = FALSE, col.names = FALSE, quote = FALSE)
              
  }  
}

```
<!-- (base) FVFXDASHHV29:roo_for_DMM morril01$ pwd -->
<!-- /Users/morril01/Documents/PhD/GlobalDA/data/roo_for_DMM -->
<!-- (base) FVFXDASHHV29:roo_for_DMM morril01$ cat run.sh  -->
<!-- /Users/morril01/software/MicrobeDMMv1.0/DirichletMixtureGHPFit -in Biliary-AdenoCA_signatures_early.csv -out Biliary-AdenoCA_signatures_early_DMM -k 4 -->


```{r, analyse_files_dmm, echo=FALSE, warning=FALSE, message=FALSE, results='hide'}
z_DMM <- lapply(enough_samples, function(ct){
  list(all=lapply(1:8, function(k) try(read.table(paste0("../../data/roo_for_DMM/DMM_output/", ct, "_signatures_all", k, "_dmm.z"), sep = ',', skip = 1))),
       early=lapply(1:8, function(k) try(read.table(paste0("../../data/roo_for_DMM/DMM_output/", ct, "_signatures_early", k, "_dmm.z"), sep = ',', skip = 1))),
       late=lapply(1:8, function(k) try(read.table(paste0("../../data/roo_for_DMM/DMM_output/", ct, "_signatures_late", k, "_dmm.z"), sep = ',', skip = 1))))
})
names(z_DMM) <- enough_samples

# (# of clusters) Evidence, Negative Log Determinant, Laplace Approximation, BIC and AIC are also sent to stdout at the end and written to a file stub.fit.
fit_DMM <- lapply(enough_samples, function(ct){
  list(all=lapply(1:8, function(k) try(read.table(paste0("../../data/roo_for_DMM/DMM_output/", ct, "_signatures_all", k, "_dmm.fit"), sep = ' '))),
       early=lapply(1:8, function(k) try(read.table(paste0("../../data/roo_for_DMM/DMM_output/", ct, "_signatures_early", k, "_dmm.fit"), sep = ' '))),
       late=lapply(1:8, function(k) try(read.table(paste0("../../data/roo_for_DMM/DMM_output/", ct, "_signatures_late", k, "_dmm.fit"), sep = ' '))))
})
names(fit_DMM) <- enough_samples
```

```{r, some_functions, echo=FALSE}
na_to_zero <- function(i) if(all(is.na(i))){i[is.na(i)] = 0; i}else{i}
```


```{r, analyse_files_dmm_find_k, fig.height=1.5, echo=FALSE, message=FALSE}

# (# of clusters) Evidence, Negative Log Determinant, Laplace Approximation, BIC and AIC are also sent to stdout at the end and written to a file stub.fit.

par(mfrow=c(1,6), mar=c(1.8, 1.8, 1.8, 1.8))
invisible(sapply(names(fit_DMM), function(j_name){
  j=fit_DMM[[j_name]]
  plot(1:8, na_to_zero(sapply(j$all, function(jj) if(! (typeof(jj) == "character")){jj[4]}else{NA})), xlab='k', ylab='BIC', main=j_name)
  plot(1:8, na_to_zero(sapply(j$all, function(jj) if(! (typeof(jj) == "character")){jj[5]}else{NA})), xlab='k', ylab='AIC', main=j_name)
  plot(1:8, na_to_zero(sapply(j$early, function(jj) if(! (typeof(jj) == "character")){jj[4]}else{NA})), xlab='k', ylab='BIC', main=j_name)
  plot(1:8, na_to_zero(sapply(j$early, function(jj) if(! (typeof(jj) == "character")){jj[5]}else{NA})), xlab='k', ylab='AIC', main=j_name)
  plot(1:8, na_to_zero(sapply(j$late, function(jj) if(! (typeof(jj) == "character")){jj[4]}else{NA})), xlab='k', ylab='BIC', main=j_name)
  plot(1:8, na_to_zero(sapply(j$late, function(jj) if(! (typeof(jj) == "character")){jj[5]}else{NA})), xlab='k', ylab='AIC', main=j_name)
}))

j=fit_DMM[[1]]

# z_DMM$`CNS-GBM`$all

# z_DMM$`Bone-Osteosarc`

# xxxx <- try(read.table(paste0("../../data/roo_for_DMM/DMM_output/", ct, "_signatures_all.z"), sep = ',', skip = 1))

# table(apply(xxxx[grepl('_early', xxxx$V1),-1], 1, which.max),
#       apply(xxxx[grepl('_late', xxxx$V1),-1], 1, which.max))

```


\newpage

## Comparison of signature exposures with QP and mutsigextractor
```{r, to_del}
signature_mutsigextractor_roo2 <- sapply(fles_roo[grepl('_signaturesmutSigExtractor_', fles_roo)], readRDS)
roo_obj2 <- roo_obj
names(signature_mutsigextractor_roo2) <- gsub("_signaturesmutSigExtractor_ROO.RDS", "", basename(names(signature_mutsigextractor_roo2)))
names(roo_obj2) <- gsub("_signatures_ROO.RDS", "", basename(names(roo_obj2)))
```

```{r, comparison_signatures_mutextractor, eval=TRUE}

par(mfrow=c(2,3))
for(i in names(roo_obj2)){
  try({

  sig1 <- roo_obj2[[i]]
  sig2 <- signature_mutsigextractor_roo2[[i]]

  sig1 <- do.call('rbind', sig1@count_matrices_active)
  sig2 <- do.call('rbind', sig2@count_matrices_all)

  sig2 <- as.vector(sig2[,match(colnames(sig1), colnames(sig2))])
  sig1 <- as.vector(sig1)
  plot(sig1, sig2)
  })
}
```

```{r, all_pvals_2}
cbind.data.frame(pvals_fullRE_M=pvals_fullRE_M,
                 pvals_diagRE_DM=pvals_diagRE_DM,
                 pvals_DM=pvals_DM,
                 pvals_DMnonexo=pvals_DMnonexo)

```