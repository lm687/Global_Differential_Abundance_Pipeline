---
title: "Summary of TMB runs"
author: "Lena Morrill"
date: "24/05/2021"
output: pdf_document
header-includes:
   - \usepackage{array}
   - \setlength{\textwidth}{6.7in}
   - \setlength{\oddsidemargin}{-0.1in}
   - \setlength{\textheight}{8.6in}
   - \setlength{\topmargin}{-0.4in}
   - \newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
   - \newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
   - \newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache=TRUE)
```

```{r libraries, echo=FALSE, message=FALSE, cache=TRUE, results='hide'}

library(Ternary)
library(MCMCpack)
library(TMB)
library(dplyr)
library(parallel)
library(umap)
library(gridExtra)
library(pheatmap)
library(ggplot2)
library(ggrepel)
library(RColorBrewer)

source("../2_inference_TMB/helper_TMB.R")
source("../../../CDA_in_Cancer/code/functions/meretricious/pretty_plots/prettySignatures.R")

TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda2.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda2"))
TMB::compile("../2_inference_TMB/mm_multinomial/diagRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/diagRE_dirichletmultinomial_single_lambda"))
TMB::compile("../2_inference_TMB/mm_multinomial/diagRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/diagRE_ME_dirichletmultinomial"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda2.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda2"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial_singlecov.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial_singlecov"))
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_halfdirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_halfdirichletmultinomial"))
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_dirichletmultinomial"))
TMB::compile("../2_inference_TMB/mm_multinomial/diagRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/diagRE_ME_dirichletmultinomial"))
TMB::compile("../2_inference_TMB/mm_multinomial/diagRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/diagRE_ME_multinomial"))
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))


```

```{r,, load_functions, cache=FALSE}

source("../2_inference_TMB/helper_TMB.R")
source("../../../CDA_in_Cancer/code/functions/meretricious/pretty_plots/prettySignatures.R")

```

```{r, read_ct, echo=FALSE}
enough_samples = read.table("../../data/restricted/pcawg/CT_sufficient_samples.txt", comment.char='#')[,1]
nonexogenous = read.table("../../data/cosmic/exogenous_signatures_SBS.txt", sep = "\t",
                          comment.char = "#", fill = F)
subset_sigs_sparse_cov_idx_nonexo <- read.table("../../current/subset_sigs_sparse_cov_idx_nonexo.txt", stringsAsFactors = F, fill = T)
fles_roo <- list.files("../../data/roo/", full.names = T)

```

```{r, dimensionality_reduction, echo=FALSE}
signature_roo <- sapply(fles_roo[grepl('_signatures_', fles_roo)], readRDS)
signature_mutsigextractor_roo <- sapply(fles_roo[grepl('_signaturesmutSigExtractor_', fles_roo)], readRDS)

signature_roo <- sapply(signature_roo, function(i) try(slot(i, 'count_matrices_all')))
names(signature_roo) <- gsub("_signatures_ROO.RDS", "", basename(fles_roo[grepl('_signatures_', fles_roo)]))
signature_roo <- signature_roo[match(enough_samples, names(signature_roo))]
signature_roo <- signature_roo[sapply(signature_roo, typeof) == "list"]

signature_mutsigextractor_roo <- sapply(signature_mutsigextractor_roo, function(i) try(slot(i, 'count_matrices_all')))
names(signature_mutsigextractor_roo) <- gsub("_signaturesmutSigExtractor_ROO.RDS", "", basename(fles_roo[grepl('_signaturesmutSigExtractor_', fles_roo)]))
signature_mutsigextractor_roo <- signature_mutsigextractor_roo[match(enough_samples, names(signature_mutsigextractor_roo))]
signature_mutsigextractor_roo <- signature_mutsigextractor_roo[sapply(signature_mutsigextractor_roo, typeof) == "list"]


signature_roo_all <- do.call('rbind', lapply(signature_roo, function(i) rbind(i[[1]], i[[2]])))
signature_roo_all <- normalise_rw(signature_roo_all)
signature_roo_all_umap <- umap(signature_roo_all)

signature_roo_all_mutsigextractor <- do.call('rbind', lapply(signature_mutsigextractor_roo, function(i) rbind(i[[1]], i[[2]])))
signature_roo_all_mutsigextractor <- normalise_rw(signature_roo_all_mutsigextractor)
signature_roo_all_mutsigextractor_umap <- umap(signature_roo_all_mutsigextractor)


n <- length(signature_roo)
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
names(col_vector) = names(signature_roo)

ggplot(cbind.data.frame(umap=signature_roo_all_umap$layout[,1:2], ct=rep(names(signature_roo), unlist(sapply(signature_roo, function(i) nrow(i[[1]])*2)))),
     aes(x=umap.1, y=umap.2, col=ct))+facet_wrap(.~ct)+
  geom_point(data=do.call('rbind', lapply(names(signature_roo), function(i) cbind.data.frame(umap=signature_roo_all_umap$layout[,1:2], ct=i))),
             col='gray', alpha=0.2)+
  geom_point()+
  scale_color_manual(values = col_vector)+guides(col=FALSE)+theme_bw()+labs(x='UMAP dimension #1',
                                                                            y='UMAP dimension #2')
# ggsave("../../../results/exploratory/umap_exposures.pdf", height = 9, width = 9)


ggplot(cbind.data.frame(umap=signature_roo_all_mutsigextractor_umap$layout[,1:2], ct=rep(names(signature_mutsigextractor_roo), unlist(sapply(signature_mutsigextractor_roo, function(i) nrow(i[[1]])*2)))),
       aes(x=umap.1, y=umap.2, col=ct))+facet_wrap(.~ct)+
  geom_point(data=do.call('rbind', lapply(names(signature_mutsigextractor_roo), function(i) cbind.data.frame(umap=signature_roo_all_mutsigextractor_umap$layout[,1:2], ct=i))),
             col='gray', alpha=0.2)+
  geom_point()+
  scale_color_manual(values = col_vector)+guides(col=FALSE)+theme_bw()+labs(x='UMAP dimension #1',
                                                                            y='UMAP dimension #2')
# ggsave("../../../results/exploratory/umap_exposures_mutsigextractor.pdf", height = 9, width = 9)

```

```{r, read_tmb_runs, warning=FALSE, echo=FALSE, message=FALSE, error=FALSE, results='hide'}
diagRE_DMSL <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/diagRE_DMSL_", ct, "_signatures.RDS")))
}, simplify = F)

diagRE_DMDL <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/optim/diagRE_DM_", ct, "_signatures.RDS")))
}, simplify = F)

fullRE_DMDL <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/optim/fullRE_DM_", ct, "_signatures.RDS")))
}, simplify = F)

fullRE_M_nonexo <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullRE_nonexo_M_", ct, "_signatures.RDS")))
}, simplify = F)

fullRE_M <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/optim/fullRE_M_", ct, "_signatures.RDS")))
}, simplify = F)

diagRE_M <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/optim/diagRE_M_", ct, "_signatures.RDS")))
}, simplify = F)

sparseRE_DMSL <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/sparseRE_DMSL2_", ct, "_signatures.RDS")))
}, simplify = F)

fullRE_DMDL_nonexo <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fulLRE_nonexo_DM_", ct, "_signatures.RDS")))
}, simplify = F)

fullRE_DMDL_sortednonexo <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fulLRE_sortednonexo_DM_", ct, "_signatures.RDS")))
}, simplify = F)

fullRE_DMSL_nonexo <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullRE_nonexo_DMSL_", ct, "_signatures.RDS")))
}, simplify = F)

diagRE_DMSL_nonexo <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/diagRE_nonexo_DMSL_", ct, "_signatures.RDS")))
}, simplify = F)

fullRE_DMSL_SBS1 <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullRE_SBS1baseline_DMSL_", ct, "signatures.RDS")))
}, simplify = F)

fullRE_halfDM <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullRE_halfDM_", ct, "signatures.RDS")))
}, simplify = F)

fullRE_DMSL <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullRE_DMSL_", ct, "_signatures.RDS")))
}, simplify = F)

diagRE_DMSL <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/diagRE_DMSL_", ct, "_signatures.RDS")))
}, simplify = F)

sparseRE_DMSL_nonexo <- sapply(enough_samples, function(ct){
  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/sparseRE_nonexo_DMSL_", ct, "_signatures.RDS")))
}, simplify = F)

```

\tableofcontents

\newpage

\section{Information about models}

\subsection{Default order of categories for each model}
\begin{tabular}{llL{1in}l}
Name model & Extension & Sorted & File in which they were created\\\hline\hline
\verb|fullREDMsinglelambda| &	\verb|fullRE_DMSL_|	& Not sorted &	\verb|run_TMB_PCAWG.R|\\\hline
\verb|fullREDMsinglelambda2|	& \verb|fullRE_DMSL2_|	& Sorted	& \verb|run_TMB_PCAWG.R|\\\hline
\verb|diagREDMsinglelambda| & 	\verb|diagRE_DMSL_|	& Unknown	& \verb|run_TMB_PCAWG.R|\\\hline
\verb|fullRE_M|	& \verb|fullRE_M_| & Sorted in previous version of \verb|wrapper_run_TMB|& \verb|run_TMB_PCAWG.R|\\\hline
\verb|diagRE_DM|	& \verb|diagRE_DM_| & Sorted in previous version of \verb|wrapper_run_TMB|& \verb|run_TMB_PCAWG.R|\\\hline
\verb|fullRE_DM|	& \verb|fullRE_DM_| & Sorted in previous version of \verb|wrapper_run_TMB|& \verb|run_TMB_PCAWG.R|\\\hline
\verb|sparseRE_DMSL2|	& \verb|sparseRE_nonexo_DMSL_| & Sorted & 	\verb|find_subset_signatures.R|\\\hline
\verb|fullREDMsinglelambda| &	\verb|fullRE_nonexo_DMSL_| &	Not sorted &	\verb|find_subset_signatures.R| \\\hline
\verb|fullRE_M| &	\verb|fullRE_nonexo_M_|	& Not sorted &	\verb|find_subset_signatures.R| \\\hline
\verb|diagREDMsinglelambda|	& \verb|diagRE_nonexo_DMSL_| &	Not sorted &	\verb|find_subset_signatures.R| \\\hline
\verb|fullRE_DM| &	\verb|fulLRE_nonexo_DM_| &	Not sorted &	\verb|find_subset_signatures.R| \\\hline
\verb|diagREDMsinglelambda| &	\verb|diagRE_DMSL_| &	Not sorted &	\verb|find_subset_signatures.R|\\\hline
\end{tabular}

\clearpage
\section{General results of all models}
Check the results of all of the models

```{r, summary_convergence, dependson=c('read_tmb_runs'), fig.height=6, echo=FALSE, dependson=c('read_tmb_runs')}
list_models <- c( 'diagRE_M', 'fullRE_M',
                  'diagRE_DMDL','fullRE_halfDM', 'fullRE_DMDL', 
                  'diagRE_DMSL','sparseRE_DMSL', 'fullRE_DMSL', 'fullRE_DMSL_SBS1',
                  'fullRE_M_nonexo','diagRE_DMSL_nonexo','sparseRE_DMSL_nonexo', 'fullRE_DMSL_nonexo',
                  'fullRE_DMDL_nonexo', 'fullRE_DMDL_sortednonexo')

all_summaries <- lapply(lapply(list_models, get), function(i){
    give_summary_of_runs2(i, long_return = T)})
names(all_summaries) <- list_models

ggplot(melt(all_summaries), aes(x=factor(L1, levels=list_models), y=value, fill=L2))+geom_tile()+
  theme(axis.text.x=element_text(angle = 45, hjust = 1, vjust=1))+theme(legend.position = "bottom")+
  labs(x='')

```

\subsection{P-values for all cancer types}

```{r, all_pvals, echo=FALSE, results='hide', warning=FALSE, message=FALSE}
pvals_fullRE_M <- sapply(fullRE_M, function(i) try(wald_TMB_wrapper(i)))
pvals_fullRE_M <- p.adjust(pvals_fullRE_M)
pvals_diagRE_DM <- sapply(diagRE_DMSL, function(i) try(wald_TMB_wrapper(i)))
pvals_diagRE_DM <- p.adjust(pvals_diagRE_DM)
pvals_DM <- sapply(sparseRE_DMSL, function(i) try(wald_TMB_wrapper(i)))
pvals_DM <- p.adjust(pvals_DM)
pvals_DMnonexo <- sapply(sparseRE_DMSL_nonexo, function(i) try(wald_TMB_wrapper(i)))
pvals_DMnonexo <- p.adjust(pvals_DMnonexo)
```

```{r, all_pvals_analysis, echo=FALSE, results='hide', dependson=c('all_pvals')}
num_samples <- sapply(enough_samples, function(ct){
    .xx <- try(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures"),
                                       sigs_to_remove = unique(nonexogenous$V1)))
    try(nrow(.xx$Y)/2)
})

effect_size <- sapply(enough_samples, function(ct){
  .xx <- try(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures"),
                                     sigs_to_remove = unique(nonexogenous$V1)))
  try(sum((normalise_rw(.xx$Y[1:(nrow(.xx$Y)/2),]) - normalise_rw(.xx$Y[(1+nrow(.xx$Y)/2):(nrow(.xx$Y)),]))**2)/(nrow(.xx$Y)/2))
})
```

```{r, all_pvals_analysis_plots, echo=FALSE, dependson=c('all_pvals_analysis'), warning=FALSE, fig.height=4}

grid.arrange(ggplot(cbind.data.frame(pvals_DM=pvals_DM, pvals_DMnonexo=pvals_DMnonexo,
                        num_samples=as.numeric(num_samples),
                        ct=enough_samples),
       aes(x=log(pvals_DM), y=log(pvals_DMnonexo), col=num_samples,
           label=ct))+geom_point()+
  geom_hline(yintercept = log(0.05))+geom_vline(xintercept = log(0.05))+
  geom_label_repel()+theme(legend.position = "bottom"),
ggplot(cbind.data.frame(pvals_DM=pvals_DM, pvals_DMnonexo=pvals_DMnonexo,
                        num_samples=as.numeric(num_samples),
                        ct=enough_samples),
       aes(x=(pvals_DM), y=(pvals_DMnonexo), col=num_samples,
           label=ct))+geom_point()+
  geom_hline(yintercept = (0.05))+geom_vline(xintercept = (0.05))+
  geom_label_repel()+theme(legend.position = "bottom"), ncol=2)

ggplot(cbind.data.frame(effect_size=as.numeric(effect_size),
                        num_samples=as.numeric(num_samples),
                        minlogpval=-log(as.numeric(pvals_DM)),
                        label=enough_samples),
       aes(x=effect_size, y=minlogpval, shape=exp(-minlogpval)<0.05,
           label=label, col=num_samples))+
  geom_point()+geom_label_repel(alpha=0.2)+
  theme(legend.position = "bottom")
# 
# plot(pvals_fullRE_M, pvals_DM)
# 
```

```{r, all_pvals_analysis_plots_2, echo=FALSE, dependson=c('all_pvals_analysis'), warning=FALSE, fig.height=8}

ggplot(cbind.data.frame(pvals_DM=pvals_DM, pvals_DMnonexo=pvals_DMnonexo,
                        num_samples=as.numeric(num_samples),
                        ct=enough_samples,
                        pvals_DM_censored=sapply(-log(pvals_DM),
                                                 function(i) min(i, 25)),
                        pvals_DMnonexo_censored=sapply(-log(pvals_DMnonexo), 
                                                       function(i) min(i, 25))),
       aes(x=pvals_DM_censored, y=pvals_DMnonexo_censored,
           size=num_samples, col=ct,
           label=ct))+geom_point()+
  geom_hline(yintercept = -log(0.05))+geom_vline(xintercept = -log(0.05))+
  geom_label_repel(size=3.2, alpha=0.6)+  theme_bw()+
  theme(legend.position = "bottom", legend.text=element_text(size=8))+
  labs(x='- Log p-value all signatures', y='- Log p-value nonexogenous signatures')+
  guides(size=FALSE, col=guide_legend(ncol=4))

```

\subsection{All betas with SBS1 as baseline}
```{r, SBS1_betas, echo=FALSE, warning=FALSE, message=FALSE, results='hide', fig.height=6}
fullRE_DMSL_SBS1_betas <- lapply(fullRE_DMSL_SBS1, function(i){
  .x <- try(give_betas(i)[2,])
  if((typeof(.x) == 'character')){
    .x <- NA
  }else{
    .sum_i = summary(i)
    .x <- t(python_like_select_rownames(.sum_i, 'beta')[c(F,T),])
  }
  .x
})
for(i in 1:length(fullRE_DMSL_SBS1)){
  if(!(typeof(fullRE_DMSL_SBS1[[i]]) == 'character')){
    .nmes <- colnames(sort_columns_TMB_SBS1(load_PCAWG(ct = enough_samples[i], typedata = "signatures", path_to_data = "../../data/"))$Y)
    colnames(fullRE_DMSL_SBS1_betas[[i]]) = paste0(.nmes[-length(.nmes)], '/', .nmes[length(.nmes)])
      
  }
}

fullRE_DMSL_SBS1_betas_all <- lapply(1:length(fullRE_DMSL_SBS1_betas), function(i) try(data.frame(ct=names(fullRE_DMSL_SBS1_betas[i]), beta=t(fullRE_DMSL_SBS1_betas[[i]]),
                                                                                                               logR=colnames(fullRE_DMSL_SBS1_betas[[i]]))))
fullRE_DMSL_SBS1_betas_all <- do.call('rbind', fullRE_DMSL_SBS1_betas_all[sapply(fullRE_DMSL_SBS1_betas_all, typeof) == 'list'])

# fullRE_DMSL_SBS1_betas_all[!grepl("/SBS1$", fullRE_DMSL_SBS1_betas_all$logR),]
## select only those with SBS1 as baseline
fullRE_DMSL_SBS1_betas_all <- fullRE_DMSL_SBS1_betas_all[grepl("/SBS1$", fullRE_DMSL_SBS1_betas_all$logR),]

fullRE_DMSL_SBS1_betas_all$phHess <- sapply(fullRE_DMSL_SBS1, function(i) try(i$pdHess))[match(fullRE_DMSL_SBS1_betas_all$ct, names(fullRE_DMSL_SBS1))]

```

```{r, SBS1_betas_plots, echo=FALSE, warning=FALSE, message=FALSE, fig.height=10, fig.width=9}

ggplot(fullRE_DMSL_SBS1_betas_all, aes(x=ct, col=logR, y=beta.Estimate))+geom_point()+
  facet_wrap(.~logR, scales = "free_x", nrow=10)+
  geom_errorbar(aes(ymin=`beta.Estimate`-`beta.Std..Error`, ymax=`beta.Estimate`+`beta.Std..Error`), width=.1)+
  geom_hline(yintercept = 0, col='blue', lty='dashed')+
  theme(axis.text.x = element_text(angle = 45, vjust = 1.0, hjust=1), legend.position = "bottom")
```

```{r, SBS1_betas_plotsb, echo=FALSE, warning=FALSE, message=FALSE, fig.height=9, fig.width=9}

sort_with_letters <- function(i){
  .order <- order(as.numeric(gsub("[a-z]", "", i)))
  i[.order]
}

multiple_obs_SBS1_betas <- fullRE_DMSL_SBS1_betas_all %>% dplyr::select(logR) %>% table > 3
ggplot(fullRE_DMSL_SBS1_betas_all %>% filter(logR %in% names(multiple_obs_SBS1_betas[multiple_obs_SBS1_betas])),
       aes(x=ct,
           col=ct, y=beta.Estimate))+geom_point()+
  facet_wrap(.~factor(logR, levels=paste0('SBS', sort_with_letters(unique(gsub('SBS', '', gsub('/.*', '', logR)))), '/SBS1')), scales = "free_x", nrow=4)+
  geom_errorbar(aes(ymin=`beta.Estimate`-`beta.Std..Error`, ymax=`beta.Estimate`+`beta.Std..Error`), width=.1)+
  geom_hline(yintercept = 0, col='blue', lty='dashed')+
  theme_bw()+
  theme(#axis.text.x = element_text(angle = 45, vjust = 1.0, hjust=1),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(), legend.position = "bottom",
        text = element_text(size=20), legend.text=element_text(size=8))
  
ggplot(fullRE_DMSL_SBS1_betas_all %>% filter(logR %in% names(multiple_obs_SBS1_betas[multiple_obs_SBS1_betas])),
       aes(x=ct,
           col=ct, y=beta.Estimate))+geom_point()+
  facet_wrap(.~logR, scales = "free_x", nrow=4)+
  geom_errorbar(aes(ymin=`beta.Estimate`-`beta.Std..Error`, ymax=`beta.Estimate`+`beta.Std..Error`), width=.1)+
  geom_hline(yintercept = 0, col='blue', lty='dashed')+
  theme_bw()+
  theme(#axis.text.x = element_text(angle = 45, vjust = 1.0, hjust=1),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(), legend.position = "bottom",
        text = element_text(size=20), legend.text=element_text(size=8))
  
# ggsave("../../../results/results_TMB/pcawg/all_betas_all_ct.pdf", width = 25, height = 15)
```

```{r, SBS1_betas_plots2, echo=FALSE, warning=FALSE, message=FALSE, fig.height=10, fig.width=8}

fullRE_DMSL_SBS1_betas_all$exogenous = (gsub("/.*", "", fullRE_DMSL_SBS1_betas_all$logR) %in% nonexogenous$V1)
ggplot(fullRE_DMSL_SBS1_betas_all, aes(x=logR, y=beta.Estimate, col=exogenous))+geom_point()+
  facet_wrap(.~ct, scales = "free_x", nrow=5)+
  geom_errorbar(aes(ymin=`beta.Estimate`-`beta.Std..Error`, ymax=`beta.Estimate`+`beta.Std..Error`), width=.1)+
  geom_hline(yintercept = 0, col='blue', lty='dashed')+
  theme(axis.text.x = element_text(angle = 45, vjust = 1.0, hjust=1))
# ggsave("../../../results/results_TMB/pcawg/all_betas_all_ct_byct.pdf", width = 12, height = 12)
```
\newpage


How many signatures so we have in total and how many nonexogenous ones?
```{r, num_cats_sigs, echo=FALSE, warning=FALSE, message=FALSE}
signature_roo0 <- sapply(fles_roo[grepl('_signatures_', fles_roo)], readRDS)
signature_roo_active <- sapply(signature_roo0, function(i) try(slot(i, 'count_matrices_active')))
names(signature_roo_active) <- gsub("_signatures_ROO.RDS", "", basename(fles_roo[grepl('_signatures_', fles_roo)]))

num_cats_nonexo <- lapply(names(signature_roo_active), function(j){
  .nonexoncol <- try(ncol(signature_roo_active[[j]][[1]][,!(colnames(signature_roo_active[[j]][[1]]) %in% nonexogenous$V1)]))
  try(c(ifelse(is.null(ncol(signature_roo_active[[j]][[1]])), yes = NA, no = ncol(signature_roo_active[[j]][[1]])),
        ifelse(is.null(.nonexoncol), NA, .nonexoncol)))})
names(num_cats_nonexo) <- names(signature_roo_active)
num_cats_nonexo <- num_cats_nonexo[ (typeof(num_cats_nonexo) != "character") & sapply(num_cats_nonexo, function(i) typeof(i[[1]]) != "character")]
ggplot(cbind.data.frame(ct=names(num_cats_nonexo),
                      do.call('rbind', num_cats_nonexo)), aes(x=`1`, y=`2`, label=ct))+
  geom_abline(slope = 1, intercept = 0, lty='dashed')+
  geom_point()+
  geom_label_repel(size=3)+labs(x='Number of active signatures', y='Number of nonexogenous active signatures')+theme_bw()
```


\section{Analysis per cancer type}

\subsection{Bone osteosarcoma}

\subsubsection{Barplot and general statistics}
```{r BoneOsteosarc1, echo=FALSE}
ct <- "Bone-Osteosarc"
obj_Bone_Osteosarc <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Bone_Osteosarc, legend_on = TRUE)
```

The number of samples and signatures is:
```{r BoneOsteosarc1b, echo=FALSE}
dim(obj_Bone_Osteosarc$Y)
```

The signatures are:
```{r BoneOsteosarc1c, echo=FALSE}
colnames(obj_Bone_Osteosarc$Y)
```

\subsubsection{Convergence table}

We only have converged results for the multinomial with full RE, and the DM with a single lambda (diag and full RE). It is the same for nonexogenous signatures.

```{r BoneOsteosarc2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Bone-Osteosarc"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}

```{r BoneOsteosarc3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
ct <- "Bone-Osteosarc"

obj <- sort_columns_TMB(load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/"))
sortedM <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj)
sortedM

## use params from ME M for ME DM
dmin1 <- ncol(obj$Y)-1

sortedDM <- wrapper_run_TMB(model = "fullRE_DM",
                           object = obj,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM$par.fixed, 'cov_par_RE'),
                             log_lambda = matrix(c(2,2))))
sortedDM

```

If we use the values of the fullRE M as initial values for the fullRE DM, we also don't get convergence:
```{r BoneOsteosarc3b, echo=FALSE, message=FALSE, dependson=c('BoneOsteosarc3')}
sortedDM$pdHess
```

\subsubsection{Potentially problematic signatures}

We notice that we have several signatures with low exposures, and many zero exposures
```{r, BoneOsteosarc1d}
colSums(obj_Bone_Osteosarc$Y == 0)/nrow(obj_Bone_Osteosarc$Y)
colSums(obj_Bone_Osteosarc$Y)/sum(obj_Bone_Osteosarc$Y)
```

E.g.

\begin{itemize}
\item SBS17b is 0 in `r round( (colSums(obj_Bone_Osteosarc$Y == 0)/nrow(obj_Bone_Osteosarc$Y))['SBS17b'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Bone_Osteosarc$Y)/sum(obj_Bone_Osteosarc$Y))['SBS17b'], digits=3)*100`\%
\item SBS30 is 0 in `r round( (colSums(obj_Bone_Osteosarc$Y == 0)/nrow(obj_Bone_Osteosarc$Y))['SBS30'], digits=3)*100`\% of cases and overal has an exposure of only `r round((colSums(obj_Bone_Osteosarc$Y)/sum(obj_Bone_Osteosarc$Y))['SBS30'], digits=3)*100`\%
\item SBS5 is 0 in `r round( (colSums(obj_Bone_Osteosarc$Y == 0)/nrow(obj_Bone_Osteosarc$Y))['SBS5'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Bone_Osteosarc$Y)/sum(obj_Bone_Osteosarc$Y))['SBS5'], digits=3)*100`\%
\end{itemize}

\subsubsection{Betas}

```{r, BoneOsteosarc_betas}
ct <- "Bone-Osteosarc"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```


```{r, BoneOsteosarc_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Bone-Osteosarc"
pval_bone_osteosarc <- wald_TMB_wrapper(diagRE_DMSL_nonexo[[ct]])
```
We use the results from the diagonal single lambda DM to test for differential abundance, giving a p-value of `r pval_bone_osteosarc`.

\subsubsection{Covariance matrices}

```{r}
ct <- "Bone-Osteosarc"
additional_sortedM <- list()
additional_sortedDM <- list()
additional_sortedM[[ct]] <- sortedM
additional_sortedDM[[ct]] <- sortedDM
```

Note that sortedDM did not convergence.

Nevertheless, both versions of fullRE M -- both of which converged and use the same baseline -- give very different covariances matrices.

```{r, BoneOsteosarc_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7}
ct <- "Bone-Osteosarc"
# models_it_bone_osteosarc <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_bone_osteosarc <- c('fullRE_M', 'fullRE_M_nonexo', 'additional_sortedM', 'additional_sortedDM')
covmats_bone_osteosarc <- lapply(models_it_bone_osteosarc,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_bone_osteosarc) <- models_it_bone_osteosarc
## because it's fullRE_M, it's sorted
colnames(covmats_bone_osteosarc[['fullRE_M']]) <- rownames(covmats_bone_osteosarc[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Bone_Osteosarc)$Y))
colnames(covmats_bone_osteosarc[['additional_sortedM']]) <- rownames(covmats_bone_osteosarc[['additional_sortedM']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Bone_Osteosarc)$Y))
colnames(covmats_bone_osteosarc[['additional_sortedDM']]) <- rownames(covmats_bone_osteosarc[['additional_sortedDM']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Bone_Osteosarc)$Y))
## because it's fullRE_M_nonexo, it's sorted
colnames(covmats_bone_osteosarc[['fullRE_M_nonexo']]) <- rownames(covmats_bone_osteosarc[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Bone_Osteosarc, nonexogenous$V1)$Y))

for(i in 1:length(covmats_bone_osteosarc)){pheatmap(covmats_bone_osteosarc[[i]], cluster_rows = F, cluster_cols = F, main = models_it_bone_osteosarc[i])}
```

\subsubsection{Simulation under inferred data}
Have not been able to simulate
```{r, BoneOsteosarc_sim, echo=FALSE}
# sim_Bone_Osteosarc <- give_sim_from_estimates("Bone-Osteosarc", "signatures",
#                                               sigs_to_remove=unique(nonexogenous$V1),
#                                               bool_give_PCA = T, path_to_data= "../../data/",
#                                               model="sparseRE_DMSL", bool_nonexo = F)
# )
# sim_Bone_Osteosarc[[2]]+ggtitle('Simulation of Bone osteosarcoma samples')
```

\subsubsection{Ranked plot for coverage}

```{r, BoneOsteosarc_ranked_plot}
ct <- "Bone-Osteosarc"
integer_overdispersion_param_DMSL <- 1
obj_Bone_Osteosarc_nonexo <- give_subset_sigs_TMBobj(obj_Bone_Osteosarc, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Bone_Osteosarc_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Bone_Osteosarc_nonexo,
                 loglog = F, title = 'obj_Bone_Osteosarc (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_Bone_Osteosarc_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Bone_Osteosarc_nonexo,
                 loglog = F, title = 'obj_Bone_Osteosarc (DMSL)'), ncol=2)
```

73/359=20\% of values are not included in the confidence interval of the DMSL.

\subsubsection{Correlations of signatures}
To add: the observed values, and the correlations of the normalised signatures
```{r, BoneOsteosarc_correlations, echo=FALSE, fig.height=3.5}

grid.arrange(ggplot(melt(give_all_correlations(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[["Bone-Osteosarc"]],
                 data_object = obj_Bone_Osteosarc_nonexo,
                 print_plot = F, nreps = 2, model = "M")[[1]])), aes(x=value))+geom_density()+
  ggtitle('Correlations of fitted values\n(fullRE M)'),
ggplot(melt(give_all_correlations(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[["Bone-Osteosarc"]],
                 data_object = obj_Bone_Osteosarc_nonexo,
                 print_plot = F, nreps = 2, model = "DMSL", integer_overdispersion_param=1)[[1]])), aes(x=value))+geom_density()+
  ggtitle('Correlations of fitted values\n(diag DMSL)'), ncol=2)

```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are a bit more chaotic:
```{r, BoneOsteosarc_mutsigextractor}
obj_Bone_Osteosarc_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Bone_Osteosarc_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations
```{r, BoneOsteosarc_sortedbynummuts}
createBarplot(normalise_rw(non_duplicated_rows(obj_Bone_Osteosarc$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Bone_Osteosarc$Y)),
                                        decreasing = F)))
```


\subsection{Breast-AdenoCA}
\subsubsection{Barplot and general statistics}
```{r BreastAdenoCA1, echo=FALSE}
ct <- "Breast-AdenoCA"
obj_Breast_AdenoCA <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Breast_AdenoCA, legend_on = TRUE)
```

There are many signatures, and also many samples.


The number of samples and signatures is:
```{r BreastAdenoCA1b, echo=FALSE}
dim(obj_Breast_AdenoCA$Y)
```

The signatures are:
```{r BreastAdenoCA1c, echo=FALSE}
colnames(obj_Breast_AdenoCA$Y)
```

\subsubsection{Convergence table}

We only have converged results for the diagRE_DMSL, with diagonal or sparse covariance structure, and diagonal M.
 This is probably due to the very high number of signatures, which make it impossible to infer the whole covariance structure.

```{r BreastAdenoCA2, echo=FALSE, dependson=c('summary_convergence')}
melt(all_summaries) %>% filter(value=="Breast-AdenoCA")
```

\subsubsection{Re-running of fitting}

```{r obj_Breast_AdenoCA3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
ct <- "Breast-AdenoCA"

obj_Breast_Adeno_sorted <- sort_columns_TMB(load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/"))
sortedM_Breast_Adeno <- wrapper_run_TMB(model = "diagRE_M",
                           object = obj_Breast_Adeno_sorted)
sortedM_Breast_Adeno

## use params from diagME M for diagME DM
sortedDM_Breast_Adeno <- wrapper_run_TMB(model = "diagRE_DM",
                           object = obj_Breast_Adeno_sorted,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_Breast_Adeno$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_Breast_Adeno$par.random, ncol=ncol(obj_Breast_Adeno_sorted$Y)-1),
                             logs_sd_RE=python_like_select_name(sortedM_Breast_Adeno$par.fixed, 'logs_sd_RE'),
                             log_lambda = matrix(c(2,2))))
sortedDM_Breast_Adeno
```

If we use the values of the diagRE M as initial values for the diagRE DM, we that it has converged. This is probably due to a combination of things: we are using the optimiser nlminb (better in general than the alternative, optim) and we are starting with these - better - values, and we are sorting the columns so that the category with highest total value is the baseline.
```{r obj_Breast_AdenoCA3b, echo=FALSE, message=FALSE, dependson=c('BoneOsteosarc3')}
sortedDM_Breast_Adeno$pdHess
```


```{r}
ct <- "Breast-AdenoCA"
additional_sorteddiagM <- list()
additional_sorteddiagDM <- list()
additional_sorteddiagM[[ct]] <- sortedM_Breast_Adeno
additional_sorteddiagDM[[ct]] <- sortedDM_Breast_Adeno
```

\subsubsection{Potentially problematic signatures}

We notice that we have several signatures with low exposures, and many zero exposures
```{r, obj_Breast_AdenoCA3d}
colSums(obj_Breast_AdenoCA$Y == 0)/nrow(obj_Breast_AdenoCA$Y)
colSums(obj_Breast_AdenoCA$Y)/sum(obj_Breast_AdenoCA$Y)
```

E.g.

\begin{itemize}
\item SBS9 is 0 in `r round( (colSums(obj_Breast_AdenoCA$Y == 0)/nrow(obj_Breast_AdenoCA$Y))['SBS9'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Breast_AdenoCA$Y)/sum(obj_Breast_AdenoCA$Y))['SBS9'], digits=3)*100`\%
\item SBS12 is 0 in `r round( (colSums(obj_Breast_AdenoCA$Y == 0)/nrow(obj_Breast_AdenoCA$Y))['SBS12'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Breast_AdenoCA$Y)/sum(obj_Breast_AdenoCA$Y))['SBS12'], digits=3)*100`\%
\item SBS17a is 0 in `r round( (colSums(obj_Breast_AdenoCA$Y == 0)/nrow(obj_Breast_AdenoCA$Y))['SBS17a'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Breast_AdenoCA$Y)/sum(obj_Breast_AdenoCA$Y))['SBS17a'], digits=3)*100`\%
\item SBS17b is 0 in `r round( (colSums(obj_Breast_AdenoCA$Y == 0)/nrow(obj_Breast_AdenoCA$Y))['SBS17b'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Breast_AdenoCA$Y)/sum(obj_Breast_AdenoCA$Y))['SBS17b'], digits=3)*100`\%
\item SBS37 is 0 in `r round( (colSums(obj_Breast_AdenoCA$Y == 0)/nrow(obj_Breast_AdenoCA$Y))['SBS37'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Breast_AdenoCA$Y)/sum(obj_Breast_AdenoCA$Y))['SBS37'], digits=3)*100`\%
\item SBS39 is 0 in `r round( (colSums(obj_Breast_AdenoCA$Y == 0)/nrow(obj_Breast_AdenoCA$Y))['SBS39'], digits=3)*100`\% of cases and has an overall exposure of `r round((colSums(obj_Breast_AdenoCA$Y)/sum(obj_Breast_AdenoCA$Y))['SBS39'], digits=3)*100`\%
\end{itemize}

\subsubsection{Betas}

```{r, Breast_AdenoCA_betas, echo=FALSE, fig.height=10}
ct <- "Breast-AdenoCA"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')),
plot_betas(additional_sorteddiagM[[ct]])+ggtitle(paste0(ct, '\n additional_sorteddiagM')),
plot_betas(additional_sorteddiagDM[[ct]])+ggtitle(paste0(ct, '\n additional_sorteddiagDM')),
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
  plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
  plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=5)

```

```{r, Breast_AdenoCA_betasb, echo=FALSE, fig.height=4}
ct <- "Breast-AdenoCA"
betas_breast_AdenoCA_sparseRE_DMSL_nonexo <- python_like_select_rownames(summary(sparseRE_DMSL_nonexo[[ct]]), 'beta')
rownames(betas_breast_AdenoCA_sparseRE_DMSL_nonexo) <- rep(vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Breast_AdenoCA, sigs_to_remove = nonexogenous$V1)$Y)), each=2)
ggplot(cbind(melt(betas_breast_AdenoCA_sparseRE_DMSL_nonexo),
             group=c('Intercept', 'Slope')) %>% filter(Var2=='Estimate', group=='Slope'), aes(x=Var1, y=value))+
  geom_hline(yintercept = 0, lty='dashed', col='blue')+geom_point()+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
```

```{r, Breast_AdenoCA_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Breast-AdenoCA"
diagRE_DMSL_nonexo[[ct]]$phHess
pval_Breast_AdenoCA <- wald_TMB_wrapper(diagRE_DMSL_nonexo[[ct]])
```
We use the results from the diagonal single lambda DM to test for differential abundance, giving a p-value of `r pval_Breast_AdenoCA`.



\subsubsection{Covariance matrices}

```{r, Breast_AdenoCA_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7}
ct <- "Breast-AdenoCA"
models_it_Breast_AdenoCA <- c('fullRE_M', 'fullRE_M_nonexo')
covmats_Breast_AdenoCA <- lapply(models_it_Breast_AdenoCA,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Breast_AdenoCA) <- models_it_Breast_AdenoCA
## because it's fullRE_M, it's sorted
colnames(covmats_Breast_AdenoCA[['fullRE_M']]) <- rownames(covmats_Breast_AdenoCA[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Breast_AdenoCA)$Y))
## because it's fullRE_M_nonexo, it's sorted
colnames(covmats_Breast_AdenoCA[['fullRE_M_nonexo']]) <- rownames(covmats_Breast_AdenoCA[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Breast_AdenoCA, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Breast_AdenoCA)){pheatmap(covmats_Breast_AdenoCA[[i]], cluster_rows = F, cluster_cols = F, main = models_it_bone_osteosarc[i])}
```

\subsubsection{Simulation under inferred data}

```{r, Breast_AdenoCA_sim, echo=FALSE}
sim_Breast_AdenoCA <- give_sim_from_estimates("Breast-AdenoCA", "signatures", sigs_to_remove=unique(nonexogenous$V1),
                                              bool_give_PCA = T, path_to_data= "../../data/")
sim_Breast_AdenoCA[[2]]+ggtitle('Simulation of Breast Adenocarcinoma samples')
```

\subsubsection{Ranked plot for coverage}

```{r, Breast_AdenoCA_ranked_plot}
ct <- "Breast-AdenoCA"
integer_overdispersion_param_DMSL <- 1
obj_Breast_AdenoCA_nonexo <- give_subset_sigs_TMBobj(obj_Breast_AdenoCA, sigs_to_remove = nonexogenous$V1)

for(loglog_it in c(T,F)){
  grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Breast_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Breast_AdenoCA_nonexo,
                 loglog = loglog_it, title = 'Breast_AdenoCA_nonexo (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_Breast_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Breast_AdenoCA_nonexo,
                 loglog = loglog_it, title = 'Breast_AdenoCA_nonexo (DMSL)'), ncol=2)
}
```


\subsubsection{Signatures from mutSigExtractor}

```{r, Breast_AdenoCA_mutsigextractor}
obj_Breast_AdenoCA_mutSigExtractor <- load_PCAWG(ct = "Breast-AdenoCA",
                                                 typedata = "signaturesmutSigExtractor",
                                                 path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Breast_AdenoCA_mutSigExtractor, legend_on = FALSE)
```





\subsection{Cervix-SCC}

\subsubsection{Barplot and general statistics}
```{r Cervix_SCC1, echo=FALSE}
ct <- "Cervix-SCC"
obj_Cervix_SCC <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Cervix_SCC, legend_on = TRUE)
```

The number of samples and signatures is:
```{r Cervix_SCC1b, echo=FALSE}
dim(obj_Cervix_SCC$Y)
```

The signatures are:
```{r Cervix_SCC1c, echo=FALSE}
colnames(obj_Cervix_SCC$Y)
```

\subsubsection{Convergence table}


```{r Cervix_SCC2, echo=FALSE, dependson=c('summary_convergence')}
melt(all_summaries) %>% filter(value=="Cervix-SCC")
```


\subsubsection{Potentially problematic signatures}

SBS33 is a potentially problematic signature, being 0 in `r round( (colSums(obj_Cervix_SCC$Y == 0)/nrow(obj_Cervix_SCC$Y))['SBS33'], digits=3)*100`\% of cases and with an overall exposure of `r round((colSums(obj_Cervix_SCC$Y)/sum(obj_Cervix_SCC$Y))['SBS33'], digits=3)*100`\%.

```{r, Cervix_SCC1d}
colSums(obj_Cervix_SCC$Y == 0)/nrow(obj_Cervix_SCC$Y)
colSums(obj_Cervix_SCC$Y)/sum(obj_Cervix_SCC$Y)
```

\subsubsection{Betas}

```{r, Cervix_SCC_betas}
ct <- "Cervix-SCC"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
             plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
             plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
             plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
  plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
  plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```

```{r, Cervix_SCC_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Cervix-SCC"
pval_Cervix_SCC <- wald_TMB_wrapper(fullRE_DMSL_nonexo[[ct]])
```
We use the results from the fullRE single lambda DM to test for differential abundance, giving a p-value of `r pval_bone_osteosarc`.

\subsubsection{Covariance matrices}

```{r}
# ct <- "Bone-Osteosarc"
# additional_sortedM <- list()
# additional_sortedDM <- list()
# additional_sortedM[[ct]] <- sortedM
# additional_sortedDM[[ct]] <- sortedDM
```


```{r, Cervix_SCC_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7}
ct <- "Cervix-SCC"

models_it_bone_Cervix_SCC <- c('fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_bone_Cervix_SCC <- lapply(models_it_bone_Cervix_SCC,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_bone_Cervix_SCC) <- models_it_bone_Cervix_SCC
## because it's fullRE_M_nonexo, it's not sorted
colnames(covmats_bone_Cervix_SCC[['fullRE_M_nonexo']]) <- rownames(covmats_bone_Cervix_SCC[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Cervix_SCC, nonexogenous$V1)$Y))
## because it's fullRE_DMSL_nonexo, it's sorted
colnames(covmats_bone_Cervix_SCC[['fullRE_DMSL_nonexo']]) <- rownames(covmats_bone_Cervix_SCC[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Cervix_SCC, nonexogenous$V1)$Y))

for(i in 1:length(covmats_bone_Cervix_SCC)){pheatmap(covmats_bone_Cervix_SCC[[i]], cluster_rows = F, cluster_cols = F, main = models_it_bone_Cervix_SCC[i])}
```

\subsubsection{Simulation under inferred data}

```{r}
unique(nonexogenous$V1)
```

```{r, Cervix_SCC_sim, echo=FALSE}
sim_Cervix_SCC <- give_sim_from_estimates( "Cervix-SCC", "signatures", 
                                          sigs_to_remove=unique(nonexogenous$V1),
                                          bool_give_PCA = T, path_to_data= "../../data/",
                                          sig_of_interest = "SBS2")
sim_Cervix_SCC[[2]]+ggtitle('Simulation of Cervix SCC samples')
```

\subsubsection{Ranked plot for coverage}

```{r, Cervix_SCC_ranked_plot}
ct <- "Cervix-SCC"
integer_overdispersion_param_DMSL <- 1
obj_Cervix_SCC_nonexo <- give_subset_sigs_TMBobj(obj_Cervix_SCC, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Cervix_SCC_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Cervix_SCC_nonexo,
                 loglog = F, title = 'obj_Cervix_SCC_nonexo (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_Cervix_SCC_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Cervix_SCC_nonexo,
                 loglog = F, title = 'obj_Cervix_SCC_nonexo (DMSL)'), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

```{r, Cervix_SCC_mutsigextractor}
obj_Cervix_SCC_mutSigExtractor <- load_PCAWG(ct = "Cervix-SCC", typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Cervix_SCC_mutSigExtractor, legend_on = TRUE)
```

\subsection{CNS-GBM}
\subsubsection{Barplot and general statistics}
```{r CNSGBM1, echo=FALSE}
ct <- "CNS-GBM"
obj_CNS_GBM <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_GBM, legend_on = TRUE)
```



The number of samples and signatures is:
```{r CNSGBM1b, echo=FALSE}
dim(obj_CNS_GBM$Y)
```

The signatures are:
```{r CNSGBM1c, echo=FALSE}
colnames(obj_CNS_GBM$Y)
```


\subsubsection{Convergence table}

We only have converged results for the multinomial with full RE, and the DM with a single lambda (diag and sparse RE). It is the same for nonexogenous signatures.

```{r CNSGBM2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "CNS-GBM"
melt(all_summaries) %>% filter(value==ct)
```


\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo
```{r CNSGBM3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "CNS-GBM"

obj_CNSGBM <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                                nonexogenous$V1))
sortedM_CNSGBM <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_CNSGBM)
sortedM_CNSGBM
```

```{r CNSGBM3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_CNSGBM$Y)-1

sortedDM_CNSGBM <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_CNSGBM,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_CNSGBM$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_CNSGBM$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_CNSGBM$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_CNSGBM$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_CNSGBM

```


If we use the values of the fullRE M exo as initial values for the fullRE DMSL exo do converge:
```{r CNSGBM3b, echo=FALSE, message=FALSE, dependson=c('CNSGBM3')}
sortedDM_CNSGBM$pdHess
```


\subsubsection{Potentially problematic signatures}

We notice that there are no truly problematic signatures (SBS15 has the most zeros; 50\%).
```{r, CNSGBM1d}
colSums(obj_CNS_GBM$Y == 0)/nrow(obj_CNS_GBM$Y)
colSums(obj_CNS_GBM$Y)/sum(obj_CNS_GBM$Y)
```

```{r, additional_runs}
additional_sortedMnonexo <- list()
additional_sortedDMSLnonexo <- list()
```

```{r, CNS_GBM_additional_runs, dependson=c('additional_runs')}
additional_sortedMnonexo[["CNS-GBM"]] <- sortedM_CNSGBM
additional_sortedDMSLnonexo[["CNS-GBM"]] <- sortedDM_CNSGBM
```

\subsubsection{Betas}

```{r, CNSGBM_betas}
ct <- "CNS-GBM"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(sortedDM_CNSGBM)+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```



```{r, CNSGBM_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "CNS-GBM"
pval_CNS_GBM <- wald_TMB_wrapper(sortedDM_CNSGBM)
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_CNS_GBM`.

\subsubsection{Covariance matrices}



```{r, CNSGBM_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('CNS_GBM_additional_runs')}
ct <- "CNS-GBM"
# models_it_CNS_GBM <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_CNS_GBM <- c('fullRE_M', 'fullRE_M_nonexo', 'additional_sortedDMSLnonexo')
covmats_CNS_GBM <- lapply(models_it_CNS_GBM,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_CNS_GBM) <- models_it_CNS_GBM
## because it's fullRE_M, it's sorted
colnames(covmats_CNS_GBM[['fullRE_M']]) <- rownames(covmats_CNS_GBM[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_CNS_GBM)$Y))
colnames(covmats_CNS_GBM[['fullRE_M_nonexo']]) <- rownames(covmats_CNS_GBM[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_CNS_GBM, nonexogenous$V1)$Y))
colnames(covmats_CNS_GBM[['additional_sortedDMSLnonexo']]) <- rownames(covmats_CNS_GBM[['additional_sortedDMSLnonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_CNS_GBM, nonexogenous$V1)$Y))

for(i in 1:length(covmats_CNS_GBM)){pheatmap(covmats_CNS_GBM[[i]], cluster_rows = F, cluster_cols = F, main = models_it_CNS_GBM[i])}
```



\subsubsection{Simulation under inferred data}
```{r, CNSGBM_sim, echo=FALSE}
sim_CNS_GBM <- give_sim_from_estimates("CNS-GBM", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = F,
                                       tmb_object=sortedDM_CNSGBM)
sim_CNS_GBM[[2]]+ggtitle('Simulation of CNS-GBM samples')

```


\subsubsection{Ranked plot for coverage}

```{r, CNSGBM_ranked_plot}
ct <- "CNS-GBM"
integer_overdispersion_param_DMSL <- 1
obj_CNS_GBM_nonexo <- give_subset_sigs_TMBobj(obj_CNS_GBM, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_CNS_GBM_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNS_GBM_nonexo,
                 loglog = F, title = 'obj_CNS_GBM (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = sortedDM_CNSGBM,
                 data_object = obj_CNS_GBM_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNS_GBM_nonexo,
           loglog = F, title = 'obj_CNS_GBM (DMSL)'), ncol=2)
```

Surprisingly, the values for DMSL look even worse than the multinomial, for high values

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are a bit more chaotic:
```{r, CNSGBM_mutsigextractor}
obj_CNS_GBM_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_GBM_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.
```{r, CNSGBM_sortedbynummuts}
createBarplot(normalise_rw(non_duplicated_rows(obj_CNS_GBM$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_CNS_GBM$Y)),
                                        decreasing = F)))
```

<!-- -------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------- -->

\subsection{CNS-Medullo}
\subsubsection{Barplot and general statistics}
```{r CNSMedullo1, echo=FALSE}
ct <- "CNS-Medullo"
obj_CNS_Medullo <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_Medullo, legend_on = TRUE)
```


The number of samples and signatures is:
```{r CNSMedullo1b, echo=FALSE}
dim(obj_CNS_Medullo$Y)
```

The signatures are:
```{r CNSMedullo1c, echo=FALSE}
colnames(obj_CNS_Medullo$Y)
```



\subsubsection{Convergence table}

Pretty much everything has converged in this case
```{r CNSMedullo2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "CNS-Medullo"
melt(all_summaries) %>% filter(value==ct)
```

As nonexo DMSL has already converged, we don't re-run anything.

\subsubsection{Potentially problematic signatures}

We notice that there are no truly problematic signatures 
```{r, CNSMedullo1d}
colSums(obj_CNS_Medullo$Y == 0)/nrow(obj_CNS_Medullo$Y)
colSums(obj_CNS_Medullo$Y)/sum(obj_CNS_Medullo$Y)
```


\subsubsection{Betas}

```{r, CNSMedullo_betas}
ct <- "CNS-Medullo"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```



```{r, CNSMedullo_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "CNS-Medullo"
pval_CNS_Medullo <- wald_TMB_wrapper(fullRE_DMSL_nonexo[[ct]])
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_CNS_Medullo`.


\subsubsection{Covariance matrices}

```{r, CNSMedullo_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('CNS_Medullo_additional_runs')}
ct <- "CNS-Medullo"
# models_it_CNS_Medullo <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_CNS_Medullo <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_CNS_Medullo <- lapply(models_it_CNS_Medullo,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_CNS_Medullo) <- models_it_CNS_Medullo
## because it's fullRE_M, it's sorted
colnames(covmats_CNS_Medullo[['fullRE_M']]) <- rownames(covmats_CNS_Medullo[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_CNS_Medullo)$Y))
colnames(covmats_CNS_Medullo[['fullRE_M_nonexo']]) <- rownames(covmats_CNS_Medullo[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_CNS_Medullo, nonexogenous$V1)$Y))
colnames(covmats_CNS_Medullo[['fullRE_DMSL_nonexo']]) <- rownames(covmats_CNS_Medullo[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_CNS_Medullo, nonexogenous$V1)$Y))

for(i in 1:length(covmats_CNS_Medullo)){pheatmap(covmats_CNS_Medullo[[i]], cluster_rows = F, cluster_cols = F, main = models_it_CNS_Medullo[i])}
```


\subsubsection{Simulation under inferred data}
```{r, CNSMedullo_sim, echo=FALSE}
sim_CNS_Medullo <- give_sim_from_estimates("CNS-Medullo", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = F,
                                       tmb_object=fullRE_DMSL_nonexo[["CNS-Medullo"]])
sim_CNS_Medullo[[2]]+ggtitle('Simulation of CNS-Medullo samples')

```


\subsubsection{Ranked plot for coverage}

```{r, CNSMedullo_ranked_plot}
ct <- "CNS-Medullo"
integer_overdispersion_param_DMSL <- 1
obj_CNS_Medullo_nonexo <- give_subset_sigs_TMBobj(obj_CNS_Medullo, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_CNS_Medullo_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNS_Medullo_nonexo,
                 loglog = F, title = 'obj_CNS_Medullo (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[["CNS-Medullo"]],
                 data_object = obj_CNS_Medullo_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNS_Medullo_nonexo,
           loglog = F, title = 'obj_CNS_Medullo (DMSL)'), ncol=2)
```



\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are a bit more chaotic:
```{r, CNSMedullo_mutsigextractor}
obj_CNS_Medullo_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_Medullo_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.
```{r, CNSMedullo_sortedbynummuts}
createBarplot(normalise_rw(non_duplicated_rows(obj_CNS_Medullo$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_CNS_Medullo$Y)),
                                        decreasing = F)))
```


<!-- -------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------- -->

\subsection{CNS-Oligo}

\subsubsection{Barplot and general statistics}
```{r CNSOligo1, echo=FALSE}
ct <- "CNS-Oligo"
obj_CNS_Oligo <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_Oligo, legend_on = TRUE)
```


The number of samples and signatures is:
```{r CNSOligo1b, echo=FALSE}
dim(obj_CNS_Oligo$Y)
```

The signatures are:
```{r CNSOligo1c, echo=FALSE}
colnames(obj_CNS_Oligo$Y)
```


\subsubsection{Convergence table}

Pretty much everything has converged
```{r CNSOligo2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "CNS-Oligo"
melt(all_summaries) %>% filter(value==ct)
```


<!-- \subsubsection{Potentially problematic signatures} -->

<!-- We notice that there are no truly problematic signatures (SBS15 has the most zeros; 50\%). -->
<!-- ```{r, CNSOligo1d} -->
<!-- colSums(obj_CNS_Oligo$Y == 0)/nrow(obj_CNS_Oligo$Y) -->
<!-- colSums(obj_CNS_Oligo$Y)/sum(obj_CNS_Oligo$Y) -->
<!-- ``` -->



\subsubsection{Betas}

```{r, CNSOligo_betas}
ct <- "CNS-Oligo"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_M[[ct]])+ggtitle(paste0(ct, '\n fullRE_M')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
  plot_betas(fullRE_DMDL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMDL_nonexo')), nrow=2)
```



```{r, CNSOligo_DA, echo=FALSE, message=FALSE, results='hide'}
pval_CNS_Oligo <- wald_TMB_wrapper(fullRE_DMSL_nonexo[["CNS-Oligo"]])
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_CNS_Oligo`.

\subsubsection{Covariance matrices}



```{r, CNSOligo_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('CNS_Oligo_additional_runs')}
ct <- "CNS-Oligo"
models_it_CNS_Oligo <- c('fullRE_M', 'fullRE_DMSL', 'fullRE_DMSL_nonexo')
covmats_CNS_Oligo <- lapply(models_it_CNS_Oligo,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_CNS_Oligo) <- models_it_CNS_Oligo

## because it's fullRE_M, it's sorted
colnames(covmats_CNS_Oligo[['fullRE_M']]) <- rownames(covmats_CNS_Oligo[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_CNS_Oligo)$Y))
colnames(covmats_CNS_Oligo[['fullRE_DMSL']]) <- rownames(covmats_CNS_Oligo[['fullRE_DMSL']]) <- vector_cats_to_logR(colnames(obj_CNS_Oligo$Y))
colnames(covmats_CNS_Oligo[['fullRE_DMSL_nonexo']]) <- rownames(covmats_CNS_Oligo[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_CNS_Oligo, nonexogenous$V1)$Y))

for(i in 1:length(covmats_CNS_Oligo)){pheatmap(covmats_CNS_Oligo[[i]], cluster_rows = F, cluster_cols = F, main = models_it_CNS_Oligo[i])}
```





\subsubsection{Simulation under inferred data}
```{r, CNSOligo_sim, echo=FALSE}
sim_CNS_Oligo <- give_sim_from_estimates("CNS-Oligo", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = F,
                                       tmb_object=fullRE_DMSL_nonexo[["CNS-Oligo"]])
sim_CNS_Oligo[[2]]+ggtitle('Simulation of CNS-Oligo samples')

```



\subsubsection{Ranked plot for coverage}
The values for DMSL nonexo look considerably better than for M nonexo.
```{r, CNSOligo_ranked_plot}
ct <- "CNS-Oligo"
integer_overdispersion_param_DMSL <- 1
obj_CNS_Oligo_nonexo <- give_subset_sigs_TMBobj(obj_CNS_Oligo, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_CNS_Oligo_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNS_Oligo_nonexo,
                 loglog = F, title = 'obj_CNS_Oligo (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_CNS_Oligo_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNS_Oligo_nonexo,
           loglog = F, title = 'obj_CNS_Oligo (DMSL)'), ncol=2)
```


\subsubsection{Signatures from mutSigExtractor}

These are the signatures from mutSigExtractor:
```{r, CNSOligo_mutsigextractor}
obj_CNS_Oligo_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_Oligo_mutSigExtractor, legend_on = FALSE)
```


Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.
```{r, CNSOligo_sortedbynummuts, fig.height=3}
createBarplot(normalise_rw(non_duplicated_rows(obj_CNS_Oligo$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_CNS_Oligo$Y)),
                                        decreasing = F)))
```

<!-- -------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------- -->

\subsection{CNS-PiloAstro}

\subsection{CNS-PiloAstro}
\subsubsection{Barplot and general statistics}
```{r CNSPiloAstro1, echo=FALSE}
ct <- "CNS-PiloAstro"
obj_CNS_PiloAstro <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_PiloAstro, legend_on = TRUE)
```



The number of samples and signatures is:
```{r CNSPiloAstro1b, echo=FALSE}
dim(obj_CNS_PiloAstro$Y)
```

The signatures are:
```{r CNSPiloAstro1c, echo=FALSE}
colnames(obj_CNS_PiloAstro$Y)
```


\subsubsection{Convergence table}

We have converged results for everything except for full RE DM, in the case of all signatures (with only nonexo everything has).

```{r CNSPiloAstro2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "CNS-PiloAstro"
melt(all_summaries) %>% filter(value==ct)
```



\subsubsection{Re-running of fitting}
Using fullRE_M to fit fullRE_DMSL (all sigs, as the one with nonexo has already converged)
```{r CNSPiloAstro3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "CNS-PiloAstro"

obj_CNSPiloAstro <- sort_columns_TMB(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"))
sortedM_CNSPiloAstro <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_CNSPiloAstro)
sortedM_CNSPiloAstro
```


```{r CNSPiloAstro3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_CNSPiloAstro$Y)-1

sortedDM_CNSPiloAstro <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_CNSPiloAstro,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_CNSPiloAstro$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_CNSPiloAstro$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_CNSPiloAstro$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_CNSPiloAstro$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_CNSPiloAstro

```



If we use the values of the fullRE M as initial values for the fullRE DMSL still do not converge:
```{r CNSPiloAstro3b, echo=FALSE, message=FALSE, dependson=c('CNSPiloAstro3')}
sortedDM_CNSPiloAstro$pdHess
```




\subsubsection{Potentially problematic signatures}

We notice that there are no truly problematic signatures (SBS15 has the most zeros; 50\%).
```{r, CNSPiloAstro1d}
colSums(obj_CNS_PiloAstro$Y == 0)/nrow(obj_CNS_PiloAstro$Y)
colSums(obj_CNS_PiloAstro$Y)/sum(obj_CNS_PiloAstro$Y)
```

SBS19 and SBS23 are quite sparse.



```{r, CNS_PiloAstro_additional_runs, dependson=c('additional_runs')}
additional_sortedMnonexo[["CNS-PiloAstro"]] <- sortedM_CNSPiloAstro
additional_sortedDMSLnonexo[["CNS-PiloAstro"]] <- sortedDM_CNSPiloAstro
```

\subsubsection{Betas}

```{r, CNSPiloAstro_betas}
ct <- "CNS-PiloAstro"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
  plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
  plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```




```{r, CNSPiloAstro_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "CNS-PiloAstro"
pval_CNS_PiloAstro <- wald_TMB_wrapper(fullRE_DMSL_nonexo[[ct]])
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_CNS_PiloAstro`.


\subsubsection{Covariance matrices}



```{r, CNSPiloAstro_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('CNS_PiloAstro_additional_runs')}
ct <- "CNS-PiloAstro"
# models_it_CNS_PiloAstro <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_CNS_PiloAstro <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_CNS_PiloAstro <- lapply(models_it_CNS_PiloAstro,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_CNS_PiloAstro) <- models_it_CNS_PiloAstro
## because it's fullRE_M, it's sorted
colnames(covmats_CNS_PiloAstro[['fullRE_M']]) <- rownames(covmats_CNS_PiloAstro[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_CNS_PiloAstro)$Y))
colnames(covmats_CNS_PiloAstro[['fullRE_M_nonexo']]) <- rownames(covmats_CNS_PiloAstro[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_CNS_PiloAstro, nonexogenous$V1)$Y))
colnames(covmats_CNS_PiloAstro[['fullRE_DMSL_nonexo']]) <- rownames(covmats_CNS_PiloAstro[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_CNS_PiloAstro, nonexogenous$V1)$Y))

for(i in 1:length(covmats_CNS_PiloAstro)){pheatmap(covmats_CNS_PiloAstro[[i]], cluster_rows = F, cluster_cols = F, main = models_it_CNS_PiloAstro[i])}
```



\subsubsection{Simulation under inferred data}
```{r, CNSPiloAstro_sim, echo=FALSE}
sim_CNS_PiloAstro <- give_sim_from_estimates(ct = "CNS-PiloAstro", typedata = "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = F,
                                      tmb_object=fullRE_DMSL_nonexo[["CNS-PiloAstro"]])
sim_CNS_PiloAstro[[2]]+ggtitle('Simulation of CNS-PiloAstro samples')

```



\subsubsection{Ranked plot for coverage}

```{r, CNSPiloAstro_ranked_plot}
ct <- "CNS-PiloAstro"
integer_overdispersion_param_DMSL <- 1
obj_CNS_PiloAstro_nonexo <- give_subset_sigs_TMBobj(obj_CNS_PiloAstro, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_CNS_PiloAstro_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNS_PiloAstro_nonexo,
                 loglog = F, title = 'obj_CNS_PiloAstro (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_CNS_PiloAstro_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_CNS_PiloAstro_nonexo,
           loglog = F, title = 'obj_CNS_PiloAstro (DMSL)'), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are a bit more chaotic:
```{r, CNSPiloAstro_mutsigextractor}
obj_CNS_PiloAstro_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_CNS_PiloAstro_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations, with perhaps SBS9 being slightly found in the rightmost side preferentially.
```{r, CNSPiloAstro_sortedbynummuts}
createBarplot(normalise_rw(non_duplicated_rows(obj_CNS_PiloAstro$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_CNS_PiloAstro$Y)),
                                        decreasing = F)))
```


\subsection{ColoRect-AdenoCA}

\subsection{ColoRect-AdenoCA}
\subsubsection{Barplot and general statistics}
```{r ColoRectAdenoCA1, echo=FALSE}
ct <- "ColoRect-AdenoCA"
obj_ColoRect_AdenoCA <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_ColoRect_AdenoCA, legend_on = TRUE)
```



The number of samples and signatures is:
```{r ColoRectAdenoCA1b, echo=FALSE}
dim(obj_ColoRect_AdenoCA$Y)
```

The signatures are:
```{r ColoRectAdenoCA1c, echo=FALSE}
colnames(obj_ColoRect_AdenoCA$Y)
```



\subsubsection{Convergence table}

We only have converged results for the multinomial with diag RE, when including all mutations. For exogenous mutations, full DMSL is has not converged.

```{r ColoRectAdenoCA2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "ColoRect-AdenoCA"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo
```{r ColoRectAdenoCA3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}

TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "ColoRect-AdenoCA"

obj_ColoRectAdenoCA <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct,
                                                                           typedata = "signatures",
                                                                           path_to_data = "../../data/"),
                                                                nonexogenous$V1))
colnames(obj_ColoRectAdenoCA)
sortedM_ColoRectAdenoCA <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_ColoRectAdenoCA)
sortedM_ColoRectAdenoCA
```


Now the fullM doesn't converge (even though the original fullRE M nonexo did converge?), so I cannot use all the parameters to find the starting parameters of the DM, as some are NA. I can however use some, such as beta.


What parameters are NA?
```{r ColoRectAdenoCA3a1, echo=FALSE, message=FALSE, dependson=c('libraries')}
sortedM_ColoRectAdenoCA$par.fixed
```

Betas, logsd and covariances are not NA. Therefore, we use these values as starting values, and give an empty random effects matrix.

```{r ColoRectAdenoCA3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide', eval=T}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_ColoRectAdenoCA$Y)-1

initial_params_colorect <- list(
                             beta = matrix(python_like_select_name(sortedM_ColoRectAdenoCA$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(0, nrow=length(sortedM_ColoRectAdenoCA$par.random) %/% dmin1,
                                              ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_ColoRectAdenoCA$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_ColoRectAdenoCA$par.fixed, 'cov_par_RE'),
                             log_lambda = 2)

# sortedDM_ColoRectAdenoCA <- wrapper_run_TMB(model = "fullREDMsinglelambda",
#                            object = obj_ColoRectAdenoCA,
#                            smart_init_vals = F, use_nlminb = T,
#                            initial_params = initial_params_colorect)
# sortedDM_ColoRectAdenoCA

```

I get the error "gradient function must rerurn a number vector of length 43" for some reason I don't understand - it's as though the initial values I am giving are not correct.

```{r ColoRectAdenoCA3b, echo=FALSE, message=FALSE, dependson=c('ColoRectAdenoCA3')}
# sortedDM_ColoRectAdenoCA$pdHess
```

\subsubsection{Potentially problematic signatures}

```{r, ColoRectAdenoCA1d}
colSums(obj_ColoRect_AdenoCA$Y == 0)/nrow(obj_ColoRect_AdenoCA$Y)
colSums(obj_ColoRect_AdenoCA$Y)/sum(obj_ColoRect_AdenoCA$Y)
```

\subsubsection{Betas}

```{r, ColoRectAdenoCA_betas}
ct <- "ColoRect-AdenoCA"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
  plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
  plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')
                                                 ), nrow=2)
```

```{r, ColoRectAdenoCA_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "ColoRect-AdenoCA"
pval_ColoRect_AdenoCA <- wald_TMB_wrapper(diagRE_DMSL_nonexo[[ct]])
```
We use the results from the diagonal RE single lambda DM nonexo to test for differential abundance, giving a p-value of `r pval_ColoRect_AdenoCA`.

\subsubsection{Covariance matrices}

```{r, ColoRectAdenoCA_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('ColoRect_AdenoCA_additional_runs')}
ct <- "ColoRect-AdenoCA"
models_it_ColoRect_AdenoCA <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_ColoRect_AdenoCA <- lapply(models_it_ColoRect_AdenoCA,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_ColoRect_AdenoCA) <- models_it_ColoRect_AdenoCA
## because it's fullRE_M, it's sorted
colnames(covmats_ColoRect_AdenoCA[['fullRE_M']]) <- rownames(covmats_ColoRect_AdenoCA[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_ColoRect_AdenoCA)$Y))
colnames(covmats_ColoRect_AdenoCA[['fullRE_M_nonexo']]) <- rownames(covmats_ColoRect_AdenoCA[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_ColoRect_AdenoCA, nonexogenous$V1)$Y))
colnames(covmats_ColoRect_AdenoCA[['fullRE_DMSL_nonexo']]) <- rownames(covmats_ColoRect_AdenoCA[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_ColoRect_AdenoCA, nonexogenous$V1)$Y))

for(i in 1:length(covmats_ColoRect_AdenoCA)){pheatmap(covmats_ColoRect_AdenoCA[[i]], cluster_rows = F, cluster_cols = F, main = models_it_ColoRect_AdenoCA[i])}
```


\subsubsection{Simulation under inferred data}
I am simulating using the full effects multinomial, because the function <give_sim_from_estimates> needs to be adapted to diagDMSL.

```{r, ColoRectAdenoCA_sim, echo=FALSE}
sim_ColoRect_AdenoCA <- give_sim_from_estimates("ColoRect-AdenoCA", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_M", bool_nonexo = F,
                                      tmb_object=(fullRE_M_nonexo[["ColoRect-AdenoCA"]]),
                                      sig_of_interest = "SBS14")
sim_ColoRect_AdenoCA[[2]]+ggtitle('Simulation of ColoRect-AdenoCA samples')

```


\subsubsection{Ranked plot for coverage}

```{r, ColoRectAdenoCA_ranked_plot}
ct <- "ColoRect-AdenoCA"
integer_overdispersion_param_DMSL <- 1
obj_ColoRect_AdenoCA_nonexo <- give_subset_sigs_TMBobj(obj_ColoRect_AdenoCA, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_ColoRect_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_ColoRect_AdenoCA_nonexo,
                 loglog = F, title = 'obj_ColoRect_AdenoCA (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                 data_object = obj_ColoRect_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_ColoRect_AdenoCA_nonexo,
           loglog = F, title = 'obj_ColoRect_AdenoCA (diag DMSL)'), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

```{r, ColoRectAdenoCA_mutsigextractor}
obj_ColoRect_AdenoCA_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_ColoRect_AdenoCA_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: very clearly there are a few samples with very high number of mutations that also have a completely different mutational signature exposure.
```{r, ColoRectAdenoCA_sortedbynummuts, fig.height=2, fig.width=4}
createBarplot(normalise_rw(non_duplicated_rows(obj_ColoRect_AdenoCA$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_ColoRect_AdenoCA$Y)),
                                        decreasing = F)))
```

\subsection{Eso-AdenoCA}

\subsubsection{Barplot and general statistics}
```{r EsoAdenoCA1, echo=FALSE}
ct <- "Eso-AdenoCA"
obj_Eso_AdenoCA <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Eso_AdenoCA, legend_on = TRUE)
```

The number of samples and signatures is:
```{r EsoAdenoCA1b, echo=FALSE}
dim(obj_Eso_AdenoCA$Y)
```

The signatures are:
```{r EsoAdenoCA1c, echo=FALSE}
colnames(obj_Eso_AdenoCA$Y)
```


\subsubsection{Convergence table}

None of the fullRE have converged when including all signatures. When including nonexo, all but fullRE_DMSL_nonexo (using either the highest absolute signature or SBS1) have converged.
```{r EsoAdenoCA2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Eso-AdenoCA"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}
Using fullRE_M_nonexo to fit fullRE_DMSL_nonexo
```{r EsoAdenoCA3, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_ME_multinomial"))
ct <- "Eso-AdenoCA"

obj_EsoAdenoCA <- sort_columns_TMB(give_subset_sigs_TMBobj(load_PCAWG(ct = ct, typedata = "signatures",
                                                           path_to_data = "../../data/"),
                                      nonexogenous$V1))
sortedM_EsoAdenoCA <- wrapper_run_TMB(model = "fullRE_M",
                           object = obj_EsoAdenoCA, use_nlminb=T)
sortedM_EsoAdenoCA

```

which has a positive-semidefinite covariance matrix, i.e. has converged

```{r EsoAdenoCA3convergence, echo=FALSE, message=FALSE, dependson=c('libraries')}
sortedM_EsoAdenoCA$pdHess
```

The fullRE DMSL hasn't, though: 
```{r EsoAdenoCA3a2, echo=FALSE, message=FALSE, dependson=c('libraries'), results='hide'}
## use params from ME M for ME DM
TMB::compile("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../2_inference_TMB/mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))

dmin1 <- ncol(obj_EsoAdenoCA$Y)-1

sortedDM_EsoAdenoCA <- wrapper_run_TMB(model = "fullREDMsinglelambda",
                           object = obj_EsoAdenoCA,
                           smart_init_vals = F, use_nlminb = T,
                           initial_params = list(
                             beta = matrix(python_like_select_name(sortedM_EsoAdenoCA$par.fixed, 'beta'), nrow=2),
                             u_large = matrix(sortedM_EsoAdenoCA$par.random, ncol=dmin1),
                             logs_sd_RE=python_like_select_name(sortedM_EsoAdenoCA$par.fixed, 'logs_sd_RE'),
                             cov_par_RE = python_like_select_name(sortedM_EsoAdenoCA$par.fixed, 'cov_par_RE'),
                             log_lambda = 2))
sortedDM_EsoAdenoCA
```

```{r EsoAdenoCA3b, echo=FALSE, message=FALSE, dependson=c('EsoAdenoCA3')}
sortedDM_EsoAdenoCA$pdHess
```


\subsubsection{Potentially problematic signatures}

We notice that there are no truly problematic signatures (SBS30 has the most zeros; 54.6\%).
```{r, EsoAdenoCA1d}
colSums(obj_Eso_AdenoCA$Y == 0)/nrow(obj_Eso_AdenoCA$Y)
colSums(obj_Eso_AdenoCA$Y)/sum(obj_Eso_AdenoCA$Y)
```

\subsubsection{Betas}

```{r, EsoAdenoCA_betas}
ct <- "Eso-AdenoCA"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```


```{r, EsoAdenoCA_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Eso_AdenoCA <- wald_TMB_wrapper(diagRE_DMSL_nonexo[["Eso-AdenoCA"]])
```
We use the results from the diag RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Eso_AdenoCA`.

\subsubsection{Covariance matrices}

```{r, EsoAdenoCA_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Eso_AdenoCA_additional_runs')}
ct <- "Eso-AdenoCA"
# models_it_Eso_AdenoCA <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Eso_AdenoCA <- c('fullRE_M', 'fullRE_M_nonexo')
covmats_Eso_AdenoCA <- lapply(models_it_Eso_AdenoCA,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Eso_AdenoCA) <- models_it_Eso_AdenoCA
## because it's fullRE_M, it's sorted
colnames(covmats_Eso_AdenoCA[['fullRE_M']]) <- rownames(covmats_Eso_AdenoCA[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Eso_AdenoCA)$Y))
colnames(covmats_Eso_AdenoCA[['fullRE_M_nonexo']]) <- rownames(covmats_Eso_AdenoCA[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Eso_AdenoCA, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Eso_AdenoCA)){pheatmap(covmats_Eso_AdenoCA[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Eso_AdenoCA[i])}
```


\subsubsection{Simulation under inferred data}
```{r, EsoAdenoCA_sim, echo=FALSE}
sim_Eso_AdenoCA <- give_sim_from_estimates("Eso-AdenoCA", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="diagRE_DMSL", bool_nonexo = F,
                                       tmb_object=diagRE_DMSL_nonexo[[ct]],
                                      sig_of_interest='SBS2')
sim_Eso_AdenoCA[[2]]+ggtitle('Simulation of Eso-AdenoCA samples')
```

\subsubsection{Ranked plot for coverage}

```{r, EsoAdenoCA_ranked_plot}
ct <- "Eso-AdenoCA"
integer_overdispersion_param_DMSL <- 1
obj_Eso_AdenoCA_nonexo <- give_subset_sigs_TMBobj(obj_Eso_AdenoCA, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Eso_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Eso_AdenoCA_nonexo,
                 loglog = F, title = 'obj_Eso_AdenoCA (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                 data_object = obj_Eso_AdenoCA_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Eso_AdenoCA_nonexo,
           loglog = F, title = 'obj_Eso_AdenoCA (DMSL)'), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, EsoAdenoCA_mutsigextractor}
obj_Eso_AdenoCA_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Eso_AdenoCA_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is a trend of samples with more mutations having more SBS17b and less SBS5, relatively.
```{r, EsoAdenoCA_sortedbynummuts, fig.height=2, fig.width=6}
createBarplot(normalise_rw(non_duplicated_rows(obj_Eso_AdenoCA$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Eso_AdenoCA$Y)),
                                        decreasing = F)))
```


\subsection{Head-SCC}

\subsubsection{Barplot and general statistics}
```{r HeadSCC1, echo=FALSE}
ct <- "Head-SCC"
obj_Head_SCC <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Head_SCC, legend_on = TRUE)
```

The number of samples and signatures is:
```{r HeadSCC1b, echo=FALSE}
dim(obj_Head_SCC$Y)
```

The signatures are:
```{r HeadSCC1c, echo=FALSE}
colnames(obj_Head_SCC$Y)
```

\subsubsection{Convergence table}

We don't have converged results for the multinomial with full RE, but for nonexogenous signatures everything has.

```{r HeadSCC2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Head-SCC"
melt(all_summaries) %>% filter(value==ct)
```


\subsubsection{Re-running of fitting}
We don't need refitting, as the results have already converged.


\subsubsection{Potentially problematic signatures}

SBS33 is likely to be problematic.
```{r, HeadSCC1d}
colSums(obj_Head_SCC$Y == 0)/nrow(obj_Head_SCC$Y)
colSums(obj_Head_SCC$Y)/sum(obj_Head_SCC$Y)
```

\subsubsection{Betas}

```{r, HeadSCC_betas}
ct <- "Head-SCC"

grid.arrange(plot_betas(fullRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
             plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
             plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
             plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
  plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
  plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```


```{r, HeadSCC_DA, echo=FALSE, message=FALSE, results='hide'}
pval_Head_SCC <- wald_TMB_wrapper(fullRE_DMSL_nonexo[["Head-SCC"]])
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Head_SCC`.

\subsubsection{Covariance matrices}

```{r, HeadSCC_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Head_SCC_additional_runs')}
ct <- "Head-SCC"
# models_it_Head_SCC <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Head_SCC <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_Head_SCC <- lapply(models_it_Head_SCC,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Head_SCC) <- models_it_Head_SCC
## because it's fullRE_M, it's sorted
colnames(covmats_Head_SCC[['fullRE_M']]) <- rownames(covmats_Head_SCC[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Head_SCC)$Y))
colnames(covmats_Head_SCC[['fullRE_M_nonexo']]) <- rownames(covmats_Head_SCC[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Head_SCC, nonexogenous$V1)$Y))
colnames(covmats_Head_SCC[['fullRE_DMSL_nonexo']]) <- rownames(covmats_Head_SCC[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Head_SCC, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Head_SCC)){pheatmap(covmats_Head_SCC[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Head_SCC[i])}
```

\subsubsection{Simulation under inferred data}
```{r, HeadSCC_sim, echo=FALSE}
sim_Head_SCC <- give_sim_from_estimates("Head-SCC", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = F, sig_of_interest="SBS2",
                                       tmb_object=fullRE_DMSL_nonexo[["Head-SCC"]])
sim_Head_SCC[[2]]+ggtitle('Simulation of Head-SCC samples')

```

\subsubsection{Ranked plot for coverage}

```{r, HeadSCC_ranked_plot}
ct <- "Head-SCC"
integer_overdispersion_param_DMSL <- 1
obj_Head_SCC_nonexo <- give_subset_sigs_TMBobj(obj_Head_SCC, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Head_SCC_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Head_SCC_nonexo,
                 loglog = F, title = 'obj_Head_SCC (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[[ct]],
                 data_object = obj_Head_SCC_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Head_SCC_nonexo,
           loglog = F, title = 'obj_Head_SCC (DMSL)'), ncol=2)
```

\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, HeadSCC_mutsigextractor}
obj_Head_SCC_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Head_SCC_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.
```{r, HeadSCC_sortedbynummuts, fig.height=2, fig.width=6}
createBarplot(normalise_rw(non_duplicated_rows(obj_Head_SCC$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Head_SCC$Y)),
                                        decreasing = F)))
```

\subsection{Kidney-ChRCC}

\subsubsection{Barplot and general statistics}
```{r KidneyChRCC1, echo=FALSE}
ct <- "Kidney-ChRCC"
obj_Kidney_ChRCC <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Kidney_ChRCC, legend_on = TRUE)
```

The number of samples and signatures is:
```{r KidneyChRCC1b, echo=FALSE}
dim(obj_Kidney_ChRCC$Y)
```

The signatures are:
```{r KidneyChRCC1c, echo=FALSE}
colnames(obj_Kidney_ChRCC$Y)
```

\subsubsection{Convergence table}

For all signatures, no fullRE model has converged. For nonexogenous ones, all have.
```{r KidneyChRCC2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Kidney-ChRCC"
melt(all_summaries) %>% filter(value==ct)
```

\subsubsection{Re-running of fitting}
We do not need to re-run any model fitting.

\subsubsection{Potentially problematic signatures}

We notice that SBS17a and SBS17b are perhaps problematic.
```{r, KidneyChRCC1d}
colSums(obj_Kidney_ChRCC$Y == 0)/nrow(obj_Kidney_ChRCC$Y)
colSums(obj_Kidney_ChRCC$Y)/sum(obj_Kidney_ChRCC$Y)
```


\subsubsection{Betas}

```{r, KidneyChRCC_betas}
ct <- "Kidney-ChRCC"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')),
plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')), nrow=2)
```


```{r, KidneyChRCC_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Kidney-ChRCC"
pval_Kidney_ChRCC <- wald_TMB_wrapper(fullRE_DMSL_nonexo[[ct]])
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Kidney_ChRCC`.

\subsubsection{Covariance matrices}

```{r, KidneyChRCC_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Kidney_ChRCC_additional_runs')}
ct <- "Kidney-ChRCC"
# models_it_Kidney_ChRCC <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Kidney_ChRCC <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_Kidney_ChRCC <- lapply(models_it_Kidney_ChRCC,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Kidney_ChRCC) <- models_it_Kidney_ChRCC
## because it's fullRE_M, it's sorted
colnames(covmats_Kidney_ChRCC[['fullRE_M']]) <- rownames(covmats_Kidney_ChRCC[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Kidney_ChRCC)$Y))
colnames(covmats_Kidney_ChRCC[['fullRE_M_nonexo']]) <- rownames(covmats_Kidney_ChRCC[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Kidney_ChRCC, nonexogenous$V1)$Y))
colnames(covmats_Kidney_ChRCC[['fullRE_DMSL_nonexo']]) <- rownames(covmats_Kidney_ChRCC[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Kidney_ChRCC, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Kidney_ChRCC)){pheatmap(covmats_Kidney_ChRCC[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Kidney_ChRCC[i])}
```


\subsubsection{Simulation under inferred data}
```{r, KidneyChRCC_sim, echo=FALSE}
sim_Kidney_ChRCC <- give_sim_from_estimates("Kidney-ChRCC", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = F,
                                       tmb_object=fullRE_DMSL_nonexo[["Kidney-ChRCC"]], sig_of_interest='SBS17b')
sim_Kidney_ChRCC[[2]]+ggtitle('Simulation of Kidney-ChRCC samples')

```


\subsubsection{Ranked plot for coverage}

```{r, KidneyChRCC_ranked_plot}
ct <- "Kidney-ChRCC"
integer_overdispersion_param_DMSL <- 1
obj_Kidney_ChRCC_nonexo <- give_subset_sigs_TMBobj(obj_Kidney_ChRCC, sigs_to_remove = nonexogenous$V1)
grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                 data_object = obj_Kidney_ChRCC_nonexo,
                 print_plot = F, nreps = 20, model = "M")), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Kidney_ChRCC_nonexo,
                 loglog = F, title = 'obj_Kidney_ChRCC (M)'),
 give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[["Kidney-ChRCC"]],
                 data_object = obj_Kidney_ChRCC_nonexo,
                 print_plot = F, nreps = 20, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                   lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                          rank_number=1:length(j)) )})[[1]],
                 data_object = obj_Kidney_ChRCC_nonexo,
           loglog = F, title = 'obj_Kidney_ChRCC (DMSL)'), ncol=2)
```


\subsubsection{Signatures from mutSigExtractor}

The signatures from mutSigExtractor are as follows:
```{r, KidneyChRCC_mutsigextractor}
obj_Kidney_ChRCC_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Kidney_ChRCC_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: there is no trend of signatures being associated with the number of mutations.
```{r, KidneyChRCC_sortedbynummuts, fig.height=2, fig.width=6}
createBarplot(normalise_rw(non_duplicated_rows(obj_Kidney_ChRCC$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Kidney_ChRCC$Y)),
                                        decreasing = F)))
```

\subsection{Kidney-RCC.clearcell}
\subsection{Kidney-RCC.papillary}
\subsection{Liver-HCC}
\subsection{Lung-AdenoCA}
\subsection{Lung-SCC}
\subsection{Lymph-BNHL}
\subsection{Lymph-CLL}

\subsubsection{Barplot and general statistics}
```{r LymphCLL1, echo=FALSE}
ct <- "Lymph-CLL"
obj_Lymph_CLL <- load_PCAWG(ct = ct, typedata = "signatures",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Lymph_CLL, legend_on = TRUE)
```



The number of samples and signatures is:
```{r LymphCLL1b, echo=FALSE}
dim(obj_Lymph_CLL$Y)
```

The signatures are:
```{r LymphCLL1c, echo=FALSE}
colnames(obj_Lymph_CLL$Y)
```


\subsubsection{Convergence table}

We have converged results in most cases

```{r LymphCLL2, echo=FALSE, dependson=c('summary_convergence')}
ct <- "Lymph-CLL"
melt(all_summaries) %>% filter(value==ct)
```


\subsubsection{Potentially problematic signatures}
SBS9 has quite a lot of zeros.
```{r, LymphCLL1d}
colSums(obj_Lymph_CLL$Y == 0)/nrow(obj_Lymph_CLL$Y)
colSums(obj_Lymph_CLL$Y)/sum(obj_Lymph_CLL$Y)
```



\subsubsection{Betas}

```{r, LymphCLL_betas}
ct <- "Lymph-CLL"

grid.arrange(plot_betas(diagRE_M[[ct]])+ggtitle(paste0(ct, '\n diagRE_M')),
plot_betas(fullRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL')),
plot_betas(diagRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL')),
plot_betas(sparseRE_DMSL[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL')), nrow=2)

grid.arrange(
  plot_betas(fullRE_M_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_M_nonexo')),
  plot_betas(diagRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n diagRE_DMSL_nonexo')),
  plot_betas(sparseRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n sparseRE_DMSL_nonexo')),
  plot_betas(fullRE_DMSL_nonexo[[ct]])+ggtitle(paste0(ct, '\n fullRE_DMSL_nonexo')), nrow=2)
```




```{r, LymphCLL_DA, echo=FALSE, message=FALSE, results='hide'}
ct <- "Lymph-CLL"
pval_Lymph_CLL <- wald_TMB_wrapper(fullRE_DMSL_nonexo[[ct]])
```
We use the results from the full RE single lambda DM to test for differential abundance, giving a p-value of `r pval_Lymph_CLL`.


\subsubsection{Covariance matrices}



```{r, LymphCLL_cov, echo=FALSE, message=FALSE, fig.height=3.7, fig.width=3.7, dependson=c('Lymph_CLL_additional_runs')}
ct <- "Lymph-CLL"
# models_it_Lymph_CLL <- c('fullRE_M', 'sparseRE_DMSL', 'fullRE_M_nonexo')
models_it_Lymph_CLL <- c('fullRE_M', 'fullRE_M_nonexo', 'fullRE_DMSL_nonexo')
covmats_Lymph_CLL <- lapply(models_it_Lymph_CLL,
                                 function(i){
     fill_covariance_matrix(arg_d = length(python_like_select_name(get(i)[[ct]]$par.fixed, 'beta'))/2,
                            arg_entries_var = python_like_select_name(get(i)[[ct]]$par.fixed, 'logs_sd_RE'),
                            arg_entries_cov = python_like_select_name(get(i)[[ct]]$par.fixed, 'cov_par_RE'))
                                 })
names(covmats_Lymph_CLL) <- models_it_Lymph_CLL
## because it's fullRE_M, it's sorted
colnames(covmats_Lymph_CLL[['fullRE_M']]) <- rownames(covmats_Lymph_CLL[['fullRE_M']]) <- vector_cats_to_logR(colnames(sort_columns_TMB(obj_Lymph_CLL)$Y))
colnames(covmats_Lymph_CLL[['fullRE_M_nonexo']]) <- rownames(covmats_Lymph_CLL[['fullRE_M_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Lymph_CLL, nonexogenous$V1)$Y))
colnames(covmats_Lymph_CLL[['fullRE_DMSL_nonexo']]) <- rownames(covmats_Lymph_CLL[['fullRE_DMSL_nonexo']]) <- vector_cats_to_logR(colnames(give_subset_sigs_TMBobj(obj_Lymph_CLL, nonexogenous$V1)$Y))

for(i in 1:length(covmats_Lymph_CLL)){pheatmap(covmats_Lymph_CLL[[i]], cluster_rows = F, cluster_cols = F, main = models_it_Lymph_CLL[i])}
```




\subsubsection{Simulation under inferred data}
```{r, LymphCLL_sim, echo=FALSE}
sim_Lymph_CLL <- give_sim_from_estimates("Lymph-CLL", "signatures",
                                      sigs_to_remove=unique(nonexogenous$V1),
                                      bool_give_PCA = T, path_to_data= "../../data/",
                                      model="fullRE_DMSL", bool_nonexo = F,
                                       tmb_object=fullRE_DMSL_nonexo[["Lymph-CLL"]], sig_of_interest='SBS9')
sim_Lymph_CLL[[2]]+ggtitle('Simulation of Lymph-CLL samples')

```



\subsubsection{Ranked plot for coverage}

```{r, LymphCLL_ranked_plot}
ct <- "Lymph-CLL"
integer_overdispersion_param_DMSL <- 1
obj_Lymph_CLL_nonexo <- give_subset_sigs_TMBobj(obj_Lymph_CLL, sigs_to_remove = nonexogenous$V1)
for(loglog_bool_it in c(T,F)){
  .full_rankedplot <-    give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_DMSL_nonexo[["Lymph-CLL"]],
                   data_object = obj_Lymph_CLL_nonexo,
                   print_plot = F, nreps = 100, model = "DMSL", integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                     lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                            rank_number=1:length(j)) )})[[1]],
                   data_object = obj_Lymph_CLL_nonexo,
             loglog = loglog_bool_it, title = 'obj_Lymph_CLL nonexo (fullRE DMSL)')
  grid.arrange(
    give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = fullRE_M_nonexo[[ct]],
                   data_object = obj_Lymph_CLL_nonexo,
                   print_plot = F, nreps = 100, model = "M")), function(i){
                     lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                            rank_number=1:length(j)) )})[[1]],
                   data_object = obj_Lymph_CLL_nonexo,
                   loglog = loglog_bool_it, title = 'obj_Lymph_CLL nonexo (M)'),
    .full_rankedplot, ncol=2)

  grid.arrange(give_interval_plots_2(df_rank = lapply(list(give_ranked_plot_simulation(tmb_fit_object = diagRE_DMSL_nonexo[[ct]],
                   data_object = obj_Lymph_CLL_nonexo,
                   print_plot = F, nreps = 100, model = "DMSL",
                   integer_overdispersion_param = integer_overdispersion_param_DMSL)), function(i){
                     lapply(i, function(j) cbind.data.frame(sorted_value=as.vector(j),
                                                            rank_number=1:length(j)) )})[[1]],
                   data_object = obj_Lymph_CLL_nonexo,
                   loglog = loglog_bool_it, title = 'obj_Lymph_CLL nonexo (diagRE DMSL)'),
               .full_rankedplot, ncol=2)

}
```


\subsubsection{Signatures from mutSigExtractor}

These are the signatures from mutSigExtractor:
```{r, LymphCLL_mutsigextractor}
obj_Lymph_CLL_mutSigExtractor <- load_PCAWG(ct = ct, typedata = "signaturesmutSigExtractor",
                                   path_to_data = "../../data/")
give_barplot_from_obj(obj = obj_Lymph_CLL_mutSigExtractor, legend_on = FALSE)
```

Exposures sorted by increasing number of mutations: SBS9 and SBS25 seem to be somewhat associated with samples with a high number of mutations.
```{r, LymphCLL_sortedbynummuts}
createBarplot(normalise_rw(non_duplicated_rows(obj_Lymph_CLL$Y)),
              order_labels = names(sort(rowSums(non_duplicated_rows(obj_Lymph_CLL$Y)),
                                        decreasing = F)))
```


\subsection{Myeloid-MPN}
\subsection{Ovary-AdenoCA}
\subsection{Panc-AdenoCA}
\subsection{Panc-Endocrine}
\subsection{Prost-AdenoCA}
\subsection{Skin-Melanoma.acral}
\subsection{Skin-Melanoma.cutaneous}
\subsection{Stomach-AdenoCA}
\subsection{Thy-AdenoCA}
\subsection{Uterus-AdenoCA}


\section{All p-values for non-exogenous signatures}

```{r, all_pvals_improved, echo=FALSE, results='asis'}
all_pvals <- rbind.data.frame(cbind.data.frame(ct='Bone-Osteosarc', pvalue=pval_bone_osteosarc, model='diagRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Breast-AdenoCA', pvalue=pval_Breast_AdenoCA, model='diagRE_DMSL_nonexo'),
                              cbind.data.frame(ct='Cervix-SCC', pvalue=pval_Cervix_SCC, model='fullRE_DMSL_nonexo') ,
                              cbind.data.frame(ct='CNS-Oligo', pvalue=pval_CNS_Oligo, model='fullRE_DMSL_nonexo')
                              )

xtable::print.xtable(xtable::xtable(all_pvals), digits=c(0,10,0))

```


\section{Dirichlet-Multinomial Mixtures}

We run the software \verb|MicrobeDMMv1.0| to determine whether we are facing DMM mixtures or not.

We save the files in two ways: all of the samples - early or not - together, and separately.

In some cases DMM says that there is an error with the input file - in this case the AIC or BIC is not plotted. If all of them are missing, all BIC and AIC are set to zero.


```{r, save_files_dmm, echo=FALSE}

roo_obj <- sapply(fles_roo[grepl('_signatures_', fles_roo)], readRDS)
for(i in 1:length(roo_obj)){
  if(!rlang::is_empty(attr(roo_obj[[i]], "count_matrices_active")[[1]])){
    write.table(cbind.data.frame(c('Taxa', colnames(attr(roo_obj[[i]], "count_matrices_active")[[1]])),
                                 rbind.data.frame(rownames(attr(roo_obj[[i]],
                                                                "count_matrices_active")[[1]]),
                                                  round(t(attr(roo_obj[[i]], "count_matrices_active")[[1]])))),
                file = paste0("../../data/roo_for_DMM/", gsub("_ROO.RDS", "", basename(names(roo_obj)))[i], "_early.csv"), sep = ",", row.names = FALSE, col.names = FALSE, quote = FALSE)
    
    write.table(cbind.data.frame(c('Taxa', colnames(attr(roo_obj[[i]], "count_matrices_active")[[2]])),
                                 rbind.data.frame(rownames(attr(roo_obj[[i]],
                                                                "count_matrices_active")[[2]]),
                                                  round(t(attr(roo_obj[[i]], "count_matrices_active")[[2]])))),
                file = paste0("../../data/roo_for_DMM/", gsub("_ROO.RDS", "", basename(names(roo_obj)))[i], "_late.csv"), sep = ",", row.names = FALSE, col.names = FALSE, quote = FALSE)
    
    ## write all
      write.table(cbind.data.frame(c('Taxa', colnames(attr(roo_obj[[i]], "count_matrices_active")[[1]])),
         rbind.data.frame(c(paste0(rownames(attr(roo_obj[[i]],
                                                 "count_matrices_active")[[1]]), '-early'),
                            paste0(rownames(attr(roo_obj[[i]],
                                                 "count_matrices_active")[[2]]), '-late')),
                          round(cbind.data.frame(t(attr(roo_obj[[i]],
                                                        "count_matrices_active")[[1]]),
                                                 t(attr(roo_obj[[i]],
                                                        "count_matrices_active")[[2]]))))),
         file = paste0("../../data/roo_for_DMM/",
                       gsub("_ROO.RDS", "", basename(names(roo_obj)))[i], "_all.csv"),
         sep = ",", row.names = FALSE, col.names = FALSE, quote = FALSE)
              
  }  
}

```
<!-- (base) FVFXDASHHV29:roo_for_DMM morril01$ pwd -->
<!-- /Users/morril01/Documents/PhD/GlobalDA/data/roo_for_DMM -->
<!-- (base) FVFXDASHHV29:roo_for_DMM morril01$ cat run.sh  -->
<!-- /Users/morril01/software/MicrobeDMMv1.0/DirichletMixtureGHPFit -in Biliary-AdenoCA_signatures_early.csv -out Biliary-AdenoCA_signatures_early_DMM -k 4 -->


```{r, analyse_files_dmm, echo=FALSE, warning=FALSE, message=FALSE, results='hide'}
z_DMM <- lapply(enough_samples, function(ct){
  list(all=lapply(1:8, function(k) try(read.table(paste0("../../data/roo_for_DMM/DMM_output/", ct, "_signatures_all", k, "_dmm.z"), sep = ',', skip = 1))),
       early=lapply(1:8, function(k) try(read.table(paste0("../../data/roo_for_DMM/DMM_output/", ct, "_signatures_early", k, "_dmm.z"), sep = ',', skip = 1))),
       late=lapply(1:8, function(k) try(read.table(paste0("../../data/roo_for_DMM/DMM_output/", ct, "_signatures_late", k, "_dmm.z"), sep = ',', skip = 1))))
})
names(z_DMM) <- enough_samples

# (# of clusters) Evidence, Negative Log Determinant, Laplace Approximation, BIC and AIC are also sent to stdout at the end and written to a file stub.fit.
fit_DMM <- lapply(enough_samples, function(ct){
  list(all=lapply(1:8, function(k) try(read.table(paste0("../../data/roo_for_DMM/DMM_output/", ct, "_signatures_all", k, "_dmm.fit"), sep = ' '))),
       early=lapply(1:8, function(k) try(read.table(paste0("../../data/roo_for_DMM/DMM_output/", ct, "_signatures_early", k, "_dmm.fit"), sep = ' '))),
       late=lapply(1:8, function(k) try(read.table(paste0("../../data/roo_for_DMM/DMM_output/", ct, "_signatures_late", k, "_dmm.fit"), sep = ' '))))
})
names(fit_DMM) <- enough_samples
```

```{r, some_functions, echo=FALSE}
na_to_zero <- function(i) if(all(is.na(i))){i[is.na(i)] = 0; i}else{i}
```


```{r, analyse_files_dmm_find_k, fig.height=1.5, echo=FALSE, message=FALSE}

# (# of clusters) Evidence, Negative Log Determinant, Laplace Approximation, BIC and AIC are also sent to stdout at the end and written to a file stub.fit.

par(mfrow=c(1,6), mar=c(1.8, 1.8, 1.8, 1.8))
invisible(sapply(names(fit_DMM), function(j_name){
  j=fit_DMM[[j_name]]
  plot(1:8, na_to_zero(sapply(j$all, function(jj) if(! (typeof(jj) == "character")){jj[4]}else{NA})), xlab='k', ylab='BIC', main=j_name)
  plot(1:8, na_to_zero(sapply(j$all, function(jj) if(! (typeof(jj) == "character")){jj[5]}else{NA})), xlab='k', ylab='AIC', main=j_name)
  plot(1:8, na_to_zero(sapply(j$early, function(jj) if(! (typeof(jj) == "character")){jj[4]}else{NA})), xlab='k', ylab='BIC', main=j_name)
  plot(1:8, na_to_zero(sapply(j$early, function(jj) if(! (typeof(jj) == "character")){jj[5]}else{NA})), xlab='k', ylab='AIC', main=j_name)
  plot(1:8, na_to_zero(sapply(j$late, function(jj) if(! (typeof(jj) == "character")){jj[4]}else{NA})), xlab='k', ylab='BIC', main=j_name)
  plot(1:8, na_to_zero(sapply(j$late, function(jj) if(! (typeof(jj) == "character")){jj[5]}else{NA})), xlab='k', ylab='AIC', main=j_name)
}))

j=fit_DMM[[1]]

# z_DMM$`CNS-GBM`$all

# z_DMM$`Bone-Osteosarc`

# xxxx <- try(read.table(paste0("../../data/roo_for_DMM/DMM_output/", ct, "_signatures_all.z"), sep = ',', skip = 1))

# table(apply(xxxx[grepl('_early', xxxx$V1),-1], 1, which.max),
#       apply(xxxx[grepl('_late', xxxx$V1),-1], 1, which.max))

```


\newpage

## Comparison of signature exposures with QP and mutsigextractor
```{r, to_del}
signature_mutsigextractor_roo2 <- sapply(fles_roo[grepl('_signaturesmutSigExtractor_', fles_roo)], readRDS)
roo_obj2 <- roo_obj
names(signature_mutsigextractor_roo2) <- gsub("_signaturesmutSigExtractor_ROO.RDS", "", basename(names(signature_mutsigextractor_roo2)))
names(roo_obj2) <- gsub("_signatures_ROO.RDS", "", basename(names(roo_obj2)))
```

```{r, comparison_signatures_mutextractor, eval=TRUE}

par(mfrow=c(2,3))
for(i in names(roo_obj2)){
  try({

  sig1 <- roo_obj2[[i]]
  sig2 <- signature_mutsigextractor_roo2[[i]]

  sig1 <- do.call('rbind', sig1@count_matrices_active)
  sig2 <- do.call('rbind', sig2@count_matrices_all)

  sig2 <- as.vector(sig2[,match(colnames(sig1), colnames(sig2))])
  sig1 <- as.vector(sig1)
  plot(sig1, sig2)
  })
}
```

```{r, all_pvals_2}
cbind.data.frame(pvals_fullRE_M=pvals_fullRE_M,
                 pvals_diagRE_DM=pvals_diagRE_DM,
                 pvals_DM=pvals_DM,
                 pvals_DMnonexo=pvals_DMnonexo)

```