#         LEvalNum <- LEvalNum + 1
#         if (alpha == step.max) {
#           step.max <- max(step.max0, step.max/mstep)
#         }
#         alpha <- 1
#       }
#       else {
#         useSquareEM <- useSquareEM + 1
#       }
#     }
#     if (isTRUE(all.equal(alpha, step.max))) {
#       step.max <- mstep * step.max
#     }
#     if (step.min < 0 & isTRUE(all.equal(alpha, step.min))) {
#       step.min <- mstep * step.min
#     }
#     p <- p.new
#     if (abs(prevL - newL) < tol) {
#       convFlag <- TRUE
#       break
#     }
#     if (!is.nan(newL)) {
#       prevL <- newL
#     }
#   }
#   calcTime <- proc.time() - startTime
#   return(list(par = p, value.objfn = newL, itr = iterNum, fpeval = updEvalNum,
#               convergence = convFlag, elapsed.time = calcTime[3]))
# }
LM_mySquareEM <- function (p, y, tol = 1e-04, maxIter = 10000, patternNum, samplePatternNum){
prevL <- -Inf
step.min <- 1
step.max <- 1
step.max0 <- 1
mstep <- 4
objfn.inc <- 1
updEvalNum <- 0
LEvalNum <- 0
useSquareEM <- 0
iterNum <- 0
convFlag <- FALSE
startTime <- proc.time()
newL <- LM_calcPMSLikelihood(p, y, patternNum, samplePatternNum)
LEvalNum <- LEvalNum + 1
for (iterNum in 1:maxIter) {
p1 <- pmsignature:::updatePMSParam(p, y)
updEvalNum <- updEvalNum + 1
if (any(is.nan(unlist(p1)))) {
stop("Error in function evaluation")
}
q1 <- p1 - p
sr2 <- crossprod(q1)
p2 <- pmsignature:::updatePMSParam(p1, y)
updEvalNum <- updEvalNum + 1
if (any(is.nan(unlist(p2)))) {
stop("Error in function evaluation")
}
q2 <- p2 - p1
sq2 <- sqrt(crossprod(q2))
sv2 <- crossprod(q2 - q1)
srv <- crossprod(q1, q2 - q1)
alpha <- -srv/sv2
alpha <- max(step.min, min(step.max, alpha))
p.new <- p + 2 * alpha * q1 + alpha^2 * (q2 - q1)
if (isTRUE(abs(alpha - 1) > 0.01)) {
p.new <- pmsignature:::updatePMSParam(p.new, y)
updEvalNum <- updEvalNum + 1
}
if (any(is.nan(p.new)) | !pmsignature:::PMSboundary(y)(p.new)) {
p.new <- p2
newL <- LM_calcPMSLikelihood(p2, y, patternNum, samplePatternNum)
LEvalNum <- LEvalNum + 1
if (isTRUE(all.equal(alpha, step.max))) {
step.max <- max(step.max0, step.max/mstep)
}
alpha <- 1
}
else {
newL <- LM_calcPMSLikelihood(p.new, y, patternNum, samplePatternNum)
LEvalNum <- LEvalNum + 1
if (is.nan(newL) | (newL > prevL + objfn.inc)) {
p.new <- p2
lnew <- LM_calcPMSLikelihood(p2, y, patternNum, samplePatternNum)
LEvalNum <- LEvalNum + 1
if (alpha == step.max) {
step.max <- max(step.max0, step.max/mstep)
}
alpha <- 1
}
else {
useSquareEM <- useSquareEM + 1
}
}
if (isTRUE(all.equal(alpha, step.max))) {
step.max <- mstep * step.max
}
if (step.min < 0 & isTRUE(all.equal(alpha, step.min))) {
step.min <- mstep * step.min
}
p <- p.new
if (abs(prevL - newL) < tol) {
convFlag <- TRUE
break
}
if (!is.nan(newL)) {
prevL <- newL
}
}
calcTime <- proc.time() - startTime
return(list(par = p, value.objfn = newL, itr = iterNum, fpeval = updEvalNum,
convergence = convFlag, elapsed.time = calcTime[3]))
}
# <bytecode: 0x7fb1aa350f28>
#   <environment: namespace:pmsignature>
#
# pmsignature:::calcPMSLikelihood
# function (p, y)
# {
#   sampleNum <- y[[1]][[1]]
#   fdim <- y[[1]][[2]]
#   patternList <- y[[1]][[3]]
#   sparseCount <- y[[1]][[4]]
#   K <- y[[2]]
#   isBG <- y[[3]]
#   BG0 <- y[[4]]
#   patternNum <- ncol(patternList)
#   samplePatternNum <- ncol(sparseCount)
#   if (isBG) {
#     varK <- K - 1
#   }
#   else {
#     varK <- K
#   }
#   lenF <- varK * (sum(fdim) - length(fdim))
#   lenQ <- (K - 1) * sampleNum
#   F <- convertFromTurbo_F(p[1:lenF], fdim, K, isBG)
#   Q <- convertFromTurbo_Q(p[(lenF + 1):(lenF + lenQ)], K, sampleNum)
#   dim(Q) <- c(sampleNum, K)
#   Q <- t(Q)
#   return(getLogLikelihoodC(as.vector(patternList), as.vector(sparseCount),
#                            as.vector(F), as.vector(Q), fdim, K, sampleNum, patternNum,
#                            samplePatternNum, isBG, BG0))
# }
# <bytecode: 0x7fb1aa346908>
#   <environment: namespace:pmsignature>
LM_calcPMSLikelihood <- function (p, y, patternNum, samplePatternNum){
##' here y[[1]][[3]] and y[[1]][[4]] are vectors to start with, because we don't have the same number of
##' observations for each feature
sampleNum <- y[[1]][[1]]
fdim <- y[[1]][[2]]
patternList <- y[[1]][[3]]
sparseCount <- y[[1]][[4]]
K <- y[[2]]
isBG <- y[[3]]
BG0 <- y[[4]]
# patternNum <- ncol(patternList)
# samplePatternNum <- ncol(sparseCount)
if (isBG) {
varK <- K - 1
}
else {
varK <- K
}
lenF <- varK * (sum(fdim) - length(fdim))
lenQ <- (K - 1) * sampleNum
F <- pmsignature:::convertFromTurbo_F(p[1:lenF], fdim, K, isBG)
Q <- pmsignature:::convertFromTurbo_Q(p[(lenF + 1):(lenF + lenQ)], K, sampleNum)
dim(Q) <- c(sampleNum, K)
Q <- t(Q)
return(pmsignature:::getLogLikelihoodC((patternList), (sparseCount),
as.vector(F), as.vector(Q), fdim, K, sampleNum, patternNum,
samplePatternNum, isBG, BG0))
}
## getLogLikelihoodC doesn't need to get changed as we already pass only vectors
# pmsignature:::getLogLikelihoodC function (vPatternList, vSparseCount, vF, vQ, fdim, signatureNum,
#                                           sampleNum, patternNum, samplePatternNum, isBackground, vF0)
# {
#   .Call("_pmsignature_getLogLikelihoodC", PACKAGE = "pmsignature",
#         vPatternList, vSparseCount, vF, vQ, fdim, signatureNum,
#         sampleNum, patternNum, samplePatternNum, isBackground,
#         vF0)
# }
# <bytecode: 0x7fb1aa336a20>
#   <environment: namespace:pmsignature>
## Changing the functions so that the observed data is a vector, instead of a matrix
Param <- LM_getPMSignature(mutationFeatureData = G, K = 3, BG = NULL,
patternNum=length(G@possibleFeatures),
samplePatternNum=ncol(slot(G, "countData")))
Param
Param_original <- getPMSignature(mutationFeatureData = G, K = 3, BG = NULL)
Param@signatureFeatureDistribution
Param_original@signatureFeatureDistribution
Param@signatureFeatureDistribution[[1]]
Param@signatureFeatureDistribution[,,1]
Param_original@signatureFeatureDistribution[,,1]
rm(list = ls())
setwd("~/Documents/PhD/GlobalDA/code/2_inference_TMB/")
library(TMB)
library(ggplot2)
library(dplyr)
library(gridExtra)
source("mm_multinomial/helper_functions.R")
source("helper_TMB.R")
source("../2_inference/helper/helper_DA_stan.R") ## for normalise_rw
source("../../../CDA_in_Cancer/code/functions/meretricious/pretty_plots/prettySignatures.R")
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/fullRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/fullRE_ME_dirichletmultinomial"))
TMB::compile("mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))
TMB::compile("mm_multinomial/fullRE_dirichletmultinomial_single_lambda2.cpp", "-std=gnu++17")
dyn.load(dynlib("mm_multinomial/fullRE_dirichletmultinomial_single_lambda2"))
TMB::compile("mm_multinomial/diagRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("mm_multinomial/diagRE_dirichletmultinomial_single_lambda"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/FE_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/FE_dirichletmultinomial"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/diagRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/diagRE_ME_dirichletmultinomial"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda2.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda2"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial_singlecov.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial_singlecov"))
enough_samples = readLines("~/Desktop/CT_sufficient_samples.txt")
df_all_samples = data.frame(do.call('rbind', lapply(enough_samples, function(i) rbind(c(i, 'signatures'), c(i, "nucleotidesubstitution1")))))
nonexogenous = read.table("../../data/cosmic/exogenous_signatures_SBS.txt", sep = "\t", comment.char = "#", fill = F)
library(parallel)
mclapply(which(df_all_samples$X2 == "signatures"),
function(idx){
i = df_all_samples[idx,]
typedata = i[1,2]
obj_subset <- give_subset_sigs_TMBobj(load_PCAWG(ct = i[1,1], typedata = i[1,2]),
sigs_to_remove = unique(nonexogenous$V1))
if(dim(obj_subset$Y)[2] <  dim(load_PCAWG(ct = i[1,1], typedata = i[1,2])$Y)[2]){
x = wrapper_run_TMB_debug(object = obj_subset,
model = "fullRE_M", return_report=T)
x
saveRDS(object = x, file=paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/", "fullRE_nonexo_M_",
paste0(df_all_samples[idx,], collapse = "_"), ".RDS"))
}
})
which(df_all_samples$X2 == "signatures")
idx=1
i = df_all_samples[idx,]
typedata = i[1,2]
obj_subset <- give_subset_sigs_TMBobj(load_PCAWG(ct = i[1,1], typedata = i[1,2]),
sigs_to_remove = unique(nonexogenous$V1))
dim(obj_subset$Y)[2] <  dim(load_PCAWG(ct = i[1,1], typedata = i[1,2])$Y)[2]
x = wrapper_run_TMB_debug(object = obj_subset,
model = "fullRE_M", return_report=T)
x = wrapper_run_TMB(object = obj_subset,  use_nlminb = T, smart_init_vals = T,
model = "fullRE_M")
obj_subset
x = wrapper_run_TMB(object = obj_subset,  use_nlminb = T, smart_init_vals = T,
model = "fullRE_M")
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/fullRE_ME_multinomial"))
x = wrapper_run_TMB(object = obj_subset,  use_nlminb = T, smart_init_vals = T,
model = "fullRE_M")
df_all_samples
mclapply(which(df_all_samples$X2 == "signatures"),
function(idx){
i = df_all_samples[idx,]
typedata = i[1,2]
obj_subset <- give_subset_sigs_TMBobj(load_PCAWG(ct = i[1,1], typedata = i[1,2]),
sigs_to_remove = unique(nonexogenous$V1))
if(dim(obj_subset$Y)[2] <  dim(load_PCAWG(ct = i[1,1], typedata = i[1,2])$Y)[2]){
x = wrapper_run_TMB(object = obj_subset,  use_nlminb = T, smart_init_vals = T,
model = "fullRE_M")
x
saveRDS(object = x, file=paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/", "fullRE_nonexo_M_",
paste0(df_all_samples[idx,], collapse = "_"), ".RDS"))
}
})
mclapply(which(df_all_samples$X2 == "signatures"),
function(idx){
i = df_all_samples[idx,]
typedata = i[1,2]
obj_subset <- give_subset_sigs_TMBobj(load_PCAWG(ct = i[1,1], typedata = i[1,2]),
sigs_to_remove = unique(nonexogenous$V1))
if(dim(obj_subset$Y)[2] <  dim(load_PCAWG(ct = i[1,1], typedata = i[1,2])$Y)[2]){
x = wrapper_run_TMB_debug(object = obj_subset,
model = "diagRE_DM", return_report=T)
x
saveRDS(object = x, file=paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/", "diagRE_nonexo_DM_",
paste0(df_all_samples[idx,], collapse = "_"), ".RDS"))
}})
debugSource('~/Documents/PhD/GlobalDA/current/find_subset_signatures.R')
mclapply(which(df_all_samples$X2 == "signatures"),
function(idx){
i = df_all_samples[idx,]
typedata = i[1,2]
obj_subset <- give_subset_sigs_TMBobj(load_PCAWG(ct = i[1,1], typedata = i[1,2]),
sigs_to_remove = unique(nonexogenous$V1))
if(dim(obj_subset$Y)[2] <  dim(load_PCAWG(ct = i[1,1], typedata = i[1,2])$Y)[2]){
x = wrapper_run_TMB_debug(object = obj_subset,
model = "diagREDMsinglelambda", return_report=T)
x
saveRDS(object = x, file=paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/", "diagRE_nonexo_DMSL_",
paste0(df_all_samples[idx,], collapse = "_"), ".RDS"))
}})
rm(list = ls())
setwd("~/Documents/PhD/GlobalDA/code/2_inference_TMB/")
library(TMB)
library(ggplot2)
library(dplyr)
library(gridExtra)
source("mm_multinomial/helper_functions.R")
source("helper_TMB.R")
source("../2_inference/helper/helper_DA_stan.R") ## for normalise_rw
source("../../../CDA_in_Cancer/code/functions/meretricious/pretty_plots/prettySignatures.R")
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/fullRE_ME_multinomial"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/fullRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/fullRE_ME_dirichletmultinomial"))
TMB::compile("mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))
TMB::compile("mm_multinomial/fullRE_dirichletmultinomial_single_lambda2.cpp", "-std=gnu++17")
dyn.load(dynlib("mm_multinomial/fullRE_dirichletmultinomial_single_lambda2"))
TMB::compile("mm_multinomial/diagRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("mm_multinomial/diagRE_dirichletmultinomial_single_lambda"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/FE_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/FE_dirichletmultinomial"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/diagRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/diagRE_ME_dirichletmultinomial"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda2.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda2"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial_singlecov.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial_singlecov"))
enough_samples = readLines("~/Desktop/CT_sufficient_samples.txt")
df_all_samples = data.frame(do.call('rbind', lapply(enough_samples, function(i) rbind(c(i, 'signatures'), c(i, "nucleotidesubstitution1")))))
nonexogenous = read.table("../../data/cosmic/exogenous_signatures_SBS.txt", sep = "\t", comment.char = "#", fill = F)
library(parallel)
enough_samples
mclapply(which(df_all_samples$X2 == "signatures"),
function(idx){
i = df_all_samples[idx,]
typedata = i[1,2]
obj_subset <- give_subset_sigs_TMBobj(load_PCAWG(ct = i[1,1], typedata = i[1,2]),
sigs_to_remove = unique(nonexogenous$V1))
if(dim(obj_subset$Y)[2] <  dim(load_PCAWG(ct = i[1,1], typedata = i[1,2])$Y)[2]){
x = wrapper_run_TMB_debug(object = obj_subset,
model = "diagREDMsinglelambda", return_report=T)
x
saveRDS(object = x, file=paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/", "diagRE_nonexo_DMSL_",
paste0(df_all_samples[idx,], collapse = "_"), ".RDS"))
}})
give_ranked_plot_simulation = function(tmb_fit_object, data_object, print_plot = T, nreps = 1, model){
if(model == 'M'){
## theta is always going to be the same. Only replicate the draws from the multinomial
sim_theta = simulate_from_M_TMB(tmb_fit_object = tmb_fit_object, full_RE = T,
x_matrix = data_object$x, z_matrix = data_object$z)
sim_counts = t(sapply(1:nrow(sim_theta), function(i) rmultinom(n = 1, size = sum(data_object$Y[i,]), prob = sim_theta[i,]) ) )
if(nreps>1){
sim_counts = replicate(nreps, t(sapply(1:nrow(sim_theta), function(i) rmultinom(n = 1, size = sum(data_object$Y[i,]), prob = sim_theta[i,]) ) ), simplify = F)
}
}else if(model == 'DM'){
give_sim_data = function(){
sim_theta = simulate_from_DM_TMB(tmb_fit_object = tmb_fit_object, full_RE = T,
x_matrix = data_object$x, z_matrix = data_object$z, integer_overdispersion_param=integer_overdispersion_param)
sim_counts = t(sapply(1:nrow(sim_theta), function(i) rmultinom(n = 1, size = sum(data_object$Y[i,]), prob = sim_theta[i,]) ) )
return(sim_counts)
}
if(nreps>1){
sim_counts = replicate(nreps, give_sim_data(), simplify = F)
}else{
sim_counts = give_sim_data()
}
}else{
stop('Specify a correct model')
}
stopifnot(all(dim(data_object$Y) == dim(sim_counts)))
if(print_plot)  plot(sort(data_object$Y), sort(sim_counts))
return(sim_counts)
}
simulate_from_M_TMB = function(tmb_fit_object, full_RE=T, x_matrix, z_matrix){
dmin1 = length(python_like_select_name(tmb_fit_object$par.fixed, 'beta'))/2
if(full_RE){
re_mat = re_vector_to_matrix(tmb_fit_object$par.random, dmin1)
ntimes2 = nrow(z_matrix)
logRmat = z_matrix %*% re_mat +
x_matrix %*% matrix(python_like_select_name(tmb_fit_object$par.fixed, 'beta'), nrow=2)
sim_thetas = softmax(cbind(logRmat, 0))
}else{
sim_thetas = softmax(cbind(sapply(1:dmin1,
function(some_dummy_idx) give_z_matrix(length(tmb_fit_object$par.random) * 2) %*% tmb_fit_object$par.random) +
give_x_matrix(length(tmb_fit_object$par.random) * 2) %*% matrix(python_like_select_name(tmb_fit_object$par.fixed, 'beta'), nrow=2), 0))
}
return(sim_thetas)
}
simulate_from_DM_TMB = function(tmb_fit_object, full_RE=T, x_matrix, z_matrix, integer_overdispersion_param){
dmin1 = length(python_like_select_name(tmb_fit_object$par.fixed, 'beta'))/2
overdispersion_lambda = integer_overdispersion_param*exp(python_like_select_name(tmb_fit_object$par.fixed, "log_lambda")[x_matrix[,2]+1])
if(full_RE){
re_mat = re_vector_to_matrix(tmb_fit_object$par.random, dmin1)
ntimes2 = nrow(z_matrix)
logRmat = z_matrix %*% re_mat +
x_matrix %*% matrix(python_like_select_name(tmb_fit_object$par.fixed, 'beta'), nrow=2)
sim_thetas = t(sapply(1:nrow(logRmat), function(l) MCMCpack::rdirichlet(1, overdispersion_lambda[l]* softmax(c(logRmat[l,], 0)))))
}else{
sim_thetas = softmax(cbind(sapply(1:dmin1,
function(some_dummy_idx) give_z_matrix(length(tmb_fit_object$par.random) * 2) %*% tmb_fit_object$par.random) +
give_x_matrix(length(tmb_fit_object$par.random) * 2) %*% matrix(python_like_select_name(tmb_fit_object$par.fixed, 'beta'), nrow=2), 0))
sim_thetas = t(sapply(1:nrow(logRmat), function(l) MCMCpack::rdirichlet(1, overdispersion_lambda[l]* sim_thetas[l,])))
}
return(sim_thetas)
}
simulate_from_DMSL_TMB = function(tmb_fit_object, full_RE=T, x_matrix, z_matrix, integer_overdispersion_param){
dmin1 = length(python_like_select_name(tmb_fit_object$par.fixed, 'beta'))/2
overdispersion_lambda = integer_overdispersion_param*exp(python_like_select_name(tmb_fit_object$par.fixed, "log_lambda"))
if(full_RE){
re_mat = re_vector_to_matrix(tmb_fit_object$par.random, dmin1)
ntimes2 = nrow(z_matrix)
logRmat = z_matrix %*% re_mat +
x_matrix %*% matrix(python_like_select_name(tmb_fit_object$par.fixed, 'beta'), nrow=2)
sim_thetas = t(sapply(1:nrow(logRmat), function(l) MCMCpack::rdirichlet(1, overdispersion_lambda[l]* softmax(c(logRmat[l,], 0)))))
}else{
sim_thetas = softmax(cbind(sapply(1:dmin1,
function(some_dummy_idx) give_z_matrix(length(tmb_fit_object$par.random) * 2) %*% tmb_fit_object$par.random) +
give_x_matrix(length(tmb_fit_object$par.random) * 2) %*% matrix(python_like_select_name(tmb_fit_object$par.fixed, 'beta'), nrow=2), 0))
sim_thetas = t(sapply(1:nrow(logRmat), function(l) MCMCpack::rdirichlet(1, overdispersion_lambda[l]* sim_thetas[l,])))
}
return(sim_thetas)
}
give_ranked_plot_simulation = function(tmb_fit_object, data_object, print_plot = T, nreps = 1, model){
if(model == 'M'){
## theta is always going to be the same. Only replicate the draws from the multinomial
sim_theta = simulate_from_M_TMB(tmb_fit_object = tmb_fit_object, full_RE = T,
x_matrix = data_object$x, z_matrix = data_object$z)
sim_counts = t(sapply(1:nrow(sim_theta), function(i) rmultinom(n = 1, size = sum(data_object$Y[i,]), prob = sim_theta[i,]) ) )
if(nreps>1){
sim_counts = replicate(nreps, t(sapply(1:nrow(sim_theta), function(i) rmultinom(n = 1, size = sum(data_object$Y[i,]), prob = sim_theta[i,]) ) ), simplify = F)
}
}else if(model %in% c('DM', 'DMSL')){
give_sim_data = function(){
if(model == 'DM'){
sim_theta = simulate_from_DM_TMB(tmb_fit_object = tmb_fit_object, full_RE = T,
x_matrix = data_object$x, z_matrix = data_object$z, integer_overdispersion_param=integer_overdispersion_param)
}else if(model == 'DMSL'){
sim_theta = simulate_from_DMSL_TMB(tmb_fit_object = tmb_fit_object, full_RE = T,
x_matrix = data_object$x, z_matrix = data_object$z, integer_overdispersion_param=integer_overdispersion_param)
}
sim_counts = t(sapply(1:nrow(sim_theta), function(i) rmultinom(n = 1, size = sum(data_object$Y[i,]), prob = sim_theta[i,]) ) )
return(sim_counts)
}
if(nreps>1){
sim_counts = replicate(nreps, give_sim_data(), simplify = F)
}else{
sim_counts = give_sim_data()
}
}else{
stop('Specify a correct model')
}
stopifnot(all(dim(data_object$Y) == dim(sim_counts)))
if(print_plot)  plot(sort(data_object$Y), sort(sim_counts))
return(sim_counts)
}
simulate_from_M_TMB = function(tmb_fit_object, full_RE=T, x_matrix, z_matrix){
dmin1 = length(python_like_select_name(tmb_fit_object$par.fixed, 'beta'))/2
if(full_RE){
re_mat = re_vector_to_matrix(tmb_fit_object$par.random, dmin1)
ntimes2 = nrow(z_matrix)
logRmat = z_matrix %*% re_mat +
x_matrix %*% matrix(python_like_select_name(tmb_fit_object$par.fixed, 'beta'), nrow=2)
sim_thetas = softmax(cbind(logRmat, 0))
}else{
sim_thetas = softmax(cbind(sapply(1:dmin1,
function(some_dummy_idx) give_z_matrix(length(tmb_fit_object$par.random) * 2) %*% tmb_fit_object$par.random) +
give_x_matrix(length(tmb_fit_object$par.random) * 2) %*% matrix(python_like_select_name(tmb_fit_object$par.fixed, 'beta'), nrow=2), 0))
}
return(sim_thetas)
}
simulate_from_DM_TMB = function(tmb_fit_object, full_RE=T, x_matrix, z_matrix, integer_overdispersion_param){
dmin1 = length(python_like_select_name(tmb_fit_object$par.fixed, 'beta'))/2
overdispersion_lambda = integer_overdispersion_param*exp(python_like_select_name(tmb_fit_object$par.fixed, "log_lambda")[x_matrix[,2]+1])
if(full_RE){
re_mat = re_vector_to_matrix(tmb_fit_object$par.random, dmin1)
ntimes2 = nrow(z_matrix)
logRmat = z_matrix %*% re_mat +
x_matrix %*% matrix(python_like_select_name(tmb_fit_object$par.fixed, 'beta'), nrow=2)
sim_thetas = t(sapply(1:nrow(logRmat), function(l) MCMCpack::rdirichlet(1, overdispersion_lambda[l]* softmax(c(logRmat[l,], 0)))))
}else{
sim_thetas = softmax(cbind(sapply(1:dmin1,
function(some_dummy_idx) give_z_matrix(length(tmb_fit_object$par.random) * 2) %*% tmb_fit_object$par.random) +
give_x_matrix(length(tmb_fit_object$par.random) * 2) %*% matrix(python_like_select_name(tmb_fit_object$par.fixed, 'beta'), nrow=2), 0))
sim_thetas = t(sapply(1:nrow(logRmat), function(l) MCMCpack::rdirichlet(1, overdispersion_lambda[l]* sim_thetas[l,])))
}
return(sim_thetas)
}
simulate_from_DMSL_TMB = function(tmb_fit_object, full_RE=T, x_matrix, z_matrix, integer_overdispersion_param){
dmin1 = length(python_like_select_name(tmb_fit_object$par.fixed, 'beta'))/2
overdispersion_lambda = integer_overdispersion_param*exp(python_like_select_name(tmb_fit_object$par.fixed, "log_lambda"))
if(full_RE){
re_mat = re_vector_to_matrix(tmb_fit_object$par.random, dmin1)
ntimes2 = nrow(z_matrix)
logRmat = z_matrix %*% re_mat +
x_matrix %*% matrix(python_like_select_name(tmb_fit_object$par.fixed, 'beta'), nrow=2)
sim_thetas = t(sapply(1:nrow(logRmat), function(l) MCMCpack::rdirichlet(1, overdispersion_lambda[l]* softmax(c(logRmat[l,], 0)))))
}else{
sim_thetas = softmax(cbind(sapply(1:dmin1,
function(some_dummy_idx) give_z_matrix(length(tmb_fit_object$par.random) * 2) %*% tmb_fit_object$par.random) +
give_x_matrix(length(tmb_fit_object$par.random) * 2) %*% matrix(python_like_select_name(tmb_fit_object$par.fixed, 'beta'), nrow=2), 0))
sim_thetas = t(sapply(1:nrow(logRmat), function(l) MCMCpack::rdirichlet(1, overdispersion_lambda[l]* sim_thetas[l,])))
}
return(sim_thetas)
}
