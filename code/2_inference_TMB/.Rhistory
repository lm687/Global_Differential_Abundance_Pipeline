data$num_individuals = n
parameters <- list(
beta = beta_init,
logs_sd_RE=rep(1, d-1),
cov_par_RE = rep(1, ((d-1)*(d-1)-(d-1))/2),
log_lambda = 2,
u_large1 = matrix(runif(n)),
u_large2 = matrix(runif(n)),
u_large3 = matrix(runif(n)),
u_large4 = matrix(runif(n))
)
obj <- MakeADFun(data, parameters, DLL="fullRE_dirichletmultinomial_single_lambda_REv2",
random = c("u_large1", "u_large2","u_large3", "u_large4"))
}else if(model == "fullRE_multinomial_REv2"){
data$num_individuals = n
parameters <- list(
beta = beta_init,
logs_sd_RE=rep(1, d-1),
cov_par_RE = rep(1, ((d-1)*(d-1)-(d-1))/2),
u_large1 = matrix(runif(n)),
u_large2 = matrix(runif(n)),
u_large3 = matrix(runif(n)),
u_large4 = matrix(runif(n))
)
obj <- MakeADFun(data, parameters, DLL="fullRE_ME_multinomial_REv2",
random = c("u_large1", "u_large2","u_large3", "u_large4"))
}else{
stop('Specify correct <model>\n')
}
if(use_nlminb){
opt = nlminb(start = obj$par, obj = obj$fn, gr = obj$gr, iter.max=iter.max)
}else{
obj$hessian <- TRUE
opt <- do.call("optim", obj)
opt
opt$hessian ## <-- FD hessian from optim
}
return_report <- sdreport(obj)
# if(sort_columns){
#   ## return results in the original order
#   order_cats
#   return_report$par.fixed[grepl('beta', names(return_report$par.fixed))] = as.vector(matrix(python_like_select_name(return_report$par.fixed, 'beta'), nrow=2)[,order_cats])
#   return_report$cov.fixed
#   return_report
# }
return(return_report)
}
python_like_select = function(vector, grep_substring){
vector[grepl(pattern = grep_substring, x = vector)]
}
python_like_select_name = function(vector, grep_substring){
vector[grepl(pattern = grep_substring, x = names(vector))]
}
python_like_select_colnames = function(matrix, grep_substring){
matrix[,grepl(pattern = grep_substring, x = colnames(matrix))]
}
python_like_select_rownames = function(matrix, grep_substring){
matrix[grepl(pattern = grep_substring, x = rownames(matrix)),]
}
clean_name = function(x){
gsub(".RDS", "", paste0(strsplit(x, "_")[[1]][2:3], collapse = ""))
}
clean_name_fullRE = function(x){
gsub(".RDS", "", paste0(strsplit(x, "_")[[1]][3:4], collapse = ""))
}
clean_name_fullRE_2 = function(x){
gsub(".RDS", "", paste0(strsplit(x, "_")[[1]][4:5], collapse = ""))
}
re_vector_to_matrix = function(vec_RE, dmin1){
## Random effects vector to matrix
matrix(vec_RE, ncol=dmin1)
}
give_summary_per_sample = function(TMB_object, verbatim=T){
if(is.null(TMB_object)){
"Object doesn't exist"
}else{
if(typeof(TMB_object) %in% c("character", "logical")){
return('Timeout or some error')
}else{
if(TMB_object$pdHess){
return('Good')
}else{
return('Non-PD')
}
}
}
}
give_summary_of_runs2 = function(vector_TMB_objects, long_return){
timeout_bool = sapply(vector_TMB_objects, typeof) == "character"
hessian_positivedefinite_bool = sapply(vector_TMB_objects[!timeout_bool], function(i){
if(length(i) == 1){FALSE}else{i$pdHess}})
summary_runs = c(sum(timeout_bool), sum(!hessian_positivedefinite_bool), sum(hessian_positivedefinite_bool))
names(summary_runs) = c('(failed) timeout', '(failed) non-positive semi-definite hessian', '(successful) positive semi-definite hessian')
if(long_return){
list(Timeout=names(vector_TMB_objects)[timeout_bool],
hessian_nonpositivedefinite_bool = names(vector_TMB_objects)[!timeout_bool][!hessian_positivedefinite_bool],
hessian_positivedefinite_bool = names(vector_TMB_objects)[!timeout_bool][hessian_positivedefinite_bool])
}else{
return(summary_runs)
}
}
give_summary_of_runs = function(vector_TMB_objects, long_return){
if(verbatim){
stop('Check give_summary_of_runs2 instead')
}
timeout_bool = sapply(vector_TMB_objects, typeof) == "character"
hessian_positivedefinite_bool = sapply(vector_TMB_objects[!timeout_bool], function(i) i$pdHess)
summary_runs = c(sum(timeout_bool), sum(!hessian_positivedefinite_bool), sum(hessian_positivedefinite_bool))
names(summary_runs) = c('(failed) timeout', '(failed) non-positive semi-definite hessian', '(successful) positive semi-definite hessian')
if(long_return){
list(Timeout=names(vector_TMB_objects)[timeout_bool],
hessian_nonpositivedefinite_bool = names(vector_TMB_objects)[!timeout_bool][!hessian_positivedefinite_bool],
hessian_positivedefinite_bool = names(vector_TMB_objects)[!timeout_bool][hessian_positivedefinite_bool])
}else{
return(summary_runs)
}
}
get_summary_stan = function(model, typefeature){
sapply(as.character(unique(samples_files$CT)), function(i){
idx = which( (stan_results$CT == i) & (stan_results$features == typefeature) & (stan_results$model == model))
if(length(idx) == 0){return("Object doesn't exist")}else{
rw = stan_results[idx,]
if(rw$divergent.transitions == "True"){
return('Divergent transitions')
} else if(rw$Cancelled..time.limit. == "True"){
return('Timeout')
} else if(!is.na(rw$Rhat.high) | !is.na(rw$ESS)){
return('No good convergence')
} else{
return('Good')
}
}
})
}
load_posteriors = function(fle_rdata){
load(fle_rdata)
list(posteriors_betas=posteriors_betas,
posteriors_betas_slope=posteriors_betas_slope,
num_not_containing_zero=num_not_containing_zero)
}
wald_generalised = function(v, sigma){
warning('20201218: sigma**(1/2) has now been replaced by (as we had before sometime in November) sigma')
chisqrt_stat = t(v) %*% solve(sigma) %*% v
pchisq(q = chisqrt_stat, df = length(v), lower.tail = FALSE)
}
wald_TMB_wrapper = function(i, verbatim=TRUE){
if(typeof(i) == "character"){
return(NA)
}else{
idx_beta = select_slope_2(which(names(i$par.fixed) == "beta"), verbatim=verbatim)
if(is.na(idx_beta)){
NA
}else{
wald_generalised(v = i$par.fixed[idx_beta], sigma = i$cov.fixed[idx_beta,idx_beta])
}
}
}
select_slope = function(i){
stop('Deprecated due to error! use <select_slope_2> instead')
i[(length(i)/2+1):(length(i))]
}
select_slope_2 = function(i, verbatim=TRUE){
if(is.null(dim(i))){
if(verbatim) warning('As per 27 August it seems clear that this version, and not <select_slope>, is correct')
i[c(F,T)]
}else{
i[,c(F,T)]
}
}
select_intercept = function(i, verbatim=TRUE){
if(is.null(dim(i))){
i[c(T,F)]
}else{
i[,c(T,F)]
}
}
vector_to_ct_list = function(vec){
##' given a vector which contains two or more types of features for the same cancer types,
##' convert it to a matrix with the pairing per cancer type
which_sigs = (grep('signatures', names(vec)))
which_nuc = (grep('nucleotidesubstitution1', names(vec)))
if(sum(length(which_sigs)+length(which_nuc)) < length(vec)){stop('There is a third feature category')}
ct_naked1 = gsub('signatures', '', names(vec)[which_sigs])
ct_naked2 = gsub('nucleotidesubstitution1', '', names(vec)[which_nuc])
ct_naked1[match(ct_naked1, ct_naked2)]
ret = cbind(vec[which_sigs][match(ct_naked1, ct_naked2)], vec[which_nuc])
rownames(ret) = gsub('signatures', '', rownames(ret))
colnames(ret) = c('signatures', 'nucleotidesubsitution1')
return(ret)
}
give_UNSTRUCTURED_CORR_t_matrix = function(vec, dim_mat){
# #https://kaskr.github.io/adcomp/classUNSTRUCTURED__CORR__t.html
m = matrix(1, nrow = dim_mat, ncol = dim_mat)
## fill in the order that TMB's UNSTRUCTURED_CORR_t saves the covariances
m[unlist(sapply(2:nrow(m), function(rw) seq(from = rw,length.out = (rw-1), by = nrow(m) )))] = vec
m[unlist(sapply(2:nrow(m), function(cl) seq(from = (((cl-1)*nrow(m))+1),length.out = (cl-1), by = 1 )))] = vec
return(m)
}
get_count_object = function(ct, feature, pre_path=NULL){
if(is.null(pre_path)){
pre_path = "../../data/roo/"
}
readRDS(paste0(pre_path, ct, "_", feature, "_ROO.RDS"))
}
get_count_object_file = function(fle){
readRDS(fle)
}
give_stderr = function(i, only_slopes=T, only_betas=T){
if(!only_betas){
stop('Not yet implemented')
}else{
if(length(i) == 1){ ## they are just NAs
if(only_slopes){
.x = select_slope_2(python_like_select_name(i$par.fixed, "beta"), verbatim = FALSE) ## repeat the NAs
}else{
.x = python_like_select_name(i$par.fixed, "beta") ## repeat the NAs
}
}else{
if(only_slopes){
.x = select_slope_2(python_like_select_name(summary.sdreport(i)[,2], "beta"),v=F)
}else{
.x = python_like_select_name(summary.sdreport(i)[,2], "beta")
}
}
.x
}
}
createbarplot_object = function(fle, slotname='count_matrices_all'){
.x = readRDS(fle)
lapply(.x, createbarplot_ROOSigs, slot=slotname, pre_path = "../../../CDA_in_Cancer/code/")
}
simulate_from_DM_TMB = function(tmb_fit_object, full_RE=T, x_matrix, z_matrix, integer_overdispersion_param){
dmin1 = length(python_like_select_name(tmb_fit_object$par.fixed, 'beta'))/2
overdispersion_lambda = integer_overdispersion_param*exp(python_like_select_name(tmb_fit_object$par.fixed, "log_lambda")[x_matrix[,2]+1])
if(full_RE){
re_mat = re_vector_to_matrix(tmb_fit_object$par.random, dmin1)
ntimes2 = nrow(z_matrix)
logRmat = z_matrix %*% re_mat +
x_matrix %*% matrix(python_like_select_name(tmb_fit_object$par.fixed, 'beta'), nrow=2)
sim_thetas = t(sapply(1:nrow(logRmat), function(l) MCMCpack::rdirichlet(1, overdispersion_lambda[l]* softmax(c(logRmat[l,], 0)))))
}else{
sim_thetas = softmax(cbind(sapply(1:dmin1,
function(some_dummy_idx) give_z_matrix(length(tmb_fit_object$par.random) * 2) %*% tmb_fit_object$par.random) +
give_x_matrix(length(tmb_fit_object$par.random) * 2) %*% matrix(python_like_select_name(tmb_fit_object$par.fixed, 'beta'), nrow=2), 0))
sim_thetas = t(sapply(1:nrow(logRmat), function(l) MCMCpack::rdirichlet(1, overdispersion_lambda[l]* sim_thetas[l,])))
}
return(sim_thetas)
}
simulate_from_M_TMB = function(tmb_fit_object, full_RE=T, x_matrix, z_matrix){
dmin1 = length(python_like_select_name(tmb_fit_object$par.fixed, 'beta'))/2
if(full_RE){
re_mat = re_vector_to_matrix(tmb_fit_object$par.random, dmin1)
ntimes2 = nrow(z_matrix)
logRmat = z_matrix %*% re_mat +
x_matrix %*% matrix(python_like_select_name(tmb_fit_object$par.fixed, 'beta'), nrow=2)
sim_thetas = softmax(cbind(logRmat, 0))
}else{
sim_thetas = softmax(cbind(sapply(1:dmin1,
function(some_dummy_idx) give_z_matrix(length(tmb_fit_object$par.random) * 2) %*% tmb_fit_object$par.random) +
give_x_matrix(length(tmb_fit_object$par.random) * 2) %*% matrix(python_like_select_name(tmb_fit_object$par.fixed, 'beta'), nrow=2), 0))
}
return(sim_thetas)
}
simulate_from_correlated_binom = function(tmb_fit_object, full_RE=T, x_matrix, z_matrix, return_logratios=F){
d = length(python_like_select_name(tmb_fit_object$par.fixed, 'beta'))/2
if(full_RE){
re_mat = re_vector_to_matrix(tmb_fit_object$par.random, d)
ntimes2 = nrow(z_matrix)
logRmat = z_matrix %*% re_mat +
x_matrix %*% matrix(python_like_select_name(tmb_fit_object$par.fixed, 'beta'), nrow=2)
if(return_logratios){
return(logRmat)
}else{
## return first probability
return(apply(logRmat, 2, function(i) exp(i)/(1+exp(i))))
}
}else{
stop('Not implemented yet')
# sim_thetas = sapply(1:d,
#                     function(some_dummy_idx) give_z_matrix(length(tmb_fit_object$par.random) * 2) %*% tmb_fit_object$par.random) +
#                              give_x_matrix(length(tmb_fit_object$par.random) * 2) %*% matrix(python_like_select_name(tmb_fit_object$par.fixed, 'beta'), nrow=2)
return(sim_thetas)
}
}
give_confidence_interval = function(vec_est, vec_stderr){
sapply(1:length(vec_est), function(i) c(vec_est[i]-1.96*vec_stderr[i],vec_est[i]+1.96*vec_stderr[i]) )
}
give_params_in_CI = function(vec_est, vec_stderr, vec_true){
ci = give_confidence_interval(vec_est, vec_stderr)
return(sapply(1:length(vec_est), function(i) (ci[1,i] < vec_true[i]) & (ci[2,i] > vec_true[i]) ))
}
wrapper_run_ttest_ilr = function(i){
x = readRDS(i)
x = x[[1]]@count_matrices_all
props = sapply(x, normalise_rw, simplify = FALSE)
return(Compositional::hotel2T2(x1 = compositions::ilr(props[[1]]), x2 = compositions::ilr(props[[2]]))$pvalue)
}
wrapper_run_ttest_props = function(i){
x = readRDS(i)
x = x[[1]]@count_matrices_all
props = sapply(x, normalise_rw, simplify = FALSE)
return(Compositional::hotel2T2(x1 =props[[1]][,-1], x2 = props[[2]][,-1])$pvalue)
}
summarise_DA_detection = function(true, predicted){
require(ROCR)
## remove NAs
which_na = which(is.na(predicted))
if(length(which_na) > 0){ ## some NA
true = true[-which_na]
predicted = predicted[-which_na]
}
FPs = sum(!true & predicted)/sum(predicted)
TPs = sum(true & predicted)/sum(predicted)
TNs = sum(!true & !predicted)/sum(!predicted)
FNs = sum(true & !predicted)/sum(!predicted)
total_pos = sum(true | predicted)
Power = TPs/total_pos
Sensitivity = TPs / (TPs + FNs)
Specificity = TNs / (TNs + FPs)
pred <- ROCR::prediction(as.numeric(true), as.numeric(predicted))
AUC = try(ROCR::performance(pred, "auc")@y.values[[1]])
return(c(FP=FPs, TP=TPs, Power=Power, AUC=AUC, Specificity=Specificity, Sensitivity=Sensitivity))
}
fill_covariance_matrix = function(arg_d, arg_entries_var, arg_entries_cov){
.sigma = matrix(NA, arg_d, arg_d)
diag(.sigma) = arg_entries_var
.sigma[unlist(sapply(1:(arg_d-1), function(i) (i-1)*arg_d + (i+1):arg_d ))] = arg_entries_cov
.sigma[unlist(sapply(1:(arg_d-1), function(i) (i) + ((i):(arg_d-1))*arg_d))] = arg_entries_cov
return(.sigma)
}
give_subset_sigs = function(sig_obj, sigs_to_remove){
if(typedata %in% c("nucleotidesubstitution1", "nucleotidesubstitution3", "simulation")){
slot_name = "count_matrices_all"
}else if(typedata == "signatures"){
if(is.null(attr(sig_obj,"count_matrices_active")[[1]]) | (length(attr(sig_obj,"count_matrices_active")[[1]]) == 0)){
## no active signatures
slot_name = "count_matrices_all"
}else{
slot_name = "count_matrices_active"
}
}
sig_obj_slot = attr(sig_obj,slot_name)
sig_obj_slot = lapply(sig_obj_slot, function(i) i[, !(colnames(i) %in% sigs_to_remove)])
# sig_obj$Y = sig_obj$Y[, !(colnames(sig_obj$Y) %in% sigs_to_remove)]
attr(sig_obj,slot_name) = sig_obj_slot
return(sig_obj)
}
give_subset_sigs_TMBobj = function(sig_obj, sigs_to_remove){
sig_obj$Y = sig_obj$Y[,!(colnames(sig_obj$Y) %in% sigs_to_remove)]
keep_obs = rowSums(sig_obj$Y) > 0
sig_obj$Y = sig_obj$Y[keep_obs,]
sig_obj$x = sig_obj$x[keep_obs,]
sig_obj$z = sig_obj$z[keep_obs,]
return(sig_obj)
}
normalise_rw <- function(x){
if(is.null(dim(x))){
x/sum(x)
}else{
## normalise row-wise
sweep(x, 1, rowSums(x), '/')
}
}
normalise_cl <- function(x){
if(is.null(dim(x))){
x/sum(x)
}else{
## normalise col-wise
t(sweep(x, 2, colSums(x), '/'))
}
}
give_barplot = function(ct, typedata, simulation=F, title='', legend_on=F){
require(gridExtra)
obj = load_PCAWG(ct, typedata, simulation)
a <- createBarplot(obj$Y[obj$x[,2] == 0,], remove_labels = T)+ggtitle('Early raw')
b <- createBarplot(obj$Y[obj$x[,2] == 1,], remove_labels = T)+ggtitle('Late raw')
c <- createBarplot(normalise_rw(obj$Y[obj$x[,2] == 0,]), remove_labels = T)+ggtitle('Early normalised')
d <- createBarplot(normalise_rw(obj$Y[obj$x[,2] == 1,]), remove_labels = T)+ggtitle('Late normalised')
if(!legend_on){
a+guides(fill=F)
b+guides(fill=F)
c+guides(fill=F)
d+guides(fill=F)
}
grid.arrange(a, b, c, d, top=title)
}
wrapper_run_TMB_debug = function(object, model = "fullRE_DM", return_report=F, iter.max=150, init_log_lambda = 2, idx_cov_to_fill){
dim(object$Y)
sort_columns=T
smart_init_vals=T
data = object
if(sort_columns){
data$Y = data$Y[,order(colSums(data$Y), decreasing = F)]
}
data$Y = matrix(data$Y, nrow=nrow(data$Y))
data$x = (matrix(data$x, ncol=2))
d <- ncol(data$Y)
n <- ncol(data$z) ## number of INDIVIDUALS, not samples
data$num_individuals = n
data$lambda_accessory_mat = (cbind(c(rep(1,n),rep(0,n)), c(rep(0,n),rep(1,n))))
if(smart_init_vals){
require(nnet)
.x_multinom = multinom(data$Y ~ data$x[,2])
beta_init = t(coef(.x_multinom))
}else{
beta_init = (matrix(rep(runif(1, min = -4, max = 4), 2*(d-1)),
nrow = 2, byrow=TRUE))
}
parameters <- list(
beta = beta_init,
u_large = matrix(runif(min = -0.3, max = 0.3, n = (d-1)*n), nrow=n),
logs_sd_RE=rep(1, d-1),
# cov_par_RE = rep(1, ((d-1)*(d-1)-(d-1))/2),
cov_par_RE = runif(min = -1, max = 1, n = ((d-1)*(d-1)-(d-1))/2),
log_lambda = matrix(c(init_log_lambda,init_log_lambda))
)
if(model == "fullRE_DM"){
obj <- MakeADFun(data, parameters, DLL="fullRE_ME_dirichletmultinomial", random = "u_large")
}else if(model == "diagRE_DM"){
parameters$cov_par_RE = NULL
obj <- MakeADFun(data, parameters, DLL="diagRE_ME_dirichletmultinomial", random = "u_large")
}else if(model == "fullREDMsinglelambda"){
parameters$log_lambda = 2
obj <- MakeADFun(data, parameters, DLL="fullRE_dirichletmultinomial_single_lambda", random = "u_large")
}else if(model == "diagREDMsinglelambda"){
parameters$cov_par_RE = NULL
parameters$log_lambda = 2
obj <- MakeADFun(data, parameters, DLL="diagRE_dirichletmultinomial_single_lambda", random = "u_large")
}else if(model == "sparseRE_DM"){
if(is.null(idx_cov_to_fill)){stop("Add <idx_cov_to_fill>")}
parameters$cov_par_RE = NULL
parameters$cov_RE_part = (rep(1, length(idx_cov_to_fill)))
data$idx_params_to_infer = (idx_cov_to_fill)
if(length(idx_cov_to_fill) > 1){
obj <- MakeADFun(data, parameters, DLL="sparseRE_ME_dirichletmultinomial", random = "u_large")
}else{
obj <- MakeADFun(data, parameters, DLL="sparseRE_ME_dirichletmultinomial_single", random = "u_large")
}
}else if(model == "sparseRE_DMSL"){
if(is.null(idx_cov_to_fill)){stop("Add <idx_cov_to_fill>")}
parameters$log_lambda = 2
parameters$cov_par_RE = NULL
parameters$cov_RE_part = (rep(1, length(idx_cov_to_fill)))
data$idx_params_to_infer = (idx_cov_to_fill)
if(length(idx_cov_to_fill) > 1){
obj <- MakeADFun(data, parameters, DLL="sparseRE_ME_dirichletmultinomialsinglelambda", random = "u_large")
}else{
stop()
}
}else if(model == "sparseRE_DMSL2"){
if(is.null(idx_cov_to_fill)){stop("Add <idx_cov_to_fill>")}
parameters$log_lambda = 2
parameters$cov_par_RE = NULL
parameters$cov_RE_part = (rep(1, length(idx_cov_to_fill)))
data$idx_params_to_infer = (idx_cov_to_fill)
if(length(idx_cov_to_fill) > 1){
obj <- MakeADFun(data, parameters, DLL="sparseRE_ME_dirichletmultinomialsinglelambda2", random = "u_large")
}else{
stop()
}
}else if(model == "sparseRE_DMSL2"){
if(is.null(idx_cov_to_fill)){stop("Add <idx_cov_to_fill>")}
parameters$log_lambda = 2
parameters$cov_par_RE = NULL
parameters$cov_RE_part = (rep(1, length(idx_cov_to_fill)))
data$idx_params_to_infer = (idx_cov_to_fill)
if(length(idx_cov_to_fill) > 1){
obj <- MakeADFun(data, parameters, DLL="sparseRE_ME_dirichletmultinomialsinglelambda2", random = "u_large")
}else{
stop()
}
} else{
stop("Incorrect <model>")
}
opt = nlminb(start = obj$par, obj = obj$fn, gr = obj$gr, iter.max=iter.max, trace=T)
if(return_report)  return(sdreport(obj))
return(opt)
}
is_slope = function(v){
bool_isbetaslope = rep(F, length(v))
bool_isbetaslope[v == "beta"] = T
bool_isbetaslope[which(bool_isbetaslope)] = c(F,T)
bool_isbetaslope
}
res_sparse <- wrapper_run_TMB_debug(object = obj_ct, iter.max = 500, init_log_lambda = 3, return_report = T,
model = "sparseRE_DMSL2",
idx_cov_to_fill=idx_cov_to_fill_read-1) ## idx_cov_to_fill must be zero-indexed
res_sparse
res_sparse <- wrapper_run_TMB_debug(object = obj_ct, iter.max = 500, init_log_lambda = 3, return_report = T,
model = "sparseRE_DMSL",
idx_cov_to_fill=idx_cov_to_fill_read-1) ## idx_cov_to_fill must be zero-indexed
res_sparse
res_sparse2 <- wrapper_run_TMB_debug(object = obj_ct, iter.max = 500, init_log_lambda = 3, return_report = T,
model = "sparseRE_DMSL2",
idx_cov_to_fill=idx_cov_to_fill_read-1) ## idx_cov_to_fill must be zero-indexed
res_sparse2
#----------------------------------------------------------------------#
enough_samples = readLines("~/Desktop/CT_sufficient_samples.txt")
enough_samples
subset_sigs_sparse_cov_idx <- read.table("../../current/subset_sigs_sparse_cov_idx.txt", stringsAsFactors = F, fill = T)
ct <- "Bone-Osteosarc"
obj_ct = load_PCAWG(ct, typedata="signatures", path_to_data = "../../data/")
idx_cov_to_fill_read <- as.integer(strsplit(subset_sigs_sparse_cov_idx[subset_sigs_sparse_cov_idx$V1 == ct,2], ",")[[1]])
idx_cov_to_fill_read <- as.integer(strsplit(subset_sigs_sparse_cov_idx[subset_sigs_sparse_cov_idx$V1 == ct,2], ",")[[1]])
# res_sparse <- wrapper_run_TMB_debug(object = obj_ct, iter.max = 500, init_log_lambda = 3, return_report = T,
#                                     model = "sparseRE_DMSL",
#                                     idx_cov_to_fill=idx_cov_to_fill_read-1) ## idx_cov_to_fill must be zero-indexed
# res_sparse
res_sparse2 <- wrapper_run_TMB_debug(object = obj_ct, iter.max = 500, init_log_lambda = 3, return_report = T,
model = "sparseRE_DMSL2",
idx_cov_to_fill=idx_cov_to_fill_read-1) ## idx_cov_to_fill must be zero-indexed
res_sparse2
