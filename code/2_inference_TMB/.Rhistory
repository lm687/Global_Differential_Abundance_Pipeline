no_hidden_values <- nrow(transition_matrix)
alpha <-matrix(NA,no_emitted_values,no_hidden_values)
alpha[1,]<-initial_distribution*emission_matrix[,visible_data[1]]
for (i in 2:(no_emitted_values)){
transitted<-alpha[(i-1),] %*% transition_matrix
alpha[i,]<-transitted*emission_matrix[,visible_data[i]]
}
return(alpha)
}
# forward_algorithm(values$emitted_values,matrix(as.numeric(A),nrow=2),matrix(as.numeric(B),nrow=2),as.numeric(mu_naught))
forward_algorithm(emitted_values,A,B,mu_naught)
#Log likelihood of GC sequence under the model in (1)
forward_algorithm_scaled<-function(visible_data,transition_matrix,emission_matrix,initial_distribution){
no_emitted_values <- length(visible_data)
no_hidden_values <- nrow(transition_matrix)
alpha <-matrix(NA,no_emitted_values,no_hidden_values)
c_0<-sum(initial_distribution*emission_matrix[,visible_data[1]])
alpha[1,]<-(1/c_0)*initial_distribution*emission_matrix[,visible_data[1]]
log_L<-list()
log_L<-append(log_L,log(c_0))
for (n in 2:(no_emitted_values)){
transitted<-alpha[(n-1),] %*% transition_matrix
c_n<-sum(transitted*emission_matrix[,visible_data[n]])
alpha[n,]<-(1/c_n)*transitted*emission_matrix[,visible_data[n]]
log_L<-append(log_L,log(c_n))
}
return(unlist(log_L))
}
## WHAT ARE THESE TWO VALUES? LOG-LIKELIHOOD IS NA?
c_n<-forward_algorithm_scaled(visible_data = emitted_sequences, transition_matrix = matrix(as.numeric(A),nrow=2),
emission_matrix = matrix(as.numeric(B),nrow=2), initial_distribution = as.numeric(mu_naught))
log_likelihood<-sum(c_n)
emitted_sequences <- c(1,1,2,4,5)
## WHAT ARE THESE TWO VALUES? LOG-LIKELIHOOD IS NA?
c_n<-forward_algorithm_scaled(visible_data = emitted_sequences, transition_matrix = matrix(as.numeric(A),nrow=2),
emission_matrix = matrix(as.numeric(B),nrow=2), initial_distribution = as.numeric(mu_naught))
log_likelihood<-sum(c_n)
c_n_arg <- c_n
backward_algorithm_scaled<-function(visible_data,hidden_states,emission_matrix,transition_matrix,c_n_arg){
no_emitted_values <- length(visible_data)
no_hidden_values <- nrow(transition_matrix)
beta_hat<-matrix(NA,no_emitted_values,no_hidden_values)
c_n_arg<-exp(c_n_arg)
N<-length(visible_data)
beta_hat[N,]<-(1/c_n_arg[N])
for (n in (N-1):1){
# beta_hat[n,]<-(1/c_n[n])* emission_matrix[,visible_data[n+1]]* beta_hat[n+1,] %*% transition_matrix
beta_hat[n,]<-(1/c_n_arg[n])* emission_matrix[,visible_data[n+1]] %*% transition_matrix  * beta_hat[n+1,]
}
return(beta_hat)
}
beta_hat<-backward_algorithm_scaled(visible_data = emitted_sequences,hidden_states = hidden_values,
emission_matrix = matrix(as.numeric(B),nrow=2), transition_matrix = matrix(as.numeric(A),nrow=2),c_n)
beta_hat
forward_algorithm_scaled2<-function(visible_data,transition_matrix,emission_matrix,initial_distribution){
no_emitted_values <- length(visible_data)+1
no_hidden_values <- nrow(transition_matrix)
alpha <-matrix(NA,no_emitted_values,no_hidden_values)
c_0<-sum(initial_distribution*emission_matrix[,visible_data[1]])
alpha[1,]<-(1/c_0)*initial_distribution*emission_matrix[,visible_data[1]]
log_L<-list()
log_L<-append(log_L,log(c_0))
for (n in 2:(no_emitted_values)){
transitted<-alpha[(n-1),] %*% transition_matrix
c_n<-sum(transitted*emission_matrix[,visible_data[n]])
alpha[n,]<-(1/c_n)*transitted*emission_matrix[,visible_data[n]]
log_L<-append(log_L,log(c_n))
}
return(alpha)
}
alpha_hat<-forward_algorithm_scaled2(emitted_sequences,matrix(as.numeric(A),nrow=2),matrix(as.numeric(B),nrow=2),as.numeric(mu_naught))
alpha_hat
backward_algorithm_scaled<-function(visible_data,hidden_states,emission_matrix,transition_matrix,c_n_arg){
no_emitted_values <- length(visible_data)
no_hidden_values <- nrow(transition_matrix)
beta_hat<-matrix(NA,no_emitted_values,no_hidden_values)
c_n_arg<-exp(c_n_arg)
N<-length(visible_data)
beta_hat[N,]<-(1/c_n_arg[N])
for (n in (N-1):1){
# beta_hat[n,]<-(1/c_n[n])* emission_matrix[,visible_data[n+1]]* beta_hat[n+1,] %*% transition_matrix
beta_hat[n,]<-(1/c_n_arg[n])* emission_matrix[,visible_data[n+1]] %*% transition_matrix  * beta_hat[n+1,]
}
return(beta_hat)
}
beta_hat<-backward_algorithm_scaled(visible_data = emitted_sequences,hidden_states = hidden_values,
emission_matrix = matrix(as.numeric(B),nrow=2), transition_matrix = matrix(as.numeric(A),nrow=2),c_n)
beta_hat
forward_algorithm_scaled2<-function(visible_data,transition_matrix,emission_matrix,initial_distribution){
no_emitted_values <- length(visible_data)
no_hidden_values <- nrow(transition_matrix)
alpha <-matrix(NA,no_emitted_values,no_hidden_values)
c_0<-sum(initial_distribution*emission_matrix[,visible_data[1]])
alpha[1,]<-(1/c_0)*initial_distribution*emission_matrix[,visible_data[1]]
log_L<-list()
log_L<-append(log_L,log(c_0))
for (n in 2:(no_emitted_values)){
transitted<-alpha[(n-1),] %*% transition_matrix
c_n<-sum(transitted*emission_matrix[,visible_data[n]])
alpha[n,]<-(1/c_n)*transitted*emission_matrix[,visible_data[n]]
log_L<-append(log_L,log(c_n))
}
return(alpha)
}
alpha_hat<-forward_algorithm_scaled2(emitted_sequences,matrix(as.numeric(A),nrow=2),matrix(as.numeric(B),nrow=2),as.numeric(mu_naught))
alpha_hat
alpha_hat
baum_welch<-function(emitted_sequences,hidden_values){
#initialization
mu_0<-c(0.5,0.5)
trans_mat<-matrix(rep(0.5,4),nrow=2)
emission_mat<-matrix(rep(0.2,10),nrow=2)
N<-1000 ## number of iterations
#iteration
for (t in 1:N){
alpha_hat<-forward_algorithm_scaled2(emitted_sequences,trans_mat,emission_mat,mu_0)
c_n<-forward_algorithm_scaled(emitted_sequences,trans_mat,emission_mat,mu_0)
beta_hat<-backward_algorithm_scaled(emitted_sequences,hidden_values,emission_mat,trans_mat,c_n)
log_likelihood<-sum(c_n)
mu_0<-alpha_hat[1,] * trans_mat %*% emission_mat[,visible_data[1],drop=FALSE]*beta_hat[1,]
E_nij<-matrix(0,2,2)
for (m in 1:N){
E_nij<-E_nij + apply(trans_mat %*% emission_mat[,visible_data[(m+1)],drop=FALSE]*beta_hat[m+1,],1, function(x) alpha_hat[m,]*x)
}
trans_mat<-apply(E_nij,1,function(x) x/colSums(E_nij))
emission_mat<-rep(NA,1)
}
#termination
}
# E_nij<-matrix(0,2,2)
# for (m in 1:N){
#   E_nij<-E_nij + apply(trans_mat %*% emission_mat[,visible_data[(m+1)],drop=FALSE]*beta_hat[m+1,],1, function(x) alpha_hat[m,]*x)
# }
A <- matrix(NA, ncol(alpha_hat), ncol(alpha_hat))
## sum the number of times that we see the transition from k to l in the observed data
sum_over_j_i <- matrix(NA, ncol=ncol(alpha_hat), nrow=length(emitted_sequences))
sum_over_j_i
sum(sapply(1:length(emitted_sequences)){
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
f[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[l,i+1]
}
}
})
sum(sapply(1:length(emitted_sequences)){
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[l,i+1]
}
}
})
alpha_hat
length(emitted_sequences)
sum(sapply(1:(length(emitted_sequences)-1)){
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[l,i+1]
}
}
})
alpha_hat
ncol(alpha_hat)
(length(emitted_sequences)-1)
sum(sapply(1:(length(emitted_sequences)-1), function(i)){
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[l,i+1]
}
}
})
sapply(1:(length(emitted_sequences)-1), function(i){
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[l,i+1]
}
}
})
trans_mat<-matrix(rep(0.5,4),nrow=2)
emission_mat<-matrix(rep(0.2,10),nrow=2)
N<-1000 ## number of iterations
sapply(1:(length(emitted_sequences)-1), function(i){
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[l,i+1]
}
}
})
visible_data=rep(1,5)
sapply(1:(length(emitted_sequences)-1), function(i){
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[l,i+1]
}
}
})
beta_hat
alpha_hat
sapply(1:(length(emitted_sequences)-1), function(i){
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[i+1,l]
}
}
})
sapply(1:(length(emitted_sequences)-1), function(i){
.x <- matrix(NA, ncol(alpha_hat), ncol(alpha_hat))
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
.x[k,l] <- alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[i+1,l]
}
}
.x
})
sapply(1:(length(emitted_sequences)-1), function(i){
.x <- matrix(NA, ncol(alpha_hat), ncol(alpha_hat))
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
.x[k,l] <- alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[i+1,l]
}
}
.x
})
A <- matrix(NA, ncol(alpha_hat), ncol(alpha_hat))
A <- matrix(NA, ncol(alpha_hat), ncol(alpha_hat))
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
A[k,l] <- sapply(1:(length(emitted_sequences)-1), function(i){ alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[i+1,l]})
}
}
sapply(1:(length(emitted_sequences)-1), function(i){ alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[i+1,l]})
}
sapply(1:(length(emitted_sequences)-1), function(i){ alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[i+1,l]})
A <- matrix(NA, ncol(alpha_hat), ncol(alpha_hat))
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
A[k,l] <- sum(sapply(1:(length(emitted_sequences)-1), function(i){ alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[i+1,l]}))
}
}
A
alpha_hat
alpha_hat[length(emitted_sequences]
alpha_hat[length(emitted_sequences)]
alpha_hat[length(emitted_sequences),]
A
##-----------------------------------------------------------------------------------------------------##
rm(list = ls())
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
##-----------------------------------------------------------------------------------------------------##
source("../2_inference_TMB/helper_TMB.R")
source("../../../CDA_in_Cancer/code/functions/meretricious/pretty_plots/prettySignatures.R")
source("../3_analysis/recovery_COSMIC_signatures/recover_COSMIC_signatures.R")
library(TMB)
library(ggrepel)
library(cowplot)
library(gridExtra)
library(dplyr)
library(jcolors)
library(viridis)
library(mutSigExtractor)
##-----------------------------------------------------------------------------------------------------##
enough_samples = read.table("../../data/restricted/pcawg/CT_sufficient_samples.txt", comment.char='#')[,1]
enough_samples
nonexogenous = read.table("../../data/cosmic/exogenous_signatures_SBS.txt", sep = "\t",
comment.char = "#", fill = F)
nonexogenouswSBS1SBS5 = read.table("../../data/cosmic/exogenous_signatures_SBS_withSBS1SBS5.txt", sep = "\t",
comment.char = "#", fill = F)
sigs_cosmic0 <- read.table(paste0( "../../data/cosmic/sigProfiler_SBS_signatures_2019_05_22.csv"),
stringsAsFactors = FALSE, sep = ',', header = TRUE)
rownames(sigs_cosmic0) <- paste0(substr(sigs_cosmic0$SubType, 1, 1),'[',
sigs_cosmic0$Type, ']', substr(sigs_cosmic0$SubType, 3, 3))
sigs_cosmic0 <- sigs_cosmic0[-c(1,2)];
sigs_cosmic <- colnames(sigs_cosmic0)
##-----------------------------------------------------------------------------------------------------##
read_info <- function(ct){
.x <- list(fullRE_M_SP = try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullREM_", ct, "_signaturesPCAWG.RDS"))),
fullRE_DMSL_SP = try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullREDMsinglelambda_", ct, "_signaturesPCAWG.RDS"))),
fullRE_M_nonexo_SP = try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullREMnonexo_", ct, "_signaturesPCAWG.RDS"))),
fullRE_DMSL_nonexo_SP = try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullREDMsinglelambdanonexo_", ct, "_signaturesPCAWG.RDS"))),
diagRE_DMDL_SP = try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/diagREDM_", ct, "_signaturesPCAWG.RDS"))),
diagRE_DMDL_nonexo_SP =  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/diagREDMnonexo_", ct, "_signaturesPCAWG.RDS"))),
diagRE_DMDL_wSBS1SBS5nonexo_SP = try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/diagREDMwSBS1SBS5nonexo_", ct, "_signaturesPCAWG.RDS"))),
fullREDMnoscaling_SP_nonexo =  try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullREDMnoscalingnonexo_", ct, "_signaturesPCAWG.RDS"))),
fullREDMnoscaling_SP_nonexo_subsets_and_amalgamations <- try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullREDMnoscalingnonexosubset_", ct, "_signaturesPCAWG.RDS"))),
fullREDMonefixedlambdanonexo_SP = try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullREDMonefixedlambdanonexo_", ct, "_signaturesPCAWG.RDS"))),
fullREDMonefixedlambda2nonexo_SP = try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullREDMonefixedlambda2nonexo_", ct, "_signaturesPCAWG.RDS"))),
fullREDMonefixedlambdanonexo_SPSaA = try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullREDMonefixedlambdanonexo_", ct, "_signaturesPCAWGSaA.RDS"))),
fullREM_MSE = try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullREM_", ct, "_signaturesMSE.RDS"))),
fullREDM_MSE = try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullREDM_", ct, "_signaturesMSE.RDS"))),
fullREDM_nucleotide1 = try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/fullREDM_", ct, "_nucleotidesubstitution1.RDS"))),
diagREDM_MSE = try(readRDS(paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/diagREDM_", ct, "_signaturesMSE.RDS"))),
dataset_all_sigs = load_PCAWG(ct = ct, typedata = "signaturesPCAWG", path_to_data = "../../data/", load_all_sigs = T),
dataset_active_sigs = load_PCAWG(ct = ct, typedata = "signaturesPCAWG", path_to_data = "../../data/"),
dataset_nucleotidesubstitution1 = load_PCAWG(ct = ct, typedata = "nucleotidesubstitution1", path_to_data = "../../data/"),
dataset_nucleotidesubstitution3 = load_PCAWG(ct = ct, typedata = "nucleotidesubstitution3", path_to_data = "../../data/"),
dataset_nucleotidesubstitution3MSE = load_PCAWG(ct = ct, typedata = "nucleotidesubstitution3MSE", path_to_data = "../../data/"),
dataset_active_sigs_MSE = load_PCAWG(ct = ct, typedata = "signaturesMSE", path_to_data = "../../data/", load_all_sigs = F),
DMM = list(z_DMM=lapply(1:8, function(k) try(read.table(paste0("../../data/roo_for_DMM_SPpcawg/DMM_output/", ct, "_signaturesPCAWG_all", k, "_dmm.z"), sep = ',', skip = 1))),
fit_DMM = lapply(1:8, function(k) try(read.table(paste0("../../data/roo_for_DMM_SPpcawg/DMM_output/", ct, "_signaturesPCAWG_all", k, "_dmm.fit"), sep = ' '))))
)
.x$dataset_nonexo <- give_subset_sigs_TMBobj(.x$dataset_active_sigs, nonexogenous$V1)
.x$dataset_nonexoSBS1SBS5 <- give_subset_sigs_TMBobj(.x$dataset_active_sigs, nonexogenouswSBS1SBS5$V1)
.x$colnames_notsorted_SP <- try(colnames(.x$dataset_active_sigs$Y))
.x$logR_notsorted_SP <- try(vector_cats_to_logR(.x$colnames_notsorted_SP))
.x$colnames_nonexo_notsorted_SP <- try(colnames(.x$dataset_nonexo$Y))
.x$logR_nonexo_notsorted_SP <- try(vector_cats_to_logR(.x$colnames_nonexo_notsorted_SP))
## nonexo, with SBS1 and SBS5
.x$colnames_wSBS1SBS5nonexo_notsorted_SP <- try(colnames(.x$dataset_nonexoSBS1SBS5$Y))
.x$logR_wSBS1SBS5nonexo_notsorted_SP <- try(vector_cats_to_logR(.x$colnames_wSBS1SBS5nonexo_notsorted_SP))
return(.x)
}
read_info_list <- lapply(enough_samples, read_info)
names(read_info_list) <- enough_samples
plot_betas_scatter <- function(TMB_obj, names_cats=NULL, softmax=F){
betas_mat <- t(matrix(python_like_select_name(TMB_obj$par.fixed, 'beta'), nrow=2))
if(softmax){
betas_mat <- t(softmax(t(rbind(betas_mat, 0))))
names_cats <- c(sapply(names_cats, function(i) strsplit(i, '/')[[1]][1]),
strsplit(names_cats[1], '/')[[1]][2])
}
betas_df <- data.frame(betas_mat)
if(!is.null(names_cats)){
betas_df$logR = names_cats
}else{
betas_df$logR <- 1:nrow(betas_df)
}
a <- ggplot(betas_df, aes(x=X1, y=X2, label=logR))+labs(x='Beta intercept', y='Beta slope')
if(!TMB_obj$pdHess){
a <- a+geom_point(col='red')
}else{
a <- a+geom_point()
}
a <- a + geom_label_repel(size=3)+theme_bw()
return(a)
}
give_mycolours <- function(n){
n <- 60
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unique(unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals))))
myColors <- col_vector[1:n]
}
plot_scatter <- function(m){
m <- data.frame(m)
names_sigs <- colnames(m)
colnames(m) <- c('x1', 'x2')
ggplot(m, aes(x=x1, y=x2))+geom_point()+theme_bw()+labs(x=names_sigs[1], y=names_sigs[2])
}
plot_covariance_mat <- function(TMB_obj, names_cats=NULL){
.x <- L_to_cov(python_like_select_name(TMB_obj$par.fixed, 'cov_par_RE'),
d=length(python_like_select_name(TMB_obj$par.fixed, 'beta'))/2)
if(!is.null(names_cats))  colnames(.x) <- rownames(.x) <- names_cats
hm <- pheatmap::pheatmap(.x, main='Covariances')
return(arrangeGrob(hm[[4]]))
}
give_plot_differential_precision <- function(TMB_obj){
ovrdisp <- cbind.data.frame( plot_lambdas(TMB_obj, return_df=T, plot=F))
if(TMB_obj$pdHess){
col='red'
}else{
col='black'
}
ovrdisp[ovrdisp$name == 'Lambda 1','name'] = 'Early'
ovrdisp[ovrdisp$name == 'Lambda 2','name'] = 'Late'
ggplot(ovrdisp, aes(x=name,  y=`Estimate`))+
geom_point(col=col)+
geom_errorbar(aes(ymin=`Estimate`-`Std..Error`,
ymax=`Estimate`+`Std..Error`), width=.1)+
theme_bw()+
labs(x='', y='Log lambda')
}
give_DMM_plot <- function(TMB_obj){
if(all(sapply(read_info_list[[ct]]$DMM$z_DMM, typeof) == 'character')){
ggplot()+theme_bw()
}else{
ggplot(cbind(melt(normalise_rw(TMB_obj$dataset_active_sigs$Y)),
grouptiming=rep(c('Clonal','Subclonal'), each=dim(TMB_obj$dataset_active_sigs$Y)[1]/2),
groupDMM=paste0('DMM ', apply(TMB_obj$DMM$z_DMM[[which.min(unlist(sapply(TMB_obj$DMM$fit_DMM, `[`, 2)))]][,2:3], 1, which.max))),
aes(x=Var1, y=value, fill=Var2))+geom_bar(stat = "identity")+facet_wrap(.~grouptiming+groupDMM, ncol=2)+
scale_fill_manual(name = "grp",values = give_mycolours(ncol(read_info_list[[ct]]$dataset_active_sigs$Y)))+theme_bw()+
theme(axis.title.x=element_blank(),
axis.text.x=element_blank(),
axis.ticks.x=element_blank())
}
}
logR_nucleotidesubs1 <- vector_cats_to_logR(sort(unlist( sapply(c('C', 'T'),
function(base){ paste0(base, '>', c('A', 'C', 'G', 'T')[! (c('A', 'C', 'G', 'T') == base)]) }))))
betas_df_to_softmax <- function(df_betas){
.x <- softmax(c(df_betas$Estimate, 0))
names(.x) <- c(gsub("/.*", "", df_betas$LogR), gsub("*./", "", df_betas$LogR[1]))
.x
}
nucleotide1 <- sapply(read_info_list, `[`, 'fullREDM_nucleotide1')
names_trinucleotide <- vector_cats_to_logR(colnames(read_info_list[[1]]$dataset_nucleotidesubstitution1$Y))
nucleotide1 <- sapply(read_info_list, `[`, 'fullREDM_nucleotide1')
names(nucleotide1) <- names(read_info_list)
system("open ../../results/results_TMB/pcawg/reports_per_cancer_type/")
betas_nucleotides <- lapply(nucleotide1, function(i) plot_betas(i, return_df = T))
betas_nucleotides <- lapply(betas_nucleotides, function(i){
i$LogR <- names_trinucleotide[i$LogR]
# rownames(i) <- make.names(i$LogR, unique = T)
i
})
betas_nucleotides_slopes <- do.call('cbind', lapply(betas_nucleotides, function(i) i%>% filter(type_beta == 'Slope' ) %>% select(Estimate)))
rownames(betas_nucleotides_slopes) <- names_trinucleotide
betas_nucleotides_intercepts <- do.call('cbind', lapply(betas_nucleotides, function(i) i%>% filter(type_beta == 'Intercept' ) %>% select(Estimate)))
rownames(betas_nucleotides_intercepts) <- names_trinucleotide
colnames(betas_nucleotides_intercepts) <- colnames(betas_nucleotides_slopes) <- names(read_info_list)
pheatmap::pheatmap(betas_nucleotides_slopes)
pheatmap::pheatmap(betas_nucleotides_intercepts)
betas_nucleotides_slopes_cors <- outer(1:nrow(betas_nucleotides_slopes),
1:nrow(betas_nucleotides_slopes), Vectorize(function(i,j){
cor(x = unlist(betas_nucleotides_slopes[i,]), y = unlist(betas_nucleotides_slopes[j,]))
}))
nucleotide1[[ct_it]]
ct_it=enough_samples
ct_it=enough_samples[1]
plot_covariance_mat(nucleotide1[[ct_it]])
plot_covariance_mat
print(plot_covariance_mat(nucleotide1[[ct_it]], names_cats = names_trinucleotide, title = ct_it))
plot_covariance_mat
plot_covariance_mat <- function(TMB_obj, names_cats=NULL, title='Covariances'){
.x <- L_to_cov(python_like_select_name(TMB_obj$par.fixed, 'cov_par_RE'),
d=length(python_like_select_name(TMB_obj$par.fixed, 'beta'))/2)
if(!is.null(names_cats))  colnames(.x) <- rownames(.x) <- names_cats
hm <- pheatmap::pheatmap(.x, main=title)
return(arrangeGrob(hm[[4]]))
}
print(plot_covariance_mat(nucleotide1[[ct_it]], names_cats = names_trinucleotide, title = ct_it))
pdf(paste0("../../results/results_TMB/pcawg/reports_per_cancer_type/nucleotide1_sigma.pdf"),
height = 3, width = 3)
for(ct_it in  names(read_info_list)){
print(plot_covariance_mat(nucleotide1[[ct_it]], names_cats = names_trinucleotide, title = ct_it))
}
dev.off()
system("open ../../results/results_TMB/pcawg/reports_per_cancer_type/")
dev.off()
pdf(paste0("../../results/results_TMB/pcawg/reports_per_cancer_type/nucleotide1_sigma.pdf"),
height = 3, width = 3)
for(ct_it in  names(read_info_list)){
print(plot_covariance_mat(nucleotide1[[ct_it]], names_cats = names_trinucleotide, title = ct_it))
}
dev.off()
plot_covariance_mat
plot_covariance_mat <- function(TMB_obj, names_cats=NULL, title='Covariances', arg_cluster_rows=T, arg_cluster_cols=T){
.x <- L_to_cov(python_like_select_name(TMB_obj$par.fixed, 'cov_par_RE'),
d=length(python_like_select_name(TMB_obj$par.fixed, 'beta'))/2)
if(!is.null(names_cats))  colnames(.x) <- rownames(.x) <- names_cats
hm <- pheatmap::pheatmap(.x, main=title, cluster_rows = arg_cluster_rows, cluster_cols = arg_cluster_cols)
return(arrangeGrob(hm[[4]]))
}
dev.off()
pdf(paste0("../../results/results_TMB/pcawg/reports_per_cancer_type/nucleotide1_sigmanoclust.pdf"),
height = 3, width = 3)
for(ct_it in  names(read_info_list)){
print(plot_covariance_mat(nucleotide1[[ct_it]], names_cats = names_trinucleotide, title = ct_it,
arg_cluster_rows = F, arg_cluster_cols = F))
}
dev.off()
plot_covariance_mat <- function(TMB_obj, names_cats=NULL, title='Covariances', arg_cluster_rows=T,
arg_cluster_cols=T, lims=NULL){
.x <- L_to_cov(python_like_select_name(TMB_obj$par.fixed, 'cov_par_RE'),
d=length(python_like_select_name(TMB_obj$par.fixed, 'beta'))/2)
if(!is.null(names_cats))  colnames(.x) <- rownames(.x) <- names_cats
if(!is.null(lims)){
breaksList = seq(lims[1], lims[2], length.out = 10)
hm <- pheatmap::pheatmap(.x, main=title, cluster_rows = arg_cluster_rows,
cluster_cols = arg_cluster_cols,
color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(length(breaksList)),
breaks = breaksList)
}else{
hm <- pheatmap::pheatmap(.x, main=title, cluster_rows = arg_cluster_rows, cluster_cols = arg_cluster_cols, )
}
return(arrangeGrob(hm[[4]]))
}
dev.off()
pdf(paste0("../../results/results_TMB/pcawg/reports_per_cancer_type/nucleotide1_sigma.pdf"),
height = 3, width = 3)
for(ct_it in  names(read_info_list)){
print(plot_covariance_mat(nucleotide1[[ct_it]], names_cats = names_trinucleotide, title = ct_it, lims=c(-1, 1)))
}
dev.off()
plot_covariance_mat <- function(TMB_obj, names_cats=NULL, title='Covariances', arg_cluster_rows=T,
arg_cluster_cols=T, lims=NULL){
.x <- L_to_cov(python_like_select_name(TMB_obj$par.fixed, 'cov_par_RE'),
d=length(python_like_select_name(TMB_obj$par.fixed, 'beta'))/2)
if(!is.null(names_cats))  colnames(.x) <- rownames(.x) <- names_cats
if(!is.null(lims)){
require(RColorBrewer)
breaksList = seq(lims[1], lims[2], length.out = 10)
hm <- pheatmap::pheatmap(.x, main=title, cluster_rows = arg_cluster_rows,
cluster_cols = arg_cluster_cols,
color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(length(breaksList)),
breaks = breaksList)
}else{
hm <- pheatmap::pheatmap(.x, main=title, cluster_rows = arg_cluster_rows, cluster_cols = arg_cluster_cols, )
}
return(arrangeGrob(hm[[4]]))
}
dev.off()
pdf(paste0("../../results/results_TMB/pcawg/reports_per_cancer_type/nucleotide1_sigma.pdf"),
height = 3, width = 3)
for(ct_it in  names(read_info_list)){
print(plot_covariance_mat(nucleotide1[[ct_it]], names_cats = names_trinucleotide, title = ct_it, lims=c(-1, 1)))
}
dev.off()
pdf(paste0("../../results/results_TMB/pcawg/reports_per_cancer_type/nucleotide1_sigmanoclust.pdf"),
height = 3, width = 3)
for(ct_it in  names(read_info_list)){
print(plot_covariance_mat(nucleotide1[[ct_it]], names_cats = names_trinucleotide, title = ct_it,
arg_cluster_rows = F, arg_cluster_cols = F, lims=c(-1, 1)))
}
dev.off()
enough_samples
