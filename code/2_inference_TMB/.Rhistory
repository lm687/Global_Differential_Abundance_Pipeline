Q <- pmsignature:::convertFromTurbo_Q(p[(lenF + 1):(lenF + lenQ)], K, sampleNum)
dim(Q) <- c(sampleNum, K)
Q <- t(Q)
return(pmsignature:::getLogLikelihoodC((patternList), (sparseCount),
as.vector(F), as.vector(Q), fdim, K, sampleNum, patternNum,
samplePatternNum, isBG, BG0))
}
## getLogLikelihoodC doesn't need to get changed as we already pass only vectors
# pmsignature:::getLogLikelihoodC function (vPatternList, vSparseCount, vF, vQ, fdim, signatureNum,
#                                           sampleNum, patternNum, samplePatternNum, isBackground, vF0)
# {
#   .Call("_pmsignature_getLogLikelihoodC", PACKAGE = "pmsignature",
#         vPatternList, vSparseCount, vF, vQ, fdim, signatureNum,
#         sampleNum, patternNum, samplePatternNum, isBackground,
#         vF0)
# }
# <bytecode: 0x7fb1aa336a20>
#   <environment: namespace:pmsignature>
## Changing the functions so that the observed data is a vector, instead of a matrix
Param <- LM_getPMSignature(mutationFeatureData = G, K = 3, BG = NULL,
patternNum=length(G@possibleFeatures),
samplePatternNum=ncol(slot(G, "countData")))
updatePM
LM_getPMSignature <- function (mutationFeatureData, K, BG = NULL, numInit = 10, tol = 1e-04,
maxIter = 10000, patternNum, samplePatternNum)
{
if (!is.null(BG)) {
isBG <- TRUE
varK <- K - 1
}else {
isBG <- FALSE
varK <- K
BG <- 0
}
sampleNum <- length(slot(mutationFeatureData, "sampleList"))
fdim <- slot(mutationFeatureData, "possibleFeatures")
tempL <- -Inf
tempPar <- c()
for (kkk in 1:numInit) {
F <- array(0, c(varK, length(fdim), max(fdim)))
for (k in 1:varK) {
for (kk in 1:length(fdim)) {
F[k, kk, 1:fdim[kk]] <- rgamma(fdim[kk], rep(1,
fdim[kk]))
F[k, kk, 1:fdim[kk]] <- F[k, kk, 1:fdim[kk]]/sum(F[k,
kk, 1:fdim[kk]])
}
}
Q <- matrix(rgamma(sampleNum * K, 1, 1), K, sampleNum)
Q <- sweep(Q, 2, apply(Q, 2, sum), `/`)
p0 <- c(pmsignature:::convertToTurbo_F(as.vector(F), fdim, K, isBG),
pmsignature:::convertToTurbo_Q(as.vector(t(Q)), K, sampleNum))
Y <- list(list(sampleNum, fdim, slot(mutationFeatureData, "featureVectorList"),
slot(mutationFeatureData, "countData")),
K, isBG, BG)
res1 <- LM_mySquareEM(p0, Y, tol = tol, maxIter = maxIter, patternNum, samplePatternNum)
cat(paste("#trial: ", sprintf("%2d", kkk), "; #iteration: ",
sprintf("%4d", as.integer(res1$itr)), "; time(s): ",
sprintf("%4.2f", res1$elapsed.time), "; convergence: ",
res1$convergence, "; loglikelihood: ", sprintf("%.4f",
res1$value.objfn), "\n", sep = ""))
if (res1$value.objfn > tempL) {
tempL <- res1$value.objfn
tempPar <- res1$par
}
}
lenF <- varK * (sum(fdim) - length(fdim))
lenQ <- sampleNum * (K - 1)
F <- pmsignature:::convertFromTurbo_F(tempPar[1:lenF], fdim, K, isBG)
Q <- pmsignature:::convertFromTurbo_Q(tempPar[(lenF + 1):(lenF + lenQ)],
K, sampleNum)
dim(F) <- c(varK, length(fdim), max(fdim))
dim(Q) <- c(sampleNum, K)
return(new(Class = "EstimatedParameters", type = slot(mutationFeatureData,
"type"),
flankingBasesNum = slot(mutationFeatureData,
"flankingBasesNum"),
transcriptionDirection = slot(mutationFeatureData,
"transcriptionDirection"),
possibleFeatures = slot(mutationFeatureData,
"possibleFeatures"), sampleList = slot(mutationFeatureData,
"sampleList"),
signatureNum = as.integer(K), isBackGround = isBG,
backGroundProb = BG, signatureFeatureDistribution = F,
sampleSignatureDistribution = Q, loglikelihood = tempL))
}
# pmsignature:::mySquareEM function (p, y, tol = 1e-04, maxIter = 10000)
# {
#   prevL <- -Inf
#   step.min <- 1
#   step.max <- 1
#   step.max0 <- 1
#   mstep <- 4
#   objfn.inc <- 1
#   updEvalNum <- 0
#   LEvalNum <- 0
#   useSquareEM <- 0
#   iterNum <- 0
#   convFlag <- FALSE
#   startTime <- proc.time()
#   newL <- calcPMSLikelihood(p, y)
#   LEvalNum <- LEvalNum + 1
#   for (iterNum in 1:maxIter) {
#     p1 <- updatePMSParam(p, y)
#     updEvalNum <- updEvalNum + 1
#     if (any(is.nan(unlist(p1)))) {
#       stop("Error in function evaluation")
#     }
#     q1 <- p1 - p
#     sr2 <- crossprod(q1)
#     p2 <- updatePMSParam(p1, y)
#     updEvalNum <- updEvalNum + 1
#     if (any(is.nan(unlist(p2)))) {
#       stop("Error in function evaluation")
#     }
#     q2 <- p2 - p1
#     sq2 <- sqrt(crossprod(q2))
#     sv2 <- crossprod(q2 - q1)
#     srv <- crossprod(q1, q2 - q1)
#     alpha <- -srv/sv2
#     alpha <- max(step.min, min(step.max, alpha))
#     p.new <- p + 2 * alpha * q1 + alpha^2 * (q2 - q1)
#     if (isTRUE(abs(alpha - 1) > 0.01)) {
#       p.new <- updatePMSParam(p.new, y)
#       updEvalNum <- updEvalNum + 1
#     }
#     if (any(is.nan(p.new)) | !PMSboundary(y)(p.new)) {
#       p.new <- p2
#       newL <- calcPMSLikelihood(p2, y)
#       LEvalNum <- LEvalNum + 1
#       if (isTRUE(all.equal(alpha, step.max))) {
#         step.max <- max(step.max0, step.max/mstep)
#       }
#       alpha <- 1
#     }
#     else {
#       newL <- calcPMSLikelihood(p.new, y)
#       LEvalNum <- LEvalNum + 1
#       if (is.nan(newL) | (newL > prevL + objfn.inc)) {
#         p.new <- p2
#         lnew <- calcPMSLikelihood(p2, y)
#         LEvalNum <- LEvalNum + 1
#         if (alpha == step.max) {
#           step.max <- max(step.max0, step.max/mstep)
#         }
#         alpha <- 1
#       }
#       else {
#         useSquareEM <- useSquareEM + 1
#       }
#     }
#     if (isTRUE(all.equal(alpha, step.max))) {
#       step.max <- mstep * step.max
#     }
#     if (step.min < 0 & isTRUE(all.equal(alpha, step.min))) {
#       step.min <- mstep * step.min
#     }
#     p <- p.new
#     if (abs(prevL - newL) < tol) {
#       convFlag <- TRUE
#       break
#     }
#     if (!is.nan(newL)) {
#       prevL <- newL
#     }
#   }
#   calcTime <- proc.time() - startTime
#   return(list(par = p, value.objfn = newL, itr = iterNum, fpeval = updEvalNum,
#               convergence = convFlag, elapsed.time = calcTime[3]))
# }
LM_mySquareEM <- function (p, y, tol = 1e-04, maxIter = 10000, patternNum, samplePatternNum){
prevL <- -Inf
step.min <- 1
step.max <- 1
step.max0 <- 1
mstep <- 4
objfn.inc <- 1
updEvalNum <- 0
LEvalNum <- 0
useSquareEM <- 0
iterNum <- 0
convFlag <- FALSE
startTime <- proc.time()
newL <- LM_calcPMSLikelihood(p, y, patternNum, samplePatternNum)
LEvalNum <- LEvalNum + 1
for (iterNum in 1:maxIter) {
p1 <- pmsignature:::updatePMSParam(p, y)
updEvalNum <- updEvalNum + 1
if (any(is.nan(unlist(p1)))) {
stop("Error in function evaluation")
}
q1 <- p1 - p
sr2 <- crossprod(q1)
p2 <- pmsignature:::updatePMSParam(p1, y)
updEvalNum <- updEvalNum + 1
if (any(is.nan(unlist(p2)))) {
stop("Error in function evaluation")
}
q2 <- p2 - p1
sq2 <- sqrt(crossprod(q2))
sv2 <- crossprod(q2 - q1)
srv <- crossprod(q1, q2 - q1)
alpha <- -srv/sv2
alpha <- max(step.min, min(step.max, alpha))
p.new <- p + 2 * alpha * q1 + alpha^2 * (q2 - q1)
if (isTRUE(abs(alpha - 1) > 0.01)) {
p.new <- pmsignature:::updatePMSParam(p.new, y)
updEvalNum <- updEvalNum + 1
}
if (any(is.nan(p.new)) | !pmsignature:::PMSboundary(y)(p.new)) {
p.new <- p2
newL <- LM_calcPMSLikelihood(p2, y, patternNum, samplePatternNum)
LEvalNum <- LEvalNum + 1
if (isTRUE(all.equal(alpha, step.max))) {
step.max <- max(step.max0, step.max/mstep)
}
alpha <- 1
}
else {
newL <- LM_calcPMSLikelihood(p.new, y, patternNum, samplePatternNum)
LEvalNum <- LEvalNum + 1
if (is.nan(newL) | (newL > prevL + objfn.inc)) {
p.new <- p2
lnew <- LM_calcPMSLikelihood(p2, y, patternNum, samplePatternNum)
LEvalNum <- LEvalNum + 1
if (alpha == step.max) {
step.max <- max(step.max0, step.max/mstep)
}
alpha <- 1
}
else {
useSquareEM <- useSquareEM + 1
}
}
if (isTRUE(all.equal(alpha, step.max))) {
step.max <- mstep * step.max
}
if (step.min < 0 & isTRUE(all.equal(alpha, step.min))) {
step.min <- mstep * step.min
}
p <- p.new
if (abs(prevL - newL) < tol) {
convFlag <- TRUE
break
}
if (!is.nan(newL)) {
prevL <- newL
}
}
calcTime <- proc.time() - startTime
return(list(par = p, value.objfn = newL, itr = iterNum, fpeval = updEvalNum,
convergence = convFlag, elapsed.time = calcTime[3]))
}
# <bytecode: 0x7fb1aa350f28>
#   <environment: namespace:pmsignature>
#
# pmsignature:::calcPMSLikelihood
# function (p, y)
# {
#   sampleNum <- y[[1]][[1]]
#   fdim <- y[[1]][[2]]
#   patternList <- y[[1]][[3]]
#   sparseCount <- y[[1]][[4]]
#   K <- y[[2]]
#   isBG <- y[[3]]
#   BG0 <- y[[4]]
#   patternNum <- ncol(patternList)
#   samplePatternNum <- ncol(sparseCount)
#   if (isBG) {
#     varK <- K - 1
#   }
#   else {
#     varK <- K
#   }
#   lenF <- varK * (sum(fdim) - length(fdim))
#   lenQ <- (K - 1) * sampleNum
#   F <- convertFromTurbo_F(p[1:lenF], fdim, K, isBG)
#   Q <- convertFromTurbo_Q(p[(lenF + 1):(lenF + lenQ)], K, sampleNum)
#   dim(Q) <- c(sampleNum, K)
#   Q <- t(Q)
#   return(getLogLikelihoodC(as.vector(patternList), as.vector(sparseCount),
#                            as.vector(F), as.vector(Q), fdim, K, sampleNum, patternNum,
#                            samplePatternNum, isBG, BG0))
# }
# <bytecode: 0x7fb1aa346908>
#   <environment: namespace:pmsignature>
LM_calcPMSLikelihood <- function (p, y, patternNum, samplePatternNum){
##' here y[[1]][[3]] and y[[1]][[4]] are vectors to start with, because we don't have the same number of
##' observations for each feature
sampleNum <- y[[1]][[1]]
fdim <- y[[1]][[2]]
patternList <- y[[1]][[3]]
sparseCount <- y[[1]][[4]]
K <- y[[2]]
isBG <- y[[3]]
BG0 <- y[[4]]
# patternNum <- ncol(patternList)
# samplePatternNum <- ncol(sparseCount)
if (isBG) {
varK <- K - 1
}
else {
varK <- K
}
lenF <- varK * (sum(fdim) - length(fdim))
lenQ <- (K - 1) * sampleNum
F <- pmsignature:::convertFromTurbo_F(p[1:lenF], fdim, K, isBG)
Q <- pmsignature:::convertFromTurbo_Q(p[(lenF + 1):(lenF + lenQ)], K, sampleNum)
dim(Q) <- c(sampleNum, K)
Q <- t(Q)
return(pmsignature:::getLogLikelihoodC((patternList), (sparseCount),
as.vector(F), as.vector(Q), fdim, K, sampleNum, patternNum,
samplePatternNum, isBG, BG0))
}
## getLogLikelihoodC doesn't need to get changed as we already pass only vectors
# pmsignature:::getLogLikelihoodC function (vPatternList, vSparseCount, vF, vQ, fdim, signatureNum,
#                                           sampleNum, patternNum, samplePatternNum, isBackground, vF0)
# {
#   .Call("_pmsignature_getLogLikelihoodC", PACKAGE = "pmsignature",
#         vPatternList, vSparseCount, vF, vQ, fdim, signatureNum,
#         sampleNum, patternNum, samplePatternNum, isBackground,
#         vF0)
# }
# <bytecode: 0x7fb1aa336a20>
#   <environment: namespace:pmsignature>
## Changing the functions so that the observed data is a vector, instead of a matrix
Param <- LM_getPMSignature(mutationFeatureData = G, K = 3, BG = NULL,
patternNum=length(G@possibleFeatures),
samplePatternNum=ncol(slot(G, "countData")))
Param
Param_original <- getPMSignature(mutationFeatureData = G, K = 3, BG = NULL)
Param@signatureFeatureDistribution
Param_original@signatureFeatureDistribution
Param@signatureFeatureDistribution[[1]]
Param@signatureFeatureDistribution[,,1]
Param_original@signatureFeatureDistribution[,,1]
which(df_all_samples$X2 == "signatures"
rm(list = ls())
setwd("~/Documents/PhD/GlobalDA/code/2_inference_TMB/")
library(TMB)
library(ggplot2)
library(dplyr)
library(gridExtra)
source("mm_multinomial/helper_functions.R")
source("helper_TMB.R")
source("../2_inference/helper/helper_DA_stan.R") ## for normalise_rw
source("../../../CDA_in_Cancer/code/functions/meretricious/pretty_plots/prettySignatures.R")
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/fullRE_ME_multinomial"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/fullRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/fullRE_ME_dirichletmultinomial"))
TMB::compile("mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))
TMB::compile("mm_multinomial/fullRE_dirichletmultinomial_single_lambda2.cpp", "-std=gnu++17")
dyn.load(dynlib("mm_multinomial/fullRE_dirichletmultinomial_single_lambda2"))
TMB::compile("mm_multinomial/diagRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("mm_multinomial/diagRE_dirichletmultinomial_single_lambda"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/FE_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/FE_dirichletmultinomial"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/diagRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/diagRE_ME_dirichletmultinomial"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda2.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda2"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial_singlecov.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial_singlecov"))
rm(list = ls())
setwd("~/Documents/PhD/GlobalDA/code/2_inference_TMB/")
library(TMB)
library(ggplot2)
library(dplyr)
library(gridExtra)
source("mm_multinomial/helper_functions.R")
source("helper_TMB.R")
source("../2_inference/helper/helper_DA_stan.R") ## for normalise_rw
source("../../../CDA_in_Cancer/code/functions/meretricious/pretty_plots/prettySignatures.R")
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/fullRE_ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/fullRE_ME_multinomial"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/fullRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/fullRE_ME_dirichletmultinomial"))
TMB::compile("mm_multinomial/fullRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("mm_multinomial/fullRE_dirichletmultinomial_single_lambda"))
TMB::compile("mm_multinomial/fullRE_dirichletmultinomial_single_lambda2.cpp", "-std=gnu++17")
dyn.load(dynlib("mm_multinomial/fullRE_dirichletmultinomial_single_lambda2"))
TMB::compile("mm_multinomial/diagRE_dirichletmultinomial_single_lambda.cpp", "-std=gnu++17")
dyn.load(dynlib("mm_multinomial/diagRE_dirichletmultinomial_single_lambda"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/FE_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/FE_dirichletmultinomial"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/diagRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/diagRE_ME_dirichletmultinomial"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda2.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomialsinglelambda2"))
TMB::compile("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial_singlecov.cpp", "-std=gnu++17")
dyn.load(dynlib("../../current/Dirichlet_Multinomial_Dom/code/TMB_models/sparseRE_ME_dirichletmultinomial_singlecov"))
mclapply(which(df_all_samples$X2 == "signatures"),
function(idx){
i = df_all_samples[idx,]
typedata = i[1,2]
obj_subset <- give_subset_sigs_TMBobj(load_PCAWG(ct = i[1,1], typedata = i[1,2]),
sigs_to_remove = unique(nonexogenous$V1))
if(dim(obj_subset$Y)[2] <  dim(load_PCAWG(ct = i[1,1], typedata = i[1,2])$Y)[2]){
x = wrapper_run_TMB(object = sort_columns_TMB(obj_subset),
model = "fullRE_DM", smart_init_vals = T, use_nlminb = T)
x
saveRDS(object = x, file=paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/", "fulLRE_sortednonexo_DM_",
paste0(df_all_samples[idx,], collapse = "_"), ".RDS"))
}})
library(parallel)
mclapply(which(df_all_samples$X2 == "signatures"),
function(idx){
i = df_all_samples[idx,]
typedata = i[1,2]
obj_subset <- give_subset_sigs_TMBobj(load_PCAWG(ct = i[1,1], typedata = i[1,2]),
sigs_to_remove = unique(nonexogenous$V1))
if(dim(obj_subset$Y)[2] <  dim(load_PCAWG(ct = i[1,1], typedata = i[1,2])$Y)[2]){
x = wrapper_run_TMB(object = sort_columns_TMB(obj_subset),
model = "fullRE_DM", smart_init_vals = T, use_nlminb = T)
x
saveRDS(object = x, file=paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/", "fulLRE_sortednonexo_DM_",
paste0(df_all_samples[idx,], collapse = "_"), ".RDS"))
}})
enough_samples = readLines("~/Desktop/CT_sufficient_samples.txt")
df_all_samples = data.frame(do.call('rbind', lapply(enough_samples, function(i) rbind(c(i, 'signatures'), c(i, "nucleotidesubstitution1")))))
nonexogenous = read.table("../../data/cosmic/exogenous_signatures_SBS.txt", sep = "\t", comment.char = "#", fill = F)
library(parallel)
mclapply(which(df_all_samples$X2 == "signatures"),
function(idx){
i = df_all_samples[idx,]
typedata = i[1,2]
obj_subset <- give_subset_sigs_TMBobj(load_PCAWG(ct = i[1,1], typedata = i[1,2]),
sigs_to_remove = unique(nonexogenous$V1))
if(dim(obj_subset$Y)[2] <  dim(load_PCAWG(ct = i[1,1], typedata = i[1,2])$Y)[2]){
x = wrapper_run_TMB(object = sort_columns_TMB(obj_subset),
model = "fullRE_DM", smart_init_vals = T, use_nlminb = T)
x
saveRDS(object = x, file=paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/", "fulLRE_sortednonexo_DM_",
paste0(df_all_samples[idx,], collapse = "_"), ".RDS"))
}})
mclapply(which(df_all_samples$X2 == "signatures"),
function(idx){
i = df_all_samples[idx,]
typedata = i[1,2]
obj_subset <- give_subset_sigs_TMBobj(load_PCAWG(ct = i[1,1], typedata = i[1,2]),
sigs_to_remove = unique(nonexogenous$V1))
if(dim(obj_subset$Y)[2] <  dim(load_PCAWG(ct = i[1,1], typedata = i[1,2])$Y)[2]){
x = wrapper_run_TMB(object = sort_columns_TMB(obj_subset),
model = "fullRE_DM", smart_init_vals = T, use_nlminb = T)
x
saveRDS(object = x, file=paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/", "fulLRE_sortednonexo_DM_",
paste0(df_all_samples[idx,], collapse = "_"), ".RDS"))
}})
mclapply(which(df_all_samples$X2 == "signatures"),
function(idx){
i = df_all_samples[idx,]
typedata = i[1,2]
obj_subset <- give_subset_sigs_TMBobj(load_PCAWG(ct = i[1,1], typedata = i[1,2]),
sigs_to_remove = unique(nonexogenous$V1))
if(dim(obj_subset$Y)[2] <  dim(load_PCAWG(ct = i[1,1], typedata = i[1,2])$Y)[2]){
x = wrapper_run_TMB(object = sort_columns_TMB(obj_subset),
model = "fullRE_DM", smart_init_vals = T, use_nlminb = T)
x
saveRDS(object = x, file=paste0("../../data/pcawg_robjects_cache/tmb_results/nlminb/", "fulLRE_sortednonexo_DM_",
paste0(df_all_samples[idx,], collapse = "_"), ".RDS"))
}})
df_all_samples
View(df_all_samples)
idx
idx=3
i = df_all_samples[idx,]
typedata = i[1,2]
obj_subset <- give_subset_sigs_TMBobj(load_PCAWG(ct = i[1,1], typedata = i[1,2]),
sigs_to_remove = unique(nonexogenous$V1))
i
obj_subset
colSums(obj_subset$Y)
i
give_subset_sigs(obj_subset, 'SBS12')
give_subset_sigs_TMBobj(obj_subset, 'SBS12')
x = wrapper_run_TMB(object = sort_columns_TMB(give_subset_sigs_TMBobj(obj_subset, 'SBS12')),
model = "fullRE_DM", smart_init_vals = T, use_nlminb = T)
x
fill_covariance_matrix(arg_d = length(python_like_select_name(x$par.fixed, 'beta'))/2,
arg_entries_var = python_like_select_name(x$par.fixed, 'logs_sd_RE'),
arg_entries_cov = python_like_select_name(x$par.fixed, 'cov_par_RE'))
python_like_select_name(x$par.fixed, 'cov_par_RE')
summary(x)
python_like_select_rownames(summary(x), 'cov_par_RE')
python_like_select_rownames(summary(x), 'cov_par_RE')[,1]
python_like_select_rownames(summary(x), 'cov_par_RE')[,2]
fill_covariance_matrix(arg_d = length(python_like_select_rownames(summary(x), 'beta')[,2])/2,
arg_entries_var = python_like_select_rownames(summary(x), 'logs_sd_RE')[,2],
arg_entries_cov = python_like_select_rownames(summary(x), 'cov_par_RE')[,2])
sort_columns_TMB(give_subset_sigs_TMBobj(obj_subset, 'SBS12')$Y
)
sort_columns_TMB(give_subset_sigs_TMBobj(obj_subset, 'SBS12')$)`4Y
sort_columns_TMB(give_subset_sigs_TMBobj(obj_subset, 'SBS12')$)$Y
sort_columns_TMB(give_subset_sigs_TMBobj(obj_subset, 'SBS12'))$Y
fill_covariance_matrix(arg_d = length(python_like_select_rownames(summary(x), 'beta')[,2])/2,
arg_entries_var = python_like_select_rownames(summary(x), 'logs_sd_RE')[,2],
arg_entries_cov = python_like_select_rownames(summary(x), 'cov_par_RE')[,2])
sort_columns_TMB(give_subset_sigs_TMBobj(obj_subset, 'SBS12'))$Y[,5]
View(sort_columns_TMB(give_subset_sigs_TMBobj(obj_subset, 'SBS12'))$Y)
fill_covariance_matrix(arg_d = length(python_like_select_rownames(summary(x), 'beta')[,2])/2,
arg_entries_var = python_like_select_rownames(summary(x), 'logs_sd_RE')[,2],
arg_entries_cov = python_like_select_rownames(summary(x), 'cov_par_RE')[,2])
