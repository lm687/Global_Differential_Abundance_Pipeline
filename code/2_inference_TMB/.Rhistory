#------------------------------------------------------------------------------------------------------------------------#
stan_results = read.table("../inference_diagnostics.csv", sep = ",", stringsAsFactors = FALSE, header = TRUE)
for(i in get_summary_stan("M", "nucleotidesubstitution1")){cat(i,'\n')}
for(i in get_summary_stan("M", "nucleotidesubstitution3")){cat(i,'\n')}
for(i in get_summary_stan("M", "signatures")){cat(i,'\n')}
for(i in get_summary_stan("DM", "nucleotidesubstitution1")){cat(i,'\n')}
for(i in get_summary_stan("DM", "nucleotidesubstitution3")){cat(i,'\n')}
for(i in get_summary_stan("DM", "signatures")){cat(i,'\n')}
for(i in get_summary_stan("LNM", "nucleotidesubstitution1")){cat(i,'\n')}
for(i in get_summary_stan("LNM", "nucleotidesubstitution3")){cat(i,'\n')}
for(i in get_summary_stan("LNM", "signatures")){cat(i,'\n')}
#------------------------------------------------------------------------------------------------------------------------#
#------------------------------------------------------------------------------------------------------------------------#
sort(table(apply(cbind(stan_results$CT, stan_results$features, stan_results$model), 1, paste0, collapse="")))
## there should be only one of each
betasM = load_posteriors("../../data/robjects_cache/betas91ecb3fe-4ff0-4e91-b6f0-a2eaf027f91e.Rdata")
betasDM = load_posteriors("../../data/robjects_cache/betas316eb9a5-31f9-4d4b-be88-1b0e5c184286_DM.Rdata")
# some example
betasDM$posteriors_betas$`Biliary-AdenoCA_signatures_20000_DMROO`
results_TMB_DM$`Biliary-AdenoCAsignatures`
set.seed(182)
#------------------------------------------------------------------------------------------------------------------------#
#------------------------------------------------------------------------------------------------------------------------#
## they should have the same dimensions
length(results_TMB_DM$`Biliary-AdenoCAsignatures`$par.fixed[grep("beta", names(results_TMB_DM$`Biliary-AdenoCAsignatures`$par.fixed))])
dim(betasDM$posteriors_betas$`Biliary-AdenoCA_signatures_20000_DMROO`[,python_like_select(colnames(betasDM$posteriors_betas$`Biliary-AdenoCA_signatures_20000_DMROO`), "beta\\[2,")])
## plotting the histogram of the posteriors and the point MLE
replot = FALSE
if(replot){
for(nme in names(results_TMB_DM)[grepl('signatures', names(results_TMB_DM))]){
if(typeof(results_TMB_DM[[nme]]) == "character"){next}
results_TMB_DM[[nme]]$par.fixed[grep("beta", names(results_TMB_DM[[nme]]$par.fixed))]
idx_posteriors = which(grepl(nme, sapply(names(betasDM$posteriors_betas), function(i) paste0(strsplit(i, '_')[[1]][1:2], collapse = ""))))
if(! (length(idx_posteriors) == 1)){next}
d_min_1 = sum(grepl('beta\\[2,', colnames(betasDM$posteriors_betas[[idx_posteriors]])))
pdf(paste0("../../results/TMB/", nme, ".pdf"))
par(mfrow=c(4,4))
for(idx in 1:d_min_1){
beta_val = results_TMB_DM[[nme]]$par.fixed[grep("beta", names(results_TMB_DM[[nme]]$par.fixed))][idx]
plot(density(betasDM$posteriors_betas[[idx_posteriors]][,python_like_select(colnames(betasDM$posteriors_betas[[idx_posteriors]]), "beta\\[2,")][,idx]),
main=paste0(idx, ' ', round(beta_val, digits = 2)))
abline(v=beta_val,
col='blue', lty="dashed")
}
dev.off()
}
}
#------------------------------------------------------------------------------------------------------------------------#
## match stan and TMB
subset_results_TMB_M = results_TMB_M[match(sapply(names(betasM$posteriors_betas_slope), function(i) paste0(strsplit(i, '_')[[1]][1:2], collapse = "")),
names(results_TMB_M))]
subset_results_TMB_DM = results_TMB_DM[match(sapply(names(betasDM$posteriors_betas_slope), function(i) paste0(strsplit(i, '_')[[1]][1:2], collapse = "")),
names(results_TMB_DM))]
## compare betas (note that some gave NaN for their standard error)
unlisted_TMB_list = function(TMB_list){
sapply(1:length(TMB_list), function(dataset){
if(typeof(TMB_list[[dataset]]) != "character"){
TMB_list[[dataset]]$par.fixed[grepl('beta', names(TMB_list[[dataset]]$par.fixed))]
}else{
NA
}
})
}
unlisted_TMB_DM = sapply(unlisted_TMB_list(subset_results_TMB_DM), select_slope)
unlisted_TMB_M = sapply(unlisted_TMB_list(subset_results_TMB_M), select_slope)
unlisted_stan_mean_DM = sapply(betasDM$posteriors_betas_slope, function(i) colMeans(i))
unlisted_stan_mean_M = sapply(betasM$posteriors_betas_slope, function(i) colMeans(i))
## make sure they are the same length
length(unlisted_TMB_DM)
length(unlisted_stan_mean_DM)
## make sure they are the same length
length(unlisted_TMB_DM %>% unlist)
length(unlisted_stan_mean_DM %>% unlist)
par(mfrow=c(1,1))
## scatterplot for multinomial draws of the mean beta from the posterior and the MLE for beta
plot(unlisted_TMB_M %>% unlist, unlisted_stan_mean_M %>% unlist,
col=c('blue', 'red')[factor(sapply(subset_results_TMB_M, give_summary_per_sample) == "Good", levels=c(T,F))], pch=8, cex=0.5)
df_betas_slope_M = cbind.data.frame( TMB_estimate=(unlisted_TMB_M %>% unlist),
stan_mean=(unlisted_stan_mean_M %>% unlist),
Bool_good_convergence=factor(rep(sapply(subset_results_TMB_M, give_summary_per_sample) == "Good",
as.vector(sapply(subset_results_TMB_M,
function(i) sum(names(i$par.fixed) == "beta"))))),
ct = rep(sapply(names(unlisted_stan_mean_M), function(i) paste0(strsplit(i, '_')[[1]][1:2], collapse = " ")),
sapply(unlisted_TMB_M, length)))
ggplot(df_betas_slope_M,
aes(x=TMB_estimate, y=stan_mean, col=Bool_good_convergence))+
geom_point()+ggtitle('Scatterplot of mean of\nposterior and TMB ML estimate')+
geom_abline(slope = 1, intercept = 0)+theme(legend.position = "bottom")
## same plot, but trying to see where it went well and where it did not
ggplot(df_betas_slope_M,
aes(x=TMB_estimate, y=stan_mean, col=Bool_good_convergence))+
geom_point()+ggtitle('Scatterplot of mean of posterior and TMB ML estimate')+
geom_abline(slope = 1, intercept = 0)+theme(legend.position = "bottom")+facet_wrap(.~factor(ct))
## scatterplot for dirichlet-multinomial draws of the mean beta from the posterior and the MLE for beta
plot(unlisted_TMB_DM %>% unlist, unlisted_stan_mean_DM %>% unlist, col=c('blue', 'red')[factor(sapply(subset_results_TMB_DM, give_summary_per_sample) == "Good", levels=c(T,F))], pch=8)
df_betas_slope_DM = cbind.data.frame( TMB_estimate=(unlisted_TMB_DM %>% unlist), stan_mean=(unlisted_stan_mean_DM %>% unlist),
Bool_good_convergence=factor(rep(sapply(subset_results_TMB_DM, give_summary_per_sample) == "Good",
as.vector(sapply(subset_results_TMB_DM, function(i) sum(names(i$par.fixed) == "beta"))))),
ct = rep(sapply(names(unlisted_stan_mean_DM), function(i) paste0(strsplit(i, '_')[[1]][1:2], collapse = " ")),
sapply(unlisted_TMB_DM, length)))
ggplot(df_betas_slope_DM,
aes(x=TMB_estimate, y=stan_mean, col=Bool_good_convergence))+
geom_point()+ggtitle('Scatterplot of mean of\nposterior and TMB ML estimate')+theme(legend.position = "bottom")+
geom_abline(intercept = 0, slope = 1)
ggplot(df_betas_slope_DM %>% filter(Bool_good_convergence == TRUE),
aes(x=TMB_estimate, y=stan_mean, col=Bool_good_convergence))+
geom_point()+geom_abline(slope = 1, intercept = 0) + ggtitle('Scatterplot of mean of\nposterior and TMB ML estimate')+
theme(legend.position = "bottom")
ggplot(df_betas_slope_DM,
aes(x=TMB_estimate, y=stan_mean, col=Bool_good_convergence))+
geom_point()+ggtitle('Scatterplot of mean of\nposterior and TMB ML estimate')+theme(legend.position = "bottom")+
geom_abline(intercept = 0, slope = 1)
ggplot(df_betas_slope_DM %>% filter(Bool_good_convergence == TRUE),
aes(x=TMB_estimate, y=stan_mean, col=factor(Bool_good_convergence, levels=c(T, F))))+
geom_point()+geom_abline(slope = 1, intercept = 0) + ggtitle('Scatterplot of mean of\nposterior and TMB ML estimate')+
theme(legend.position = "bottom")
ggplot(df_betas_slope_DM,
aes(x=TMB_estimate, y=stan_mean, col=factor(Bool_good_convergence, levels=c(T, F))))+
geom_point()+ggtitle('Scatterplot of mean of\nposterior and TMB ML estimate')+theme(legend.position = "bottom")+
geom_abline(intercept = 0, slope = 1)
ggplot(df_betas_slope_DM,
aes(x=TMB_estimate, y=stan_mean, col=factor(Bool_good_convergence, levels=c(T, F))))+
geom_point()+ggtitle('Scatterplot of mean of\nposterior and TMB ML estimate')+theme(legend.position = "bottom")+
geom_abline(intercept = 0, slope = 1)
ggsave("../../results/TMB/betas_stan_TMB_DM.pdf")
ggplot(df_betas_slope_DM %>% filter(Bool_good_convergence == TRUE),
aes(x=TMB_estimate, y=stan_mean, col=factor(Bool_good_convergence, levels=c(T, F))))+
geom_point()+geom_abline(slope = 1, intercept = 0) + ggtitle('Scatterplot of mean of\nposterior and TMB ML estimate')+
theme(legend.position = "bottom")
ggsave("../../results/TMB/betas_stan_TMB_DM2.pdf")
ggplot(df_betas_slope_DM %>% filter(Bool_good_convergence == TRUE),
aes(x=TMB_estimate, y=stan_mean))+
geom_point()+geom_abline(slope = 1, intercept = 0) + ggtitle('Scatterplot of mean of\nposterior and TMB ML estimate')+
theme(legend.position = "bottom")+facet_wrap(.~factor(Bool_good_convergence, levels=c(T, F)))
ggplot(df_betas_slope_DM),
aes(x=TMB_estimate, y=stan_mean))+
geom_point()+geom_abline(slope = 1, intercept = 0) + ggtitle('Scatterplot of mean of\nposterior and TMB ML estimate')+
theme(legend.position = "bottom")+facet_wrap(.~factor(Bool_good_convergence, levels=c(T, F)))
ggplot(df_betas_slope_DM,
aes(x=TMB_estimate, y=stan_mean))+
geom_point()+geom_abline(slope = 1, intercept = 0) + ggtitle('Scatterplot of mean of\nposterior and TMB ML estimate')+
theme(legend.position = "bottom")+facet_wrap(.~factor(Bool_good_convergence, levels=c(T, F)))
ggplot(df_betas_slope_DM,
aes(x=TMB_estimate, y=stan_mean, col=factor(Bool_good_convergence, levels=c(F, T))))+
geom_point()+ggtitle('Scatterplot of mean of\nposterior and TMB ML estimate')+theme(legend.position = "bottom")+
geom_abline(intercept = 0, slope = 1)
ggsave("../../results/TMB/betas_stan_TMB_DM.pdf")
ggplot(df_betas_slope_DM %>% filter(Bool_good_convergence == TRUE),
aes(x=TMB_estimate, y=stan_mean, col=factor(Bool_good_convergence, levels=c(F, T))))+
geom_point()+geom_abline(slope = 1, intercept = 0) + ggtitle('Scatterplot of mean of\nposterior and TMB ML estimate')+
theme(legend.position = "bottom")
ggsave("../../results/TMB/betas_stan_TMB_DM2.pdf")
ggplot(df_betas_slope_DM,
aes(x=TMB_estimate, y=stan_mean))+
geom_point()+geom_abline(slope = 1, intercept = 0) + ggtitle('Scatterplot of mean of\nposterior and TMB ML estimate')+
theme(legend.position = "bottom")+facet_wrap(.~factor(Bool_good_convergence, levels=c(F, T)))
ggplot(df_betas_slope_DM,
aes(x=TMB_estimate, y=stan_mean))+
geom_point()+geom_abline(slope = 1, intercept = 0) + ggtitle('Scatterplot of mean of\nposterior and TMB ML estimate')+
theme(legend.position = "bottom")+facet_wrap(.~ct)
## same plot, but without the outliers
ggplot(df_betas_slope_DM %>% filter(Bool_good_convergence == TRUE),
aes(x=TMB_estimate, y=stan_mean, col=Bool_good_convergence))+
geom_point()+geom_abline(slope = 1, intercept = 0) + ggtitle('Scatterplot of mean of posterior and TMB ML estimate')+
theme(legend.position = "bottom")+facet_wrap(.~ct, scales = "free")
df_betas_slope_DM$Bool_good_convergence
ggplot(df_betas_slope_DM,
aes(x=TMB_estimate, y=stan_mean))+
geom_point()+geom_abline(slope = 1, intercept = 0) + ggtitle('Scatterplot of mean of\nposterior and TMB ML estimate')+
theme(legend.position = "bottom")+facet_wrap(.~ct)
ggplot(df_betas_slope_DM,
aes(x=TMB_estimate, y=stan_mean))+
geom_point()+geom_abline(slope = 1, intercept = 0) + ggtitle('Scatterplot of mean of\nposterior and TMB ML estimate')+
theme(legend.position = "bottom")+facet_wrap(.~ct, scales = "free")
dev.off()
ggplot(df_betas_slope_DM,
aes(x=TMB_estimate, y=stan_mean))+
geom_point()+geom_abline(slope = 1, intercept = 0) + ggtitle('Scatterplot of mean of\nposterior and TMB ML estimate')+
theme(legend.position = "bottom")+facet_wrap(.~ct, scales = "free")
folder_robjs
results_TMB_DM_dep = lapply( python_like_select(list.files("../../data/robjects_cache/tmb_results_dep/"), "^DM_"),
function(i) readRDS(paste0("../../data/robjects_cache/tmb_results_dep/", i)))
names(results_TMB_DM_dep) = sapply(python_like_select(list.files("../../data/robjects_cache/tmb_results_dep/"), "^DM_"), clean_name)
results_TMB_DM_dep
subset_results_TMB_DM_dep = results_TMB_DM_dep[match(sapply(names(betasDM$posteriors_betas_slope), function(i) paste0(strsplit(i, '_')[[1]][1:2], collapse = "")),
names(ç))]
subset_results_TMB_DM_dep = results_TMB_DM_dep[match(sapply(names(betasDM$posteriors_betas_slope), function(i) paste0(strsplit(i, '_')[[1]][1:2], collapse = "")),
names(results_TMB_DM_dep))]
unlisted_TMB_DM_dep = sapply(unlisted_TMB_list(subset_results_TMB_DM_dep), select_slope)
df_betas_slope_DM = cbind.data.frame( TMB_estimate=(unlisted_TMB_DM %>% unlist), stan_mean=(unlisted_stan_mean_DM %>% unlist),
TMB_estimate_dep=(unlisted_TMB_DM_dep %>% unlist), stan_mean=(unlisted_stan_mean_DM %>% unlist),
Bool_good_convergence=factor(rep(sapply(subset_results_TMB_DM, give_summary_per_sample) == "Good",
as.vector(sapply(subset_results_TMB_DM, function(i) sum(names(i$par.fixed) == "beta"))))),
ct = rep(sapply(names(unlisted_stan_mean_DM), function(i) paste0(strsplit(i, '_')[[1]][1:2], collapse = " ")),
sapply(unlisted_TMB_DM, length)))
unlisted_TMB_list(subset_results_TMB_DM_dep)
unlisted_TMB_M
unlisted_TMB_DM_dep = unlisted_TMB_list(subset_results_TMB_DM_dep)
df_betas_slope_DM = cbind.data.frame( TMB_estimate=(unlisted_TMB_DM %>% unlist), stan_mean=(unlisted_stan_mean_DM %>% unlist),
TMB_estimate_dep=(unlisted_TMB_DM_dep %>% unlist), stan_mean=(unlisted_stan_mean_DM %>% unlist),
Bool_good_convergence=factor(rep(sapply(subset_results_TMB_DM, give_summary_per_sample) == "Good",
as.vector(sapply(subset_results_TMB_DM, function(i) sum(names(i$par.fixed) == "beta"))))),
ct = rep(sapply(names(unlisted_stan_mean_DM), function(i) paste0(strsplit(i, '_')[[1]][1:2], collapse = " ")),
sapply(unlisted_TMB_DM, length)))
list(TMB_estimate=(unlisted_TMB_DM %>% unlist), stan_mean=(unlisted_stan_mean_DM %>% unlist),
TMB_estimate_dep=(unlisted_TMB_DM_dep %>% unlist), stan_mean=(unlisted_stan_mean_DM %>% unlist),
Bool_good_convergence=factor(rep(sapply(subset_results_TMB_DM, give_summary_per_sample) == "Good",
as.vector(sapply(subset_results_TMB_DM, function(i) sum(names(i$par.fixed) == "beta"))))),
ct = rep(sapply(names(unlisted_stan_mean_DM), function(i) paste0(strsplit(i, '_')[[1]][1:2], collapse = " ")),
sapply(unlisted_TMB_DM, length)))
lapply(list(TMB_estimate=(unlisted_TMB_DM %>% unlist), stan_mean=(unlisted_stan_mean_DM %>% unlist),
TMB_estimate_dep=(unlisted_TMB_DM_dep %>% unlist), stan_mean=(unlisted_stan_mean_DM %>% unlist),
Bool_good_convergence=factor(rep(sapply(subset_results_TMB_DM, give_summary_per_sample) == "Good",
as.vector(sapply(subset_results_TMB_DM, function(i) sum(names(i$par.fixed) == "beta"))))),
ct = rep(sapply(names(unlisted_stan_mean_DM), function(i) paste0(strsplit(i, '_')[[1]][1:2], collapse = " ")),
sapply(unlisted_TMB_DM, length))), length)
df_betas_slope_DM = cbind.data.frame( TMB_estimate=(unlisted_TMB_DM %>% unlist), stan_mean=(unlisted_stan_mean_DM %>% unlist),
TMB_estimate_dep=(unlisted_TMB_DM_dep %>% unlist), stan_mean=(unlisted_stan_mean_DM %>% unlist),
Bool_good_convergence=factor(rep(sapply(subset_results_TMB_DM, give_summary_per_sample) == "Good",
as.vector(sapply(subset_results_TMB_DM, function(i) sum(names(i$par.fixed) == "beta")/2)))), ## /2 because of the intercept and the slope
ct = rep(sapply(names(unlisted_stan_mean_DM), function(i) paste0(strsplit(i, '_')[[1]][1:2], collapse = " ")),
sapply(unlisted_TMB_DM, length)))
## same plot, but only with good convergence
ggplot(df_betas_slope_DM %>% filter(Bool_good_convergence == TRUE),
aes(x=TMB_estimate, y=stan_mean))+
geom_point()+geom_abline(slope = 1, intercept = 0) + ggtitle('Scatterplot of mean of posterior and TMB ML estimate')+
theme(legend.position = "bottom")+facet_wrap(.~ct, scales = "free")
df_betas_slope_DM = cbind.data.frame( TMB_estimate=(unlisted_TMB_DM %>% unlist),
stan_mean=(unlisted_stan_mean_DM %>% unlist),
TMB_estimate_dep=(unlisted_TMB_DM_dep %>% unlist),
Bool_good_convergence=factor(rep(sapply(subset_results_TMB_DM, give_summary_per_sample) == "Good",
as.vector(sapply(subset_results_TMB_DM, function(i) sum(names(i$par.fixed) == "beta")/2)))), ## /2 because of the intercept and the slope
ct = rep(sapply(names(unlisted_stan_mean_DM), function(i) paste0(strsplit(i, '_')[[1]][1:2], collapse = " ")),
sapply(unlisted_TMB_DM, length)))
## same plot, but only with good convergence
ggplot(df_betas_slope_DM %>% filter(Bool_good_convergence == TRUE),
aes(x=TMB_estimate, y=stan_mean))+
geom_point()+geom_abline(slope = 1, intercept = 0) + ggtitle('Scatterplot of mean of posterior and TMB ML estimate')+
theme(legend.position = "bottom")+facet_wrap(.~ct, scales = "free")
ggplot(df_betas_slope_DM,
aes(x=TMB_estimate_dep, y=stan_mean))+
geom_point()+geom_abline(slope = 1, intercept = 0) + ggtitle('Scatterplot of mean of posterior and TMB ML estimate')+
theme(legend.position = "bottom")+facet_wrap(.~ct, scales = "free")
## same plot, but trying to see where it went well and where it did not
ggplot(df_betas_slope_M,
aes(x=TMB_estimate, y=stan_mean, col=Bool_good_convergence))+
geom_point()+ggtitle('Scatterplot of mean of posterior and TMB ML estimate')+
geom_abline(slope = 1, intercept = 0)+theme(legend.position = "bottom")+facet_wrap(.~factor(ct))
rm(list = ls())
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
# setwd("~/Documents/PhD/GlobalDA/code/2_inference_TMB/mm_multinomial/")
library(TMB)
library(scales)
library(uuid)
library(ROCR)
library(ggplot2)
library(gridExtra)
library(dplyr)
library(xtable)
source("../1_create_ROO/roo_functions.R")
source("../2_inference/helper/helper_DA_stan.R") ## for normalise_rw
source("mm_multinomial/helper_functions.R")
source("helper_TMB.R")
uuid = uuid::UUIDgenerate()
re_run_test = FALSE ## use cache
# set.seed(1245)
#-------------------------------------------------------------------------------------------------#
#-------------------------------------------------------------------------------------------------#
TMB::compile("mm_multinomial/ME_LNM.cpp", "-std=gnu++17")
dyn.load(dynlib("mm_multinomial/ME_LNM"))
TMB::compile("mm_multinomial/ME_multinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("mm_multinomial/ME_multinomial"))
TMB::compile("mm_multinomial/ME_dirichletmultinomial.cpp", "-std=gnu++17")
dyn.load(dynlib("mm_multinomial/ME_dirichletmultinomial"))
#-------------------------------------------------------------------------------------------------#
#-------------------------------------------------------------------------------------------------#
datasets_files = list.files("../../data/assessing_models_simulation/datasets/", full.names = TRUE)
re_run_test
if(re_run_test){
runs_M = lapply(datasets_files, function(i)  try(wrapper_run_TMB(i, model = "M", typedata = "simulation", simulation = TRUE)))
names(runs_M) = gsub(".RDS", "", basename(datasets_files))
saveRDS(object = runs_M, file = paste0("../../data/robjects_cache/tmb_results_simulations/simulation_runs_M_", uuid, ".RDS"))
}else{
runs_M = readRDS("../../data/robjects_cache/tmb_results_simulations/simulation_runs_M_17b8ae57-29f2-4ffe-951b-2bad65ec6387.RDS")
}
if(re_run_test){
runs_DM = lapply(datasets_files, function(i)  try(wrapper_run_TMB(i, model = "DM", typedata = "simulation", simulation = TRUE)))
names(runs_DM) = gsub(".RDS", "", basename(datasets_files))
saveRDS(object = runs_DM, file = paste0("../../data/robjects_cache/tmb_results_simulations/simulation_runs_DM_", uuid, ".RDS"))
}else{
runs_DM = readRDS("../../data/robjects_cache/tmb_results_simulations/simulation_runs_DM_17b8ae57-29f2-4ffe-951b-2bad65ec6387.RDS")
}
if(re_run_test){
runs_LNM = lapply(datasets_files, function(i)  try( wrapper_run_TMB(i, model = "LNM", typedata = "simulation", simulation = TRUE)))
names(runs_LNM) = gsub(".RDS", "", basename(datasets_files))
saveRDS(object = runs_LNM, file = paste0("../../data/robjects_cache/tmb_results_simulations/simulation_runs_LNM_", uuid, ".RDS"))
}else{
runs_LNM = readRDS("../../data/robjects_cache/tmb_results_simulations/simulation_runs_LNM_17b8ae57-29f2-4ffe-951b-2bad65ec6387.RDS")
}
wrapper_run_ttest = function(i){
x = readRDS(i)
x = x[[1]]@count_matrices_all
props = sapply(x, normalise_rw, simplify = FALSE)
return(Compositional::hotel2T2(x1 = compositions::ilr(props[[1]]), x2 = compositions::ilr(props[[2]]))$pvalue)
}
runs_ttest_proportions = lapply(datasets_files, function(i)  try(wrapper_run_ttest(i)))
pvals_ttest = as.numeric(unlist(runs_ttest_proportions))
## assess if there was good convergence
runs_M[[10]]
sapply(runs_M, typeof)
pvals_M = sapply(runs_M, wald_TMB_wrapper)
pvals_DM = sapply(runs_DM, wald_TMB_wrapper)
pvals_LNM = sapply(runs_LNM, wald_TMB_wrapper)
## adjust p-values
## TO DO
pvals_M_adj = pvals_M
pvals_DM_adj = pvals_DM
pvals_LNM_adj = pvals_LNM
pvals_ttest_adj = pvals_ttest
sapply(list(M=pvals_M_adj <= 0.05, DM=pvals_DM_adj <= 0.05, LNM=pvals_LNM_adj <= 0.05, ttest=pvals_ttest_adj <= 0.05), table)
VennDiagram::venn.diagram(as.vector(table(pvals_M <= 0.05, pvals_DM <= 0.05, pvals_LNM <= 0.05)))
## which simulations were actually differentially abundant?
datasets = lapply(datasets_files, readRDS)
DA_bool = ( sapply(datasets, function(i) i$beta_gamma_shape) > 0 )
sapply(datasets, function(i) i$beta[1,])
table(DA_bool) ## most are differentially abundant
## Remove outlier datasets
plot(density(sapply(datasets, function(i) max(i$beta[2,]))))
remove_idx_datasets = which(sapply(datasets, function(i) max(i$beta[2,])) > 5)
datasets = datasets[-remove_idx_datasets]
pvals_M_adj = pvals_M_adj[-remove_idx_datasets]
pvals_DM_adj = pvals_DM_adj[-remove_idx_datasets]
pvals_LNM_adj = pvals_LNM_adj[-remove_idx_datasets]
pvals_ttest_adj = pvals_ttest_adj[-remove_idx_datasets]
runs_M = runs_M[-remove_idx_datasets]
runs_DM = runs_DM[-remove_idx_datasets]
runs_LNM = runs_LNM[-remove_idx_datasets]
DA_bool = DA_bool[-remove_idx_datasets]
summarise_DA_detection = function(true, predicted){
## remove NAs
which_na = which(is.na(predicted))
if(length(which_na) > 0){ ## some NA
true = true[-which_na]
predicted = predicted[-which_na]
}
FPs = sum(!true & predicted)/sum(predicted)
TPs = sum(true & predicted)/sum(predicted)
TNs = sum(!true & !predicted)/sum(!predicted)
FNs = sum(true & !predicted)/sum(!predicted)
total_pos = sum(true | predicted)
Power = TPs/total_pos
Sensitivity = TPs / (TPs + FNs)
Specificity = TNs / (TNs + FPs)
pred <- prediction(as.numeric(true), as.numeric(predicted))
AUC = try(performance(pred, "auc")@y.values[[1]])
return(c(FP=FPs, TP=TPs, Power=Power, AUC=AUC, Specificity=Specificity, Sensitivity=Sensitivity))
}
## they are all pretty horrendous in terms of FP
summarise_DA_detection(true = DA_bool, predicted = pvals_M_adj <= 0.05)
summarise_DA_detection(true = DA_bool, predicted = pvals_DM_adj <= 0.05)
summarise_DA_detection(true = DA_bool, predicted = pvals_LNM_adj <= 0.05)
summarise_DA_detection(true = DA_bool, predicted = pvals_ttest_adj <= 0.05)
all_summary = do.call('rbind', list(M=summarise_DA_detection(true = DA_bool, predicted = pvals_M_adj <= 0.05),
DM=summarise_DA_detection(true = DA_bool, predicted = pvals_DM_adj <= 0.05),
LNM=summarise_DA_detection(true = DA_bool, predicted = pvals_LNM_adj <= 0.05),
ttest=summarise_DA_detection(true = DA_bool, predicted = pvals_ttest_adj <= 0.05)))
xtable::xtable(all_summary, digits=c(0,4,4,4,4,4,4))
table(DA_bool, pvals_DM_adj <= 0.05)
## here there should be a negative correlation (higher effect size <=> lower p-value) (which there is to some extend)
par(mfrow=c(1,3))
plot( sapply(datasets, function(i) i$beta_gamma_shape), pvals_M_adj)
plot( sapply(datasets, function(i) i$beta_gamma_shape), pvals_DM_adj)
plot( sapply(datasets, function(i) i$beta_gamma_shape), pvals_LNM_adj)
## compare estimated betas to actual betas
par(mfrow=c(1,1))
plot((unlist(sapply(datasets, function(i) i$beta[2,]))),
(unlist(sapply(runs_M, function(i) select_slope(python_like_select_name(i$par.fixed, "beta"))))))
abline(coef = c(0, 1))
for(j in which(sapply(runs_DM, typeof) == "character")){
runs_DM[[j]] = list(par.fixed=c(beta=rep(NA, 2*(datasets[[j]]$d-1)))) ## *2 for slope and intercept
}
for(j in which(sapply(runs_LNM, typeof) == "character")){
runs_LNM[[j]] = list(par.fixed=c(beta=rep(NA, 2*(datasets[[j]]$d-1)))) ## *2 for slope and intercept
}
df_beta_recovery = cbind.data.frame(beta_true = unlist(sapply(datasets, function(i) i$beta[2,])),
idx = rep(1:length(datasets) , unlist(sapply(datasets, function(i) i$d))-1),
d =  rep(unlist(sapply(datasets, function(i) i$d)), unlist(sapply(datasets, function(i) i$d))-1),
n =  rep(unlist(sapply(datasets, function(i) i$n)), unlist(sapply(datasets, function(i) i$d))-1),
beta_gamma_shape =  rep(unlist(sapply(datasets, function(i) i$beta_gamma_shape)), unlist(sapply(datasets, function(i) i$d))-1),
beta_est_M = unlist(sapply(runs_M, function(i) select_slope(python_like_select_name(i$par.fixed, "beta")))),
beta_est_DM = unlist(sapply(runs_DM, function(i) select_slope(python_like_select_name(i$par.fixed, "beta")))),
beta_est_LNM = unlist(sapply(runs_LNM, function(i) select_slope(python_like_select_name(i$par.fixed, "beta")))),
pvals_M_adj=rep(pvals_M_adj, unlist(sapply(datasets, function(i) i$d))-1),
pvals_DM_adj=rep(pvals_DM_adj, unlist(sapply(datasets, function(i) i$d))-1),
pvals_LNM_adj=rep(pvals_LNM_adj, unlist(sapply(datasets, function(i) i$d))-1))
df_beta_recovery$bool_zero_true_beta = factor((df_beta_recovery$beta_true == 0), levels = c(TRUE, FALSE))
pairs(df_beta_recovery[,c('pvals_M_adj', 'pvals_DM_adj', 'pvals_LNM_adj')], main='Pairs plot of p-values')
pairs(df_beta_recovery[,c('beta_est_M', 'beta_est_DM', 'beta_est_LNM')], main='Pairs plot of betas')
table(na.omit(df_beta_recovery$pvals_M_adj <= 0.05))
table(na.omit(df_beta_recovery$pvals_DM_adj <= 0.05))
table(na.omit(df_beta_recovery$pvals_LNM_adj <= 0.05))
## zero slopes are not well detected
ggplot(df_beta_recovery,
aes(x=(beta_true), y=(beta_est_M), col=beta_gamma_shape))+geom_point()+
geom_abline(intercept = 0, slope = 1)
df_beta_recovery$idx
ggplot(df_beta_recovery,
aes(x=(beta_true), y=(beta_est_M), col=beta_gamma_shape))+geom_point()+
geom_abline(intercept = 0, slope = 1)+facet_wrap(.~idx)
ggplot(df_beta_recovery,
aes(x=(beta_true), y=(beta_est_M), col=n))+geom_point()+
geom_abline(intercept = 0, slope = 1)+facet_wrap(.~bool_zero_true_beta, scales = "free_x")
## Multinomial
p <- ggplot(df_beta_recovery,
aes(x=(beta_true), y=(beta_est_M), col=(pvals_M_adj<0.05)))+geom_point()+
geom_abline(intercept = 0, slope = 1)+facet_wrap(.~bool_zero_true_beta, scales = "free_x")
gp <- ggplotGrob(p); facet.columns <- gp$layout$l[grepl("panel", gp$layout$name)]; gp$widths[facet.columns] <- gp$widths[facet.columns] * c(1,4); grid::grid.draw(gp)
## Dirichlet-Multinomial
## there are some very extreme values of beta
plot(density(log(abs(na.omit(df_beta_recovery$beta_est_DM))))) ## all betas
plot(density(na.omit(sapply(runs_DM, function(i) max(python_like_select_name(i$par.fixed, "beta"))))))
df_beta_recovery[df_beta_recovery$idx %in% which(sapply(runs_DM, function(i) max(abs(python_like_select_name(i$par.fixed, "beta")))) > 10),'beta_est_DM'] = NA
p <- ggplot(df_beta_recovery,
aes(x=(beta_true), y=(beta_est_DM), col=(pvals_DM_adj)<0.05))+geom_point()+
geom_abline(intercept = 0, slope = 1)+facet_wrap(.~bool_zero_true_beta, scales = "free_x")
gp <- ggplotGrob(p); facet.columns <- gp$layout$l[grepl("panel", gp$layout$name)]; gp$widths[facet.columns] <- gp$widths[facet.columns] * c(1,4); grid::grid.draw(gp)
## LNM
df_beta_recovery[df_beta_recovery$idx %in% which(sapply(runs_LNM, function(i) max(abs(python_like_select_name(i$par.fixed, "beta")))) > 20),'beta_est_LNM'] = NA
p <- ggplot(df_beta_recovery,
aes(x=(beta_true), y=(beta_est_LNM), col=(pvals_LNM_adj)<0.05))+geom_point()+
geom_abline(intercept = 0, slope = 1)+facet_wrap(.~bool_zero_true_beta, scales = "free_x")
gp <- ggplotGrob(p); facet.columns <- gp$layout$l[grepl("panel", gp$layout$name)]; gp$widths[facet.columns] <- gp$widths[facet.columns] * c(1,4); grid::grid.draw(gp)
## colour code per patient
ggplot(df_beta_recovery,
aes(x=(beta_true), y=(beta_est), col=factor(idx)))+geom_point()+
geom_abline(intercept = 0, slope = 1)+guides(color=FALSE)
## a clear problem is some datasets with no zero or near-zero differential abundance having a very small p-value
df_beta_recovery[df_beta_recovery$beta_true == 0,][1:10,]
## e.g. idx=6
df_beta_recovery[df_beta_recovery$idx == 6,]
simulate_theta_from_TMB_M = function(tmb_object, dataset_object){
## there is a column of zeros because the intercepts have been absorbed by the random effects intercept
theta_sim = softmax(
cbind(t(dataset_object$X_sim) %*% t(matrix(python_like_select_name(tmb_object$par.fixed, 'beta'), ncol = 2)) +
replicate(n = dataset_object$d-1, tmb_object$par.random %*% dataset_object$Z_sim, simplify = TRUE), 0)
)
list(theta_sim[1:dataset_object$n,], theta_sim[(dataset_object$n+1):(2*dataset_object$n),])
}
simulate_theta_from_TMB_DM = function(tmb_object, dataset_object){
## there is a column of zeros because the intercepts have been absorbed by the random effects intercept
alphabar_sim = softmax(
cbind(t(dataset_object$X_sim) %*% t(matrix(python_like_select_name(tmb_object$par.fixed, 'beta'), ncol = 2)) +
replicate(n = dataset_object$d-1, tmb_object$par.random %*% dataset_object$Z_sim, simplify = TRUE), 0)
)
theta_sim = t(apply(alphabar_sim, 1, function(i) MCMCpack::rdirichlet(1, i*exp(tmb_object$par.fixed['log_lambda']))))
list(theta_sim[1:dataset_object$n,], theta_sim[(dataset_object$n+1):(2*dataset_object$n),])
}
tmb_object=runs_LNM[[1]]
tmb_object
runs_LNM = readRDS("../../data/robjects_cache/tmb_results_simulations/simulation_runs_LNM_17b8ae57-29f2-4ffe-951b-2bad65ec6387.RDS")
runs_LNM = readRDS("../../data/robjects_cache/tmb_results_simulations/simulation_runs_LNM_f4c2696a-252f-461f-840c-34008c0394be.RDS")
# t.test2 <- function(m1,m2,s1,s2,n1,n2,m0=0,equal.variance=FALSE){
#   if( equal.variance==FALSE )
#   {
#     se <- sqrt( (s1^2/n1) + (s2^2/n2) )
#     # welch-satterthwaite df
#     df <- ( (s1^2/n1 + s2^2/n2)^2 )/( (s1^2/n1)^2/(n1-1) + (s2^2/n2)^2/(n2-1) )
#   } else
#   {
#     # pooled standard deviation, scaled by the sample sizes
#     se <- sqrt( (1/n1 + 1/n2) * ((n1-1)*s1^2 + (n2-1)*s2^2)/(n1+n2-2) )
#     df <- n1+n2-2
#   }
#   t <- (m1-m2-m0)/se
#   dat <- c(m1-m2, se, t, 2*pt(-abs(t),df))
#   names(dat) <- c("Difference of means", "Std Error", "t",      "p-value")
#   return(dat)
# }
# t.test2(m1 = colMeans(props[[1]]), m2 = colMeans(props[[2]]), s1 = )
# Compositional::hotel2T2(x1 = matrix(runif(20*4), ncol=4), x2 = matrix(runif(10*4), ncol=4))
wrapper_run_ttest = function(i){
x = readRDS(i)
x = x[[1]]@count_matrices_all
props = sapply(x, normalise_rw, simplify = FALSE)
return(Compositional::hotel2T2(x1 = compositions::ilr(props[[1]]), x2 = compositions::ilr(props[[2]]))$pvalue)
}
runs_ttest_proportions = lapply(datasets_files, function(i)  try(wrapper_run_ttest(i)))
pvals_ttest = as.numeric(unlist(runs_ttest_proportions))
## assess if there was good convergence
runs_M[[10]]
sapply(runs_M, typeof)
pvals_M = sapply(runs_M, wald_TMB_wrapper)
pvals_DM = sapply(runs_DM, wald_TMB_wrapper)
pvals_LNM = sapply(runs_LNM, wald_TMB_wrapper)
pvals_DM = sapply(runs_DM, wald_TMB_wrapper)
runs_DM
pvals_DM = sapply(runs_DM, wald_TMB_wrapper)
pvals_DM = sapply(runs_DM[1:10], wald_TMB_wrapper)
sapply(runs_DM, typeof)
unlist(sapply(runs_DM, typeof))
as.vector(sapply(runs_DM, typeof))
pvals_DM = sapply(runs_DM[1:30], wald_TMB_wrapper)
pvals_DM = sapply(runs_DM[1:60], wald_TMB_wrapper)
pvals_DM = sapply(runs_DM[1:80], wald_TMB_wrapper)
pvals_DM = sapply(runs_DM[1:100], wald_TMB_wrapper)
pvals_DM = sapply(runs_DM[1:110], wald_TMB_wrapper)
pvals_DM = sapply(runs_DM[1:120], wald_TMB_wrapper)
pvals_DM = sapply(runs_DM[1:115], wald_TMB_wrapper)
pvals_DM = sapply(runs_DM[1:113], wald_TMB_wrapper)
pvals_DM = sapply(runs_DM[1:114], wald_TMB_wrapper)
runs_DM[114]
wald_TMB_wrapper
