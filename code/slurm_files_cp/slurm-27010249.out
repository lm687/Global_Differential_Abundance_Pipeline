Building DAG of jobs...
Using shell: /usr/bin/bash
Provided cores: 1 (use --cores to define parallelism)
Rules claiming more threads will be scaled down.
Job counts:
	count	jobs
	1	inference
	1

[Sun Aug  2 19:27:57 2020]
rule inference:
    input: ../data/roo/Head-SCC_signatures_ROO.RDS
    output: ../data/inference/Head-SCC_signatures_15000_DMROO.RData
    log: logs/inference/Head-SCC_signatures_15000_DM.log
    jobid: 0
    wildcards: cancer_type=Head-SCC, feature_type=signatures, nits=15000, model=DM

module load miniconda3-4.5.4-gcc-5.4.0-hivczbz
#source activate rstan_env
~/.conda/envs/rstan_env/bin/Rscript --vanilla 2_inference/fit_PCAWG.R --cancertype Head-SCC --typedata signatures --infile '../data/roo/Head-SCC_signatures_ROO.RDS' --output '../data/inference/Head-SCC_signatures_15000_DMROO.RData' --niterations 15000 --model DM
#conda deactivate
Loading required package: ggplot2
Registered S3 methods overwritten by 'ggplot2':
  method         from 
  [.quosures     rlang
  c.quosures     rlang
  print.quosures rlang
Loading required package: StanHeaders
rstan (Version 2.18.2, GitRev: 2e1f913d3ca3)
For execution on a local, multicore CPU with excess RAM we recommend calling
options(mc.cores = parallel::detectCores()).
To avoid recompilation of unchanged Stan programs, we recommend calling
rstan_options(auto_write = TRUE)
$status
[1] TRUE

$model_cppname
[1] "model6a8014f03f76c_stan_DM_ME"

$cppcode
[1] "// Code generated by Stan version 2.18.1\n\n#include <stan/model/model_header.hpp>\n\nnamespace model6a8014f03f76c_stan_DM_ME_namespace {\n\nusing std::istream;\nusing std::string;\nusing std::stringstream;\nusing std::vector;\nusing stan::io::dump;\nusing stan::math::lgamma;\nusing stan::model::prob_grad;\nusing namespace stan::math;\n\nstatic int current_statement_begin__;\n\nstan::io::program_reader prog_reader__() {\n    stan::io::program_reader reader;\n    reader.add_event(0, 0, \"start\", \"model6a8014f03f76c_stan_DM_ME\");\n    reader.add_event(57, 55, \"end\", \"model6a8014f03f76c_stan_DM_ME\");\n    return reader;\n}\n\ntemplate <bool propto, typename T1__>\ntypename boost::math::tools::promote_args<T1__>::type\ndirichlet_multinomial_lpmf(const std::vector<int>& y,\n                               const Eigen::Matrix<T1__, Eigen::Dynamic,1>& alpha, std::ostream* pstream__) {\n    typedef typename boost::math::tools::promote_args<T1__>::type local_scalar_t__;\n    typedef local_scalar_t__ fun_return_scalar_t__;\n    const static bool propto__ = true;\n    (void) propto__;\n        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());\n        (void) DUMMY_VAR__;  // suppress unused var warning\n\n    int current_statement_begin__ = -1;\n    try {\n        {\n        current_statement_begin__ = 4;\n        local_scalar_t__ alpha_plus;\n        (void) alpha_plus;  // dummy to suppress unused var warning\n\n        stan::math::initialize(alpha_plus, DUMMY_VAR__);\n        stan::math::fill(alpha_plus,DUMMY_VAR__);\n        stan::math::assign(alpha_plus,sum(alpha));\n\n\n        current_statement_begin__ = 5;\n        return stan::math::promote_scalar<fun_return_scalar_t__>((((stan::math::lgamma(alpha_plus) + sum(stan::math::lgamma(add(alpha,to_vector(y))))) - stan::math::lgamma((alpha_plus + sum(y)))) - sum(stan::math::lgamma(alpha))));\n        }\n    } catch (const std::exception& e) {\n        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());\n        // Next line prevents compiler griping about no return\n        throw std::runtime_error(\"*** IF YOU SEE THIS, PLEASE REPORT A BUG ***\");\n    }\n}\ntemplate <typename T1__>\ntypename boost::math::tools::promote_args<T1__>::type\ndirichlet_multinomial_lpmf(const std::vector<int>& y,\n                               const Eigen::Matrix<T1__, Eigen::Dynamic,1>& alpha, std::ostream* pstream__) {\n    return dirichlet_multinomial_lpmf<false>(y,alpha, pstream__);\n}\n\n\nstruct dirichlet_multinomial_lpmf_functor__ {\n    template <bool propto, typename T1__>\n        typename boost::math::tools::promote_args<T1__>::type\n    operator()(const std::vector<int>& y,\n                               const Eigen::Matrix<T1__, Eigen::Dynamic,1>& alpha, std::ostream* pstream__) const {\n        return dirichlet_multinomial_lpmf(y, alpha, pstream__);\n    }\n};\n\nclass model6a8014f03f76c_stan_DM_ME : public prob_grad {\nprivate:\n    int n;\n    int d;\n    vector<vector<int> > w;\n    int p;\n    matrix_d x;\n    matrix_d Z;\npublic:\n    model6a8014f03f76c_stan_DM_ME(stan::io::var_context& context__,\n        std::ostream* pstream__ = 0)\n        : prob_grad(0) {\n        ctor_body(context__, 0, pstream__);\n    }\n\n    model6a8014f03f76c_stan_DM_ME(stan::io::var_context& context__,\n        unsigned int random_seed__,\n        std::ostream* pstream__ = 0)\n        : prob_grad(0) {\n        ctor_body(context__, random_seed__, pstream__);\n    }\n\n    void ctor_body(stan::io::var_context& context__,\n                   unsigned int random_seed__,\n                   std::ostream* pstream__) {\n        typedef double local_scalar_t__;\n\n        boost::ecuyer1988 base_rng__ =\n          stan::services::util::create_rng(random_seed__, 0);\n        (void) base_rng__;  // suppress unused var warning\n\n        current_statement_begin__ = -1;\n\n        static const char* function__ = \"model6a8014f03f76c_stan_DM_ME_namespace::model6a8014f03f76c_stan_DM_ME\";\n        (void) function__;  // dummy to suppress unused var warning\n        size_t pos__;\n        (void) pos__;  // dummy to suppress unused var warning\n        std::vector<int> vals_i__;\n        std::vector<double> vals_r__;\n        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());\n        (void) DUMMY_VAR__;  // suppress unused var warning\n\n        // initialize member variables\n        try {\n            current_statement_begin__ = 11;\n            context__.validate_dims(\"data initialization\", \"n\", \"int\", context__.to_vec());\n            n = int(0);\n            vals_i__ = context__.vals_i(\"n\");\n            pos__ = 0;\n            n = vals_i__[pos__++];\n            current_statement_begin__ = 12;\n            context__.validate_dims(\"data initialization\", \"d\", \"int\", context__.to_vec());\n            d = int(0);\n            vals_i__ = context__.vals_i(\"d\");\n            pos__ = 0;\n            d = vals_i__[pos__++];\n            current_statement_begin__ = 13;\n            validate_non_negative_index(\"w\", \"(2 * n)\", (2 * n));\n            validate_non_negative_index(\"w\", \"d\", d);\n            context__.validate_dims(\"data initialization\", \"w\", \"int\", context__.to_vec((2 * n),d));\n            validate_non_negative_index(\"w\", \"(2 * n)\", (2 * n));\n            validate_non_negative_index(\"w\", \"d\", d);\n            w = std::vector<std::vector<int> >((2 * n),std::vector<int>(d,int(0)));\n            vals_i__ = context__.vals_i(\"w\");\n            pos__ = 0;\n            size_t w_limit_1__ = d;\n            for (size_t i_1__ = 0; i_1__ < w_limit_1__; ++i_1__) {\n                size_t w_limit_0__ = (2 * n);\n                for (size_t i_0__ = 0; i_0__ < w_limit_0__; ++i_0__) {\n                    w[i_0__][i_1__] = vals_i__[pos__++];\n                }\n            }\n            current_statement_begin__ = 14;\n            context__.validate_dims(\"data initialization\", \"p\", \"int\", context__.to_vec());\n            p = int(0);\n            vals_i__ = context__.vals_i(\"p\");\n            pos__ = 0;\n            p = vals_i__[pos__++];\n            current_statement_begin__ = 15;\n            validate_non_negative_index(\"x\", \"p\", p);\n            validate_non_negative_index(\"x\", \"(2 * n)\", (2 * n));\n            context__.validate_dims(\"data initialization\", \"x\", \"matrix_d\", context__.to_vec(p,(2 * n)));\n            validate_non_negative_index(\"x\", \"p\", p);\n            validate_non_negative_index(\"x\", \"(2 * n)\", (2 * n));\n            x = matrix_d(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>((2 * n)));\n            vals_r__ = context__.vals_r(\"x\");\n            pos__ = 0;\n            size_t x_m_mat_lim__ = p;\n            size_t x_n_mat_lim__ = (2 * n);\n            for (size_t n_mat__ = 0; n_mat__ < x_n_mat_lim__; ++n_mat__) {\n                for (size_t m_mat__ = 0; m_mat__ < x_m_mat_lim__; ++m_mat__) {\n                    x(m_mat__,n_mat__) = vals_r__[pos__++];\n                }\n            }\n            current_statement_begin__ = 16;\n            validate_non_negative_index(\"Z\", \"n\", n);\n            validate_non_negative_index(\"Z\", \"(2 * n)\", (2 * n));\n            context__.validate_dims(\"data initialization\", \"Z\", \"matrix_d\", context__.to_vec(n,(2 * n)));\n            validate_non_negative_index(\"Z\", \"n\", n);\n            validate_non_negative_index(\"Z\", \"(2 * n)\", (2 * n));\n            Z = matrix_d(static_cast<Eigen::VectorXd::Index>(n),static_cast<Eigen::VectorXd::Index>((2 * n)));\n            vals_r__ = context__.vals_r(\"Z\");\n            pos__ = 0;\n            size_t Z_m_mat_lim__ = n;\n            size_t Z_n_mat_lim__ = (2 * n);\n            for (size_t n_mat__ = 0; n_mat__ < Z_n_mat_lim__; ++n_mat__) {\n                for (size_t m_mat__ = 0; m_mat__ < Z_m_mat_lim__; ++m_mat__) {\n                    Z(m_mat__,n_mat__) = vals_r__[pos__++];\n                }\n            }\n\n            // validate, data variables\n            current_statement_begin__ = 11;\n            check_greater_or_equal(function__,\"n\",n,0);\n            current_statement_begin__ = 12;\n            check_greater_or_equal(function__,\"d\",d,0);\n            current_statement_begin__ = 13;\n            current_statement_begin__ = 14;\n            current_statement_begin__ = 15;\n            current_statement_begin__ = 16;\n            // initialize data variables\n\n\n            // validate transformed data\n\n            // validate, set parameter ranges\n            num_params_r__ = 0U;\n            param_ranges_i__.clear();\n            current_statement_begin__ = 20;\n        validate_non_negative_index(\"beta\", \"p\", p);\n            validate_non_negative_index(\"beta\", \"(d - 1)\", (d - 1));\n            num_params_r__ += p * (d - 1);\n            current_statement_begin__ = 21;\n            validate_non_negative_index(\"u\", \"n\", n);\n            num_params_r__ += n;\n            current_statement_begin__ = 22;\n            ++num_params_r__;\n            current_statement_begin__ = 23;\n            validate_non_negative_index(\"overdispersion_scalar\", \"2\", 2);\n            num_params_r__ += 2;\n        } catch (const std::exception& e) {\n            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());\n            // Next line prevents compiler griping about no return\n            throw std::runtime_error(\"*** IF YOU SEE THIS, PLEASE REPORT A BUG ***\");\n        }\n    }\n\n    ~model6a8014f03f76c_stan_DM_ME() { }\n\n\n    void transform_inits(const stan::io::var_context& context__,\n                         std::vector<int>& params_i__,\n                         std::vector<double>& params_r__,\n                         std::ostream* pstream__) const {\n        stan::io::writer<double> writer__(params_r__,params_i__);\n        size_t pos__;\n        (void) pos__; // dummy call to supress warning\n        std::vector<double> vals_r__;\n        std::vector<int> vals_i__;\n\n        if (!(context__.contains_r(\"beta\")))\n            throw std::runtime_error(\"variable beta missing\");\n        vals_r__ = context__.vals_r(\"beta\");\n        pos__ = 0U;\n        validate_non_negative_index(\"beta\", \"p\", p);\n        validate_non_negative_index(\"beta\", \"(d - 1)\", (d - 1));\n        context__.validate_dims(\"initialization\", \"beta\", \"matrix_d\", context__.to_vec(p,(d - 1)));\n        matrix_d beta(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>((d - 1)));\n        for (int j2__ = 0U; j2__ < (d - 1); ++j2__)\n            for (int j1__ = 0U; j1__ < p; ++j1__)\n                beta(j1__,j2__) = vals_r__[pos__++];\n        try {\n            writer__.matrix_unconstrain(beta);\n        } catch (const std::exception& e) { \n            throw std::runtime_error(std::string(\"Error transforming variable beta: \") + e.what());\n        }\n\n        if (!(context__.contains_r(\"u\")))\n            throw std::runtime_error(\"variable u missing\");\n        vals_r__ = context__.vals_r(\"u\");\n        pos__ = 0U;\n        validate_non_negative_index(\"u\", \"n\", n);\n        context__.validate_dims(\"initialization\", \"u\", \"vector_d\", context__.to_vec(n));\n        vector_d u(static_cast<Eigen::VectorXd::Index>(n));\n        for (int j1__ = 0U; j1__ < n; ++j1__)\n            u(j1__) = vals_r__[pos__++];\n        try {\n            writer__.vector_unconstrain(u);\n        } catch (const std::exception& e) { \n            throw std::runtime_error(std::string(\"Error transforming variable u: \") + e.what());\n        }\n\n        if (!(context__.contains_r(\"var_u\")))\n            throw std::runtime_error(\"variable var_u missing\");\n        vals_r__ = context__.vals_r(\"var_u\");\n        pos__ = 0U;\n        context__.validate_dims(\"initialization\", \"var_u\", \"double\", context__.to_vec());\n        double var_u(0);\n        var_u = vals_r__[pos__++];\n        try {\n            writer__.scalar_lb_unconstrain(0,var_u);\n        } catch (const std::exception& e) { \n            throw std::runtime_error(std::string(\"Error transforming variable var_u: \") + e.what());\n        }\n\n        if (!(context__.contains_r(\"overdispersion_scalar\")))\n            throw std::runtime_error(\"variable overdispersion_scalar missing\");\n        vals_r__ = context__.vals_r(\"overdispersion_scalar\");\n        pos__ = 0U;\n        validate_non_negative_index(\"overdispersion_scalar\", \"2\", 2);\n        context__.validate_dims(\"initialization\", \"overdispersion_scalar\", \"double\", context__.to_vec(2));\n        std::vector<double> overdispersion_scalar(2,double(0));\n        for (int i0__ = 0U; i0__ < 2; ++i0__)\n            overdispersion_scalar[i0__] = vals_r__[pos__++];\n        for (int i0__ = 0U; i0__ < 2; ++i0__)\n            try {\n            writer__.scalar_lb_unconstrain(0,overdispersion_scalar[i0__]);\n        } catch (const std::exception& e) { \n            throw std::runtime_error(std::string(\"Error transforming variable overdispersion_scalar: \") + e.what());\n        }\n\n        params_r__ = writer__.data_r();\n        params_i__ = writer__.data_i();\n    }\n\n    void transform_inits(const stan::io::var_context& context,\n                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,\n                         std::ostream* pstream__) const {\n      std::vector<double> params_r_vec;\n      std::vector<int> params_i_vec;\n      transform_inits(context, params_i_vec, params_r_vec, pstream__);\n      params_r.resize(params_r_vec.size());\n      for (int i = 0; i < params_r.size(); ++i)\n        params_r(i) = params_r_vec[i];\n    }\n\n\n    template <bool propto__, bool jacobian__, typename T__>\n    T__ log_prob(vector<T__>& params_r__,\n                 vector<int>& params_i__,\n                 std::ostream* pstream__ = 0) const {\n\n        typedef T__ local_scalar_t__;\n\n        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());\n        (void) DUMMY_VAR__;  // suppress unused var warning\n\n        T__ lp__(0.0);\n        stan::math::accumulator<T__> lp_accum__;\n\n        try {\n            // model parameters\n            stan::io::reader<local_scalar_t__> in__(params_r__,params_i__);\n\n            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  beta;\n            (void) beta;  // dummy to suppress unused var warning\n            if (jacobian__)\n                beta = in__.matrix_constrain(p,(d - 1),lp__);\n            else\n                beta = in__.matrix_constrain(p,(d - 1));\n\n            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  u;\n            (void) u;  // dummy to suppress unused var warning\n            if (jacobian__)\n                u = in__.vector_constrain(n,lp__);\n            else\n                u = in__.vector_constrain(n);\n\n            local_scalar_t__ var_u;\n            (void) var_u;  // dummy to suppress unused var warning\n            if (jacobian__)\n                var_u = in__.scalar_lb_constrain(0,lp__);\n            else\n                var_u = in__.scalar_lb_constrain(0);\n\n            vector<local_scalar_t__> overdispersion_scalar;\n            size_t dim_overdispersion_scalar_0__ = 2;\n            overdispersion_scalar.reserve(dim_overdispersion_scalar_0__);\n            for (size_t k_0__ = 0; k_0__ < dim_overdispersion_scalar_0__; ++k_0__) {\n                if (jacobian__)\n                    overdispersion_scalar.push_back(in__.scalar_lb_constrain(0,lp__));\n                else\n                    overdispersion_scalar.push_back(in__.scalar_lb_constrain(0));\n            }\n\n\n            // transformed parameters\n            current_statement_begin__ = 27;\n            validate_non_negative_index(\"alpha_mean\", \"(2 * n)\", (2 * n));\n            validate_non_negative_index(\"alpha_mean\", \"d\", d);\n            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  alpha_mean(static_cast<Eigen::VectorXd::Index>((2 * n)),static_cast<Eigen::VectorXd::Index>(d));\n            (void) alpha_mean;  // dummy to suppress unused var warning\n\n            stan::math::initialize(alpha_mean, DUMMY_VAR__);\n            stan::math::fill(alpha_mean,DUMMY_VAR__);\n            current_statement_begin__ = 28;\n            validate_non_negative_index(\"alpha\", \"(2 * n)\", (2 * n));\n            validate_non_negative_index(\"alpha\", \"d\", d);\n            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  alpha(static_cast<Eigen::VectorXd::Index>((2 * n)),static_cast<Eigen::VectorXd::Index>(d));\n            (void) alpha;  // dummy to suppress unused var warning\n\n            stan::math::initialize(alpha, DUMMY_VAR__);\n            stan::math::fill(alpha,DUMMY_VAR__);\n            current_statement_begin__ = 29;\n            validate_non_negative_index(\"overdispersion_scalars\", \"(2 * n)\", (2 * n));\n            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  overdispersion_scalars(static_cast<Eigen::VectorXd::Index>((2 * n)));\n            (void) overdispersion_scalars;  // dummy to suppress unused var warning\n\n            stan::math::initialize(overdispersion_scalars, DUMMY_VAR__);\n            stan::math::fill(overdispersion_scalars,DUMMY_VAR__);\n            stan::math::assign(overdispersion_scalars,append_row(rep_vector(get_base1(overdispersion_scalar,1,\"overdispersion_scalar\",1),n),rep_vector(get_base1(overdispersion_scalar,2,\"overdispersion_scalar\",1),n)));\n\n\n            current_statement_begin__ = 31;\n            stan::math::assign(alpha_mean, append_col(add(multiply(transpose(x),beta),multiply(transpose(Z),rep_matrix(u,(d - 1)))),rep_vector(0,(2 * n))));\n            current_statement_begin__ = 32;\n            for (int l = 1; l <= (2 * n); ++l) {\n\n                current_statement_begin__ = 33;\n                stan::model::assign(alpha, \n                            stan::model::cons_list(stan::model::index_uni(l), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), \n                            multiply(to_row_vector(softmax(to_vector(stan::model::rvalue(alpha_mean, stan::model::cons_list(stan::model::index_uni(l), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), \"alpha_mean\")))),get_base1(overdispersion_scalars,l,\"overdispersion_scalars\",1)), \n                            \"assigning variable alpha\");\n            }\n\n            // validate transformed parameters\n            for (int i0__ = 0; i0__ < (2 * n); ++i0__) {\n                for (int i1__ = 0; i1__ < d; ++i1__) {\n                    if (stan::math::is_uninitialized(alpha_mean(i0__,i1__))) {\n                        std::stringstream msg__;\n                        msg__ << \"Undefined transformed parameter: alpha_mean\" << '[' << i0__ << ']' << '[' << i1__ << ']';\n                        throw std::runtime_error(msg__.str());\n                    }\n                }\n            }\n            for (int i0__ = 0; i0__ < (2 * n); ++i0__) {\n                for (int i1__ = 0; i1__ < d; ++i1__) {\n                    if (stan::math::is_uninitialized(alpha(i0__,i1__))) {\n                        std::stringstream msg__;\n                        msg__ << \"Undefined transformed parameter: alpha\" << '[' << i0__ << ']' << '[' << i1__ << ']';\n                        throw std::runtime_error(msg__.str());\n                    }\n                }\n            }\n            for (int i0__ = 0; i0__ < (2 * n); ++i0__) {\n                if (stan::math::is_uninitialized(overdispersion_scalars(i0__))) {\n                    std::stringstream msg__;\n                    msg__ << \"Undefined transformed parameter: overdispersion_scalars\" << '[' << i0__ << ']';\n                    throw std::runtime_error(msg__.str());\n                }\n            }\n\n            const char* function__ = \"validate transformed params\";\n            (void) function__;  // dummy to suppress unused var warning\n            current_statement_begin__ = 27;\n            current_statement_begin__ = 28;\n            check_greater_or_equal(function__,\"alpha\",alpha,0);\n            current_statement_begin__ = 29;\n            check_greater_or_equal(function__,\"overdispersion_scalars\",overdispersion_scalars,0);\n\n            // model body\n\n            current_statement_begin__ = 39;\n            lp_accum__.add(gamma_log<propto__>(var_u, 5, 5));\n            current_statement_begin__ = 41;\n            lp_accum__.add(normal_log<propto__>(overdispersion_scalar, 1, 1));\n            current_statement_begin__ = 44;\n            for (int d_it = 1; d_it <= (d - 1); ++d_it) {\n\n                current_statement_begin__ = 45;\n                lp_accum__.add(uniform_log<propto__>(stan::model::rvalue(beta, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(d_it), stan::model::nil_index_list())), \"beta\"), -(5), 5));\n            }\n            current_statement_begin__ = 49;\n            lp_accum__.add(normal_log<propto__>(to_vector(u), 0, stan::math::sqrt(var_u)));\n            current_statement_begin__ = 51;\n            for (int l = 1; l <= (2 * n); ++l) {\n\n                current_statement_begin__ = 52;\n                lp_accum__.add(dirichlet_multinomial_lpmf<propto__>(stan::model::rvalue(w, stan::model::cons_list(stan::model::index_uni(l), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), \"w\"), to_vector(stan::model::rvalue(alpha, stan::model::cons_list(stan::model::index_uni(l), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), \"alpha\")), pstream__));\n            }\n\n        } catch (const std::exception& e) {\n            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());\n            // Next line prevents compiler griping about no return\n            throw std::runtime_error(\"*** IF YOU SEE THIS, PLEASE REPORT A BUG ***\");\n        }\n\n        lp_accum__.add(lp__);\n        return lp_accum__.sum();\n\n    } // log_prob()\n\n    template <bool propto, bool jacobian, typename T_>\n    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,\n               std::ostream* pstream = 0) const {\n      std::vector<T_> vec_params_r;\n      vec_params_r.reserve(params_r.size());\n      for (int i = 0; i < params_r.size(); ++i)\n        vec_params_r.push_back(params_r(i));\n      std::vector<int> vec_params_i;\n      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);\n    }\n\n\n    void get_param_names(std::vector<std::string>& names__) const {\n        names__.resize(0);\n        names__.push_back(\"beta\");\n        names__.push_back(\"u\");\n        names__.push_back(\"var_u\");\n        names__.push_back(\"overdispersion_scalar\");\n        names__.push_back(\"alpha_mean\");\n        names__.push_back(\"alpha\");\n        names__.push_back(\"overdispersion_scalars\");\n    }\n\n\n    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {\n        dimss__.resize(0);\n        std::vector<size_t> dims__;\n        dims__.resize(0);\n        dims__.push_back(p);\n        dims__.push_back((d - 1));\n        dimss__.push_back(dims__);\n        dims__.resize(0);\n        dims__.push_back(n);\n        dimss__.push_back(dims__);\n        dims__.resize(0);\n        dimss__.push_back(dims__);\n        dims__.resize(0);\n        dims__.push_back(2);\n        dimss__.push_back(dims__);\n        dims__.resize(0);\n        dims__.push_back((2 * n));\n        dims__.push_back(d);\n        dimss__.push_back(dims__);\n        dims__.resize(0);\n        dims__.push_back((2 * n));\n        dims__.push_back(d);\n        dimss__.push_back(dims__);\n        dims__.resize(0);\n        dims__.push_back((2 * n));\n        dimss__.push_back(dims__);\n    }\n\n    template <typename RNG>\n    void write_array(RNG& base_rng__,\n                     std::vector<double>& params_r__,\n                     std::vector<int>& params_i__,\n                     std::vector<double>& vars__,\n                     bool include_tparams__ = true,\n                     bool include_gqs__ = true,\n                     std::ostream* pstream__ = 0) const {\n        typedef double local_scalar_t__;\n\n        vars__.resize(0);\n        stan::io::reader<local_scalar_t__> in__(params_r__,params_i__);\n        static const char* function__ = \"model6a8014f03f76c_stan_DM_ME_namespace::write_array\";\n        (void) function__;  // dummy to suppress unused var warning\n        // read-transform, write parameters\n        matrix_d beta = in__.matrix_constrain(p,(d - 1));\n        vector_d u = in__.vector_constrain(n);\n        double var_u = in__.scalar_lb_constrain(0);\n        vector<double> overdispersion_scalar;\n        size_t dim_overdispersion_scalar_0__ = 2;\n        for (size_t k_0__ = 0; k_0__ < dim_overdispersion_scalar_0__; ++k_0__) {\n            overdispersion_scalar.push_back(in__.scalar_lb_constrain(0));\n        }\n            for (int k_1__ = 0; k_1__ < (d - 1); ++k_1__) {\n                for (int k_0__ = 0; k_0__ < p; ++k_0__) {\n                vars__.push_back(beta(k_0__, k_1__));\n                }\n            }\n            for (int k_0__ = 0; k_0__ < n; ++k_0__) {\n            vars__.push_back(u[k_0__]);\n            }\n        vars__.push_back(var_u);\n            for (int k_0__ = 0; k_0__ < 2; ++k_0__) {\n            vars__.push_back(overdispersion_scalar[k_0__]);\n            }\n\n        // declare and define transformed parameters\n        double lp__ = 0.0;\n        (void) lp__;  // dummy to suppress unused var warning\n        stan::math::accumulator<double> lp_accum__;\n\n        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());\n        (void) DUMMY_VAR__;  // suppress unused var warning\n\n        try {\n            current_statement_begin__ = 27;\n            validate_non_negative_index(\"alpha_mean\", \"(2 * n)\", (2 * n));\n            validate_non_negative_index(\"alpha_mean\", \"d\", d);\n            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  alpha_mean(static_cast<Eigen::VectorXd::Index>((2 * n)),static_cast<Eigen::VectorXd::Index>(d));\n            (void) alpha_mean;  // dummy to suppress unused var warning\n\n            stan::math::initialize(alpha_mean, DUMMY_VAR__);\n            stan::math::fill(alpha_mean,DUMMY_VAR__);\n            current_statement_begin__ = 28;\n            validate_non_negative_index(\"alpha\", \"(2 * n)\", (2 * n));\n            validate_non_negative_index(\"alpha\", \"d\", d);\n            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  alpha(static_cast<Eigen::VectorXd::Index>((2 * n)),static_cast<Eigen::VectorXd::Index>(d));\n            (void) alpha;  // dummy to suppress unused var warning\n\n            stan::math::initialize(alpha, DUMMY_VAR__);\n            stan::math::fill(alpha,DUMMY_VAR__);\n            current_statement_begin__ = 29;\n            validate_non_negative_index(\"overdispersion_scalars\", \"(2 * n)\", (2 * n));\n            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  overdispersion_scalars(static_cast<Eigen::VectorXd::Index>((2 * n)));\n            (void) overdispersion_scalars;  // dummy to suppress unused var warning\n\n            stan::math::initialize(overdispersion_scalars, DUMMY_VAR__);\n            stan::math::fill(overdispersion_scalars,DUMMY_VAR__);\n            stan::math::assign(overdispersion_scalars,append_row(rep_vector(get_base1(overdispersion_scalar,1,\"overdispersion_scalar\",1),n),rep_vector(get_base1(overdispersion_scalar,2,\"overdispersion_scalar\",1),n)));\n\n\n            current_statement_begin__ = 31;\n            stan::math::assign(alpha_mean, append_col(add(multiply(transpose(x),beta),multiply(transpose(Z),rep_matrix(u,(d - 1)))),rep_vector(0,(2 * n))));\n            current_statement_begin__ = 32;\n            for (int l = 1; l <= (2 * n); ++l) {\n\n                current_statement_begin__ = 33;\n                stan::model::assign(alpha, \n                            stan::model::cons_list(stan::model::index_uni(l), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), \n                            multiply(to_row_vector(softmax(to_vector(stan::model::rvalue(alpha_mean, stan::model::cons_list(stan::model::index_uni(l), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), \"alpha_mean\")))),get_base1(overdispersion_scalars,l,\"overdispersion_scalars\",1)), \n                            \"assigning variable alpha\");\n            }\n\n            // validate transformed parameters\n            current_statement_begin__ = 27;\n            current_statement_begin__ = 28;\n            check_greater_or_equal(function__,\"alpha\",alpha,0);\n            current_statement_begin__ = 29;\n            check_greater_or_equal(function__,\"overdispersion_scalars\",overdispersion_scalars,0);\n\n            // write transformed parameters\n            if (include_tparams__) {\n            for (int k_1__ = 0; k_1__ < d; ++k_1__) {\n                for (int k_0__ = 0; k_0__ < (2 * n); ++k_0__) {\n                vars__.push_back(alpha_mean(k_0__, k_1__));\n                }\n            }\n            for (int k_1__ = 0; k_1__ < d; ++k_1__) {\n                for (int k_0__ = 0; k_0__ < (2 * n); ++k_0__) {\n                vars__.push_back(alpha(k_0__, k_1__));\n                }\n            }\n            for (int k_0__ = 0; k_0__ < (2 * n); ++k_0__) {\n            vars__.push_back(overdispersion_scalars[k_0__]);\n            }\n            }\n            if (!include_gqs__) return;\n            // declare and define generated quantities\n\n\n\n            // validate generated quantities\n\n            // write generated quantities\n        } catch (const std::exception& e) {\n            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());\n            // Next line prevents compiler griping about no return\n            throw std::runtime_error(\"*** IF YOU SEE THIS, PLEASE REPORT A BUG ***\");\n        }\n    }\n\n    template <typename RNG>\n    void write_array(RNG& base_rng,\n                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,\n                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,\n                     bool include_tparams = true,\n                     bool include_gqs = true,\n                     std::ostream* pstream = 0) const {\n      std::vector<double> params_r_vec(params_r.size());\n      for (int i = 0; i < params_r.size(); ++i)\n        params_r_vec[i] = params_r(i);\n      std::vector<double> vars_vec;\n      std::vector<int> params_i_vec;\n      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);\n      vars.resize(vars_vec.size());\n      for (int i = 0; i < vars.size(); ++i)\n        vars(i) = vars_vec[i];\n    }\n\n    static std::string model_name() {\n        return \"model6a8014f03f76c_stan_DM_ME\";\n    }\n\n\n    void constrained_param_names(std::vector<std::string>& param_names__,\n                                 bool include_tparams__ = true,\n                                 bool include_gqs__ = true) const {\n        std::stringstream param_name_stream__;\n        for (int k_1__ = 1; k_1__ <= (d - 1); ++k_1__) {\n            for (int k_0__ = 1; k_0__ <= p; ++k_0__) {\n                param_name_stream__.str(std::string());\n                param_name_stream__ << \"beta\" << '.' << k_0__ << '.' << k_1__;\n                param_names__.push_back(param_name_stream__.str());\n            }\n        }\n        for (int k_0__ = 1; k_0__ <= n; ++k_0__) {\n            param_name_stream__.str(std::string());\n            param_name_stream__ << \"u\" << '.' << k_0__;\n            param_names__.push_back(param_name_stream__.str());\n        }\n        param_name_stream__.str(std::string());\n        param_name_stream__ << \"var_u\";\n        param_names__.push_back(param_name_stream__.str());\n        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {\n            param_name_stream__.str(std::string());\n            param_name_stream__ << \"overdispersion_scalar\" << '.' << k_0__;\n            param_names__.push_back(param_name_stream__.str());\n        }\n\n        if (!include_gqs__ && !include_tparams__) return;\n\n        if (include_tparams__) {\n            for (int k_1__ = 1; k_1__ <= d; ++k_1__) {\n                for (int k_0__ = 1; k_0__ <= (2 * n); ++k_0__) {\n                    param_name_stream__.str(std::string());\n                    param_name_stream__ << \"alpha_mean\" << '.' << k_0__ << '.' << k_1__;\n                    param_names__.push_back(param_name_stream__.str());\n                }\n            }\n            for (int k_1__ = 1; k_1__ <= d; ++k_1__) {\n                for (int k_0__ = 1; k_0__ <= (2 * n); ++k_0__) {\n                    param_name_stream__.str(std::string());\n                    param_name_stream__ << \"alpha\" << '.' << k_0__ << '.' << k_1__;\n                    param_names__.push_back(param_name_stream__.str());\n                }\n            }\n            for (int k_0__ = 1; k_0__ <= (2 * n); ++k_0__) {\n                param_name_stream__.str(std::string());\n                param_name_stream__ << \"overdispersion_scalars\" << '.' << k_0__;\n                param_names__.push_back(param_name_stream__.str());\n            }\n        }\n\n\n        if (!include_gqs__) return;\n    }\n\n\n    void unconstrained_param_names(std::vector<std::string>& param_names__,\n                                   bool include_tparams__ = true,\n                                   bool include_gqs__ = true) const {\n        std::stringstream param_name_stream__;\n        for (int k_1__ = 1; k_1__ <= (d - 1); ++k_1__) {\n            for (int k_0__ = 1; k_0__ <= p; ++k_0__) {\n                param_name_stream__.str(std::string());\n                param_name_stream__ << \"beta\" << '.' << k_0__ << '.' << k_1__;\n                param_names__.push_back(param_name_stream__.str());\n            }\n        }\n        for (int k_0__ = 1; k_0__ <= n; ++k_0__) {\n            param_name_stream__.str(std::string());\n            param_name_stream__ << \"u\" << '.' << k_0__;\n            param_names__.push_back(param_name_stream__.str());\n        }\n        param_name_stream__.str(std::string());\n        param_name_stream__ << \"var_u\";\n        param_names__.push_back(param_name_stream__.str());\n        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {\n            param_name_stream__.str(std::string());\n            param_name_stream__ << \"overdispersion_scalar\" << '.' << k_0__;\n            param_names__.push_back(param_name_stream__.str());\n        }\n\n        if (!include_gqs__ && !include_tparams__) return;\n\n        if (include_tparams__) {\n            for (int k_1__ = 1; k_1__ <= d; ++k_1__) {\n                for (int k_0__ = 1; k_0__ <= (2 * n); ++k_0__) {\n                    param_name_stream__.str(std::string());\n                    param_name_stream__ << \"alpha_mean\" << '.' << k_0__ << '.' << k_1__;\n                    param_names__.push_back(param_name_stream__.str());\n                }\n            }\n            for (int k_1__ = 1; k_1__ <= d; ++k_1__) {\n                for (int k_0__ = 1; k_0__ <= (2 * n); ++k_0__) {\n                    param_name_stream__.str(std::string());\n                    param_name_stream__ << \"alpha\" << '.' << k_0__ << '.' << k_1__;\n                    param_names__.push_back(param_name_stream__.str());\n                }\n            }\n            for (int k_0__ = 1; k_0__ <= (2 * n); ++k_0__) {\n                param_name_stream__.str(std::string());\n                param_name_stream__ << \"overdispersion_scalars\" << '.' << k_0__;\n                param_names__.push_back(param_name_stream__.str());\n            }\n        }\n\n\n        if (!include_gqs__) return;\n    }\n\n}; // model\n\n}\n\ntypedef model6a8014f03f76c_stan_DM_ME_namespace::model6a8014f03f76c_stan_DM_ME stan_model;\n\n"

$model_name
[1] "stan_DM_ME"

$model_code
[1] "// Stan model for the dirichlet-multinomial\nfunctions {\n  real dirichlet_multinomial_lpmf(int[] y, vector alpha) {\n    real alpha_plus = sum(alpha);\n    return lgamma(alpha_plus) + sum(lgamma(alpha + to_vector(y)))\n    - lgamma(alpha_plus+sum(y)) - sum(lgamma(alpha));\n  }\n}\n\ndata {\n  int<lower=0> n; // number of samples. \\in N^1\n  int<lower=0> d; // number of signatures. \\in N^1\n  int w[2*n,d]; // number of mutations attributed to each signature. \\in N^{Ns,Nk}\n  int p; // number of covariates\n  matrix[p, 2*n] x; // covariate matrix\n  matrix[n, 2*n] Z; // matrix for random effects\n}\n\nparameters {\n  matrix[p,d-1] beta; // coefficients for fixed effects\n  vector[n] u; // coefficients for random effects\n  real<lower=0> var_u; // variance for random effect coefficients\n  real<lower=0> overdispersion_scalar[2]; // for the dirichlet\n}\n\ntransformed parameters {\n  matrix[2*n,d] alpha_mean;\n  matrix<lower=0>[2*n,d] alpha; \n  vector<lower=0>[2*n] overdispersion_scalars = append_row(rep_vector(overdispersion_scalar[1], n),rep_vector(overdispersion_scalar[2], n));\n  \n  alpha_mean = append_col( (x'*beta + Z'*rep_matrix(u, d-1)), rep_vector(0, 2*n));\n  for(l in 1:(2*n)){\n    alpha[l,] = to_row_vector(softmax(to_vector(alpha_mean[l,])))* overdispersion_scalars[l];\n  }\n}\n\nmodel {\n  \n  var_u ~ gamma(5, 5);\n\n  overdispersion_scalar ~ normal(1,1);\n  \n\n  for(d_it in 1:(d-1)){\n    beta[,d_it] ~ uniform(-5, 5);\n  }\n  \n// prior for random effects\n  to_vector(u) ~ normal(0, sqrt(var_u));\n  \n  for (l in 1:(2*n) ) {\n    w[l,] ~ dirichlet_multinomial(to_vector(alpha[l,]));\n  }\n}\n\n"
attr(,"model_name2")
[1] "stan_DM_ME"

[1] 32

SAMPLING FOR MODEL 'stan_DM_ME' NOW (CHAIN 2).

SAMPLING FOR MODEL 'stan_DM_ME' NOW (CHAIN 1).
Chain 2: 
Chain 2: Gradient evaluation took 0 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 1: 
Chain 1: Gradient evaluation took 0 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 2: Iteration:     1 / 15000 [  0%]  (Warmup)
Chain 1: Iteration:     1 / 15000 [  0%]  (Warmup)
Chain 2: Iteration:  1500 / 15000 [ 10%]  (Warmup)
Chain 1: Iteration:  1500 / 15000 [ 10%]  (Warmup)
Chain 2: Iteration:  3000 / 15000 [ 20%]  (Warmup)
Chain 1: Iteration:  3000 / 15000 [ 20%]  (Warmup)
Chain 2: Iteration:  4500 / 15000 [ 30%]  (Warmup)
Chain 1: Iteration:  4500 / 15000 [ 30%]  (Warmup)
Chain 2: Iteration:  6000 / 15000 [ 40%]  (Warmup)
Chain 1: Iteration:  6000 / 15000 [ 40%]  (Warmup)
Chain 2: Iteration:  7500 / 15000 [ 50%]  (Warmup)
Chain 2: Iteration:  7501 / 15000 [ 50%]  (Sampling)
Chain 1: Iteration:  7500 / 15000 [ 50%]  (Warmup)
Chain 1: Iteration:  7501 / 15000 [ 50%]  (Sampling)
Chain 2: Iteration:  9000 / 15000 [ 60%]  (Sampling)
Chain 1: Iteration:  9000 / 15000 [ 60%]  (Sampling)
Chain 2: Iteration: 10500 / 15000 [ 70%]  (Sampling)
Chain 1: Iteration: 10500 / 15000 [ 70%]  (Sampling)
Chain 2: Iteration: 12000 / 15000 [ 80%]  (Sampling)
Chain 1: Iteration: 12000 / 15000 [ 80%]  (Sampling)
Chain 2: Iteration: 13500 / 15000 [ 90%]  (Sampling)
Chain 1: Iteration: 13500 / 15000 [ 90%]  (Sampling)
Chain 2: Iteration: 15000 / 15000 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 104.76 seconds (Warm-up)
Chain 2:                92.63 seconds (Sampling)
Chain 2:                197.39 seconds (Total)
Chain 2: 

SAMPLING FOR MODEL 'stan_DM_ME' NOW (CHAIN 3).
Chain 3: 
Chain 3: Gradient evaluation took 0 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 3: Iteration:     1 / 15000 [  0%]  (Warmup)
Chain 1: Iteration: 15000 / 15000 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 106.36 seconds (Warm-up)
Chain 1:                93.56 seconds (Sampling)
Chain 1:                199.92 seconds (Total)
Chain 1: 

SAMPLING FOR MODEL 'stan_DM_ME' NOW (CHAIN 4).
Chain 4: 
Chain 4: Gradient evaluation took 0 seconds
Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 4: Adjust your expectations accordingly!
Chain 4: 
Chain 4: 
Chain 4: Iteration:     1 / 15000 [  0%]  (Warmup)
Chain 3: Iteration:  1500 / 15000 [ 10%]  (Warmup)
Chain 4: Iteration:  1500 / 15000 [ 10%]  (Warmup)
Chain 3: Iteration:  3000 / 15000 [ 20%]  (Warmup)
Chain 4: Iteration:  3000 / 15000 [ 20%]  (Warmup)
Chain 3: Iteration:  4500 / 15000 [ 30%]  (Warmup)
Chain 4: Iteration:  4500 / 15000 [ 30%]  (Warmup)
Chain 3: Iteration:  6000 / 15000 [ 40%]  (Warmup)
Chain 4: Iteration:  6000 / 15000 [ 40%]  (Warmup)
Chain 4: Iteration:  7500 / 15000 [ 50%]  (Warmup)
Chain 4: Iteration:  7501 / 15000 [ 50%]  (Sampling)
Chain 3: Iteration:  7500 / 15000 [ 50%]  (Warmup)
Chain 3: Iteration:  7501 / 15000 [ 50%]  (Sampling)
Chain 3: Iteration:  9000 / 15000 [ 60%]  (Sampling)
Chain 4: Iteration:  9000 / 15000 [ 60%]  (Sampling)
Chain 3: Iteration: 10500 / 15000 [ 70%]  (Sampling)
Chain 3: Iteration: 12000 / 15000 [ 80%]  (Sampling)
Chain 4: Iteration: 10500 / 15000 [ 70%]  (Sampling)
Chain 3: Iteration: 13500 / 15000 [ 90%]  (Sampling)
Chain 4: Iteration: 12000 / 15000 [ 80%]  (Sampling)
Chain 3: Iteration: 15000 / 15000 [100%]  (Sampling)
Chain 3: 
Chain 3:  Elapsed Time: 108.97 seconds (Warm-up)
Chain 3:                91.17 seconds (Sampling)
Chain 3:                200.14 seconds (Total)
Chain 3: 
Chain 4: Iteration: 13500 / 15000 [ 90%]  (Sampling)
Chain 4: Iteration: 15000 / 15000 [100%]  (Sampling)
Chain 4: 
Chain 4:  Elapsed Time: 105.86 seconds (Warm-up)
Chain 4:                138.47 seconds (Sampling)
Chain 4:                244.33 seconds (Total)
Chain 4: 
Warning messages:
1: There were 6403 divergent transitions after warmup. Increasing adapt_delta above 0.8 may help. See
http://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup 
2: Examine the pairs() plot to diagnose sampling problems
 
[Sun Aug  2 19:42:46 2020]
Finished job 0.
1 of 1 steps (100%) done
