#                                                         size = 1000,
#                                                         replace = FALSE )))
subset = sample(1:nrow(sim_counts), 1e3, replace = FALSE)
par(mfrow=c(1,1))
sim_counts_subset = sim_counts[subset,]
print(subset)
subset
cols = cols[subset]
## Moreover, we subset this further (I don't think this is necessary)
# sim_counts_subset = sim_counts[subset,]
# print(subset)
# cols = cols[subset]
# print(cols)
prcomp_all = prcomp(na.omit(sim_counts), scale. = FALSE, center=TRUE)
prcomp_res = prcomp_all$x[,c(1,2)]
projected_observed = (scale(normalise_rw(do.call('rbind', ROO_object)),
center = TRUE, scale = FALSE) %*% prcomp_all$rotation)[,1:2]
#########################################################################################################
############### Lower-dimensional representation of posteriors and of observed values [2] ###############
#########################################################################################################
## This time I am sampling from the model (coefficients beta, u) instead of from the posteriors of theta
## or alpha themselves
list_for_model = lapply(model, function(name_model){
if(bool_data_avilable[name_model]){
npatients = dim(posteriors_all[[name_model]]$u)[2]
npatientsx2 = npatients*2
patient_idx = 1
if(name_model == 'DM'){
## For each model, patient and group, simulate data
nfeatures = dim(posteriors_all[[name_model]]$beta)[3]
sample_posterior_idxs = sample(1: dim(posteriors_all[[name_model]]$beta)[1], 1e3)
## We sample from the posterior several times. The posterior indices that we use are <sample_posterior_idx>.
## We only sample some individuals at each run of the posteriors. The selected individuals are stored in <sample_subset_idxs>
give_theta = function(sample_posterior_idx){
sample_subset_idxs = sample(1: dim(covariates[[name_model]]$X)[2], 10)
alpha = softmax_mat(cbind(t(covariates[[name_model]]$X)[sample_subset_idxs,] %*% posteriors_all[[name_model]]$beta[sample_posterior_idx,,] +
do.call('cbind', replicate(nfeatures, t(covariates[[name_model]]$Z)[sample_subset_idxs,] %*% posteriors_all[[name_model]]$u[sample_posterior_idx,],
simplify = FALSE)),
rep(0, length(sample_subset_idxs))) * do.call('cbind', replicate(nfeatures+1, posteriors_all[[name_model]]$overdispersion_scalars[sample_posterior_idx,sample_subset_idxs], simplify = FALSE)))
theta = t(apply(alpha, 1, MCMCpack::rdirichlet, n=1))
list(theta, sample_subset_idxs)
}
give_theta_res = lapply(sample_posterior_idxs, give_theta)
theta_list = lapply(give_theta_res, function(i) i[[1]])
individuals_list = lapply(give_theta_res, function(i) i[[2]])
}else if(name_model == 'M'){
nfeatures = dim(posteriors_all[[name_model]]$beta)[3]
## We sample from the posterior several times. The posterior indices that we use are <sample_posterior_idx>.
## We only sample some individuals at each run of the posteriors. The selected individuals are stored in <sample_subset_idxs>
sample_posterior_idxs = sample(1: dim(posteriors_all[[name_model]]$beta)[1], 1e3)
give_theta = function(sample_posterior_idx){
sample_subset_idxs = sample(1: dim(covariates[[name_model]]$X)[2], 10)
theta = softmax_mat(cbind(t(covariates[[name_model]]$X)[sample_subset_idxs,] %*% posteriors_all[[name_model]]$beta[sample_posterior_idx,,] +
do.call('cbind', replicate(nfeatures, t(covariates[[name_model]]$Z)[sample_subset_idxs,] %*% posteriors_all[[name_model]]$u[sample_posterior_idx,],
simplify = FALSE)),
rep(0, length(sample_subset_idxs))))
list(theta, sample_subset_idxs)
}
give_theta_res = lapply(sample_posterior_idxs, give_theta)
theta_list = lapply(give_theta_res, function(i) i[[1]])
individuals_list = lapply(give_theta_res, function(i) i[[2]])
}else{
stop('Not implemented yet')
}
cols = unlist(individuals_list) #rep(rep(sample_subset_idxs, length(sample_posterior_idxs)), ### need to change something here
print(cols)
# subset = unlist(lapply(unique(cols), function(i) sample(x = which(cols == i),
#                                                         size = 1000,
#                                                         replace = FALSE )))
sim_counts = lapply(1:length(theta_list), function(thetas_idx){
do.call('rbind', lapply(1:npatientsx2, function(patient_idx) normalise_cl(apply(theta_list[[thetas_idx]], 1, rmultinom, n=1, size=rowsums_toll[patient_idx]))))
})
sim_counts = do.call('rbind', sim_counts)
sim_counts = sim_counts[! (colSums(apply(sim_counts, 1, is.na)) > 0),]
# subset = unlist(lapply(unique(cols), function(i) sample(x = which(cols == i),
#                                                         size = 1000,
#                                                         replace = FALSE )))
subset = sample(1:nrow(sim_counts), 1e3, replace = FALSE)
par(mfrow=c(1,1))
## Moreover, we subset this further (I don't think this is necessary)
# sim_counts_subset = sim_counts[subset,]
# print(subset)
# cols = cols[subset]
# print(cols)
prcomp_all = prcomp(na.omit(sim_counts), scale. = FALSE, center=TRUE)
prcomp_res = prcomp_all$x[,c(1,2)]
projected_observed = (scale(normalise_rw(do.call('rbind', ROO_object)),
center = TRUE, scale = FALSE) %*% prcomp_all$rotation)[,1:2]
}else{
sim_counts = prcomp_all = prcomp_res = projected_observed = cols = npatientsx2 = NA
}
return(list(sim_counts=sim_counts, prcomp_all=prcomp_all, prcomp_res=prcomp_res,
projected_observed=projected_observed,
cols=cols,
npatientsx2=npatientsx2))
})
sim_counts = lapply(list_for_model, function(i) i$sim_counts)
prcomp_all = lapply(list_for_model, function(i) i$prcomp_all)
prcomp_all = lapply(list_for_model, function(i) i$prcomp_all)
prcomp_res = lapply(list_for_model, function(i) i$prcomp_res)
projected_observed = lapply(list_for_model, function(i) i$projected_observed)
cols = lapply(list_for_model, function(i) i$cols)
npatientsx2 = lapply(list_for_model, function(i) i$npatientsx2)
npatientsx2 = as.numeric(na.omit(unlist(unique(npatientsx2))))
if(length(npatientsx2) != 1){stop('The number of patients seems to be different across patients. Stopping.\n')}
npatients = npatientsx2/2
names(sim_counts) = names(prcomp_all) = names(prcomp_all) = names(prcomp_res) = names(projected_observed) = model #names(cols) =
select_rows = function(df, colours){
if(is.na(colours)){ NA}else{lapply(unique(colours), function(i) df[colours == i,])}
}
## plotting the contours for all patients
splits_df = lapply(1:length(sim_counts), function(i) select_rows(sim_counts[[i]], cols[[i]]) )
names(splits_df) = model
names(splits_df)
splits_df
sapply(model, function(model_idx){
plot_whole_contour(group_idx = 1, model_name = model_idx, true_contour = FALSE)
plot_whole_contour(group_idx = 2, model_name = model_idx, true_contour = FALSE)
})
model
splits_df
splits_df$M
length(splits_df$M)
table(cols)
table(cols$`../data/inference/Kidney-RCC.papillary_signatures_20000_MROO.RData`)
splits_df$M[[1]]
rowSums(splits_df$M[[1]])
opt = list(); opt$files_posteriors =  c("../data/inference/Bladder-TCC_signatures_20000_DMROO.RData", "../data/inference/Bladder-TCC_signatures_20000_MROO.RData"  , "../data/inference/Bladder-TCC_signatures_20000_LNMROO.RData")
files_posterior_split = do.call('cbind', sapply(opt$files_posteriors, function(i) strsplit(i, "_")[[1]]))
sapply(opt$files_posteriors, function(i) strsplit(i, "_")[[1]])
if(length(opt$files_posteriors) == 1){
files_posterior_split = sapply(opt$files_posteriors, function(i) strsplit(i, "_")[[1]])
}else if(length(opt$files_posteriors) >= 2){
files_posterior_split = sapply(opt$files_posteriors, function(i) strsplit(i, "_")[[1]])
}else if(length(opt$files_posteriors) > 2){
files_posterior_split = do.call('cbind', sapply(opt$files_posteriors, function(i) strsplit(i, "_")[[1]]))
}
files_posterior_split
rm(list = ls())
library(optparse)
library(rstan)
library(ggplot2)
library(dplyr)
library(reshape2)
library(MCMCpack)
library(plyr)
library(CompSign)
library(scales)
library(optparse)
debug=FALSE
if(debug){
setwd("/Users/morril01/Documents/PhD/GlobalDA/code/")
opt = list(); opt$files_posteriors = c("../data/inference/Kidney-RCC.papillary_signatures_20000_MROO.RData", "../data/inference/Kidney-RCC.papillary_signatures_20000_DMROO.RData", "../data/inference/Kidney-RCC.papillary_signatures_20000_LNMROO.RData")
}else{
option_list = list(
make_option(c("--files_posteriors"), type="character", default=NA,
help="File with the posterior, with directory included", metavar="character")
);
opt_parser = OptionParser(option_list=option_list);
opt = parse_args(opt_parser);
opt$files_posteriors = strsplit(opt$files_posteriors, " ")[[1]]
print(opt$files_posteriors)
}
debug
debug=T
if(debug){
setwd("/Users/morril01/Documents/PhD/GlobalDA/code/")
opt = list(); opt$files_posteriors = c("../data/inference/Kidney-RCC.papillary_signatures_20000_MROO.RData", "../data/inference/Kidney-RCC.papillary_signatures_20000_DMROO.RData", "../data/inference/Kidney-RCC.papillary_signatures_20000_LNMROO.RData")
}else{
option_list = list(
make_option(c("--files_posteriors"), type="character", default=NA,
help="File with the posterior, with directory included", metavar="character")
);
opt_parser = OptionParser(option_list=option_list);
opt = parse_args(opt_parser);
opt$files_posteriors = strsplit(opt$files_posteriors, " ")[[1]]
print(opt$files_posteriors)
}
cat('Arguments read')
print(opt$files_posteriors)
source("3_analysis/helper/helper_analyse_posteriors.R")
source("3_analysis/helper/helper_simulation.R")
source("2_inference/helper/helper_DA_stan.R")
if(length(opt$files_posteriors) == 1){
files_posterior_split = sapply(opt$files_posteriors, function(i) strsplit(i, "_")[[1]])
}else if(length(opt$files_posteriors) >= 2){
files_posterior_split = sapply(opt$files_posteriors, function(i) strsplit(i, "_")[[1]])
}else if(length(opt$files_posteriors) > 2){
files_posterior_split = do.call('cbind', sapply(opt$files_posteriors, function(i) strsplit(i, "_")[[1]]))
}
print(files_posterior_split)
ct = unique(basename(files_posterior_split[1,]))
type_feature = unique(files_posterior_split[2,])
nits =  as.numeric(files_posterior_split[3,])
model = gsub("ROO.RData", "",files_posterior_split[4,])
names(nits) = model
donors = read.table("../data/restricted/pcawg/icgc-dataset-1591612699408/donor.tsv",
stringsAsFactors = FALSE, sep = "\t", header = TRUE)
files_donors = read.table("../data/restricted/pcawg/repository_1567600367.tsv",
stringsAsFactors = FALSE, sep = "\t", header = TRUE)
give_roo_wrapper = function(.it_features, .list_CT){
it_features = .it_features
list_CT = .list_CT
source("3_analysis/helper/load_ROO.R", local = TRUE)
return(objects_sigs_per_CT[[it_features]][[list_CT]])
}
ROO_object = give_roo_wrapper(type_feature, ct)
## Load (1) the posteriors and (2) the covariate matrix Z and the random effect matrix Z
posteriors_and_covariates = lapply(opt$files_posteriors,
function(f){
if(substr(f, nchar(f), nchar(f)) == "/" | basename(f) == "NA" ){
# no file
list(NA, NA)
}else{
print(f)
load(f)
fit = tryCatch(rstan::extract(fit_stan))
if(is.null(fit)){
## no samples
list(NA, NA)
}else{
list(fit, list(X=X, Z=Z))
}
}
})
#########################################################
################### Work in progress ####################
#########################################################
## Comparison of simulated results from the inferred parameters, for D-M vs simpler Multinomial
rm(list = ls())
library(optparse)
library(rstan)
library(ggplot2)
library(dplyr)
library(reshape2)
library(MCMCpack)
library(plyr)
library(CompSign)
library(scales)
library(optparse)
debug = FALSE
if(debug){
setwd("/Users/morril01/Documents/PhD/GlobalDA/code/")
opt = list(); opt$files_posteriors = c("../data/inference/Kidney-RCC.papillary_signatures_20000_MROO.RData", "../data/inference/Kidney-RCC.papillary_signatures_20000_DMROO.RData", "../data/inference/Kidney-RCC.papillary_signatures_20000_LNMROO.RData")
}else{
option_list = list(
make_option(c("--files_posteriors"), type="character", default=NA,
help="File with the posterior, with directory included", metavar="character")
);
opt_parser = OptionParser(option_list=option_list);
opt = parse_args(opt_parser);
opt$files_posteriors = strsplit(opt$files_posteriors, " ")[[1]]
print(opt$files_posteriors)
}
cat('Arguments read')
print(opt$files_posteriors)
source("3_analysis/helper/helper_analyse_posteriors.R")
source("3_analysis/helper/helper_simulation.R")
source("2_inference/helper/helper_DA_stan.R")
if(length(opt$files_posteriors) == 1){
files_posterior_split = sapply(opt$files_posteriors, function(i) strsplit(i, "_")[[1]])
}else if(length(opt$files_posteriors) >= 2){
files_posterior_split = sapply(opt$files_posteriors, function(i) strsplit(i, "_")[[1]])
}else if(length(opt$files_posteriors) > 2){
files_posterior_split = do.call('cbind', sapply(opt$files_posteriors, function(i) strsplit(i, "_")[[1]]))
}
print(files_posterior_split)
ct = unique(basename(files_posterior_split[1,]))
type_feature = unique(files_posterior_split[2,])
nits =  as.numeric(files_posterior_split[3,])
model = gsub("ROO.RData", "",files_posterior_split[4,])
names(nits) = model
donors = read.table("../data/restricted/pcawg/icgc-dataset-1591612699408/donor.tsv",
stringsAsFactors = FALSE, sep = "\t", header = TRUE)
files_donors = read.table("../data/restricted/pcawg/repository_1567600367.tsv",
stringsAsFactors = FALSE, sep = "\t", header = TRUE)
give_roo_wrapper = function(.it_features, .list_CT){
it_features = .it_features
list_CT = .list_CT
source("3_analysis/helper/load_ROO.R", local = TRUE)
return(objects_sigs_per_CT[[it_features]][[list_CT]])
}
ROO_object = give_roo_wrapper(type_feature, ct)
## Load (1) the posteriors and (2) the covariate matrix Z and the random effect matrix Z
posteriors_and_covariates = lapply(opt$files_posteriors,
function(f){
if(substr(f, nchar(f), nchar(f)) == "/" | basename(f) == "NA" ){
# no file
list(NA, NA)
}else{
print(f)
load(f)
fit = tryCatch(rstan::extract(fit_stan))
if(is.null(fit)){
## no samples
list(NA, NA)
}else{
list(fit, list(X=X, Z=Z))
}
}
})
rm(list = ls())
library(optparse)
library(rstan)
library(ggplot2)
library(dplyr)
library(reshape2)
library(MCMCpack)
library(plyr)
library(CompSign)
library(scales)
library(optparse)
debug=T
if(debug){
setwd("/Users/morril01/Documents/PhD/GlobalDA/code/")
opt = list(); opt$files_posteriors = c("../data/inference/Kidney-RCC.papillary_signatures_20000_MROO.RData", "../data/inference/Kidney-RCC.papillary_signatures_20000_DMROO.RData", "../data/inference/Kidney-RCC.papillary_signatures_20000_LNMROO.RData")
}else{
option_list = list(
make_option(c("--files_posteriors"), type="character", default=NA,
help="File with the posterior, with directory included", metavar="character")
);
opt_parser = OptionParser(option_list=option_list);
opt = parse_args(opt_parser);
opt$files_posteriors = strsplit(opt$files_posteriors, " ")[[1]]
print(opt$files_posteriors)
}
cat('Arguments read')
print(opt$files_posteriors)
source("3_analysis/helper/helper_analyse_posteriors.R")
source("3_analysis/helper/helper_simulation.R")
source("2_inference/helper/helper_DA_stan.R")
if(length(opt$files_posteriors) == 1){
files_posterior_split = sapply(opt$files_posteriors, function(i) strsplit(i, "_")[[1]])
}else if(length(opt$files_posteriors) >= 2){
files_posterior_split = sapply(opt$files_posteriors, function(i) strsplit(i, "_")[[1]])
}else if(length(opt$files_posteriors) > 2){
files_posterior_split = do.call('cbind', sapply(opt$files_posteriors, function(i) strsplit(i, "_")[[1]]))
}
print(files_posterior_split)
ct = unique(basename(files_posterior_split[1,]))
type_feature = unique(files_posterior_split[2,])
nits =  as.numeric(files_posterior_split[3,])
model = gsub("ROO.RData", "",files_posterior_split[4,])
names(nits) = model
donors = read.table("../data/restricted/pcawg/icgc-dataset-1591612699408/donor.tsv",
stringsAsFactors = FALSE, sep = "\t", header = TRUE)
files_donors = read.table("../data/restricted/pcawg/repository_1567600367.tsv",
stringsAsFactors = FALSE, sep = "\t", header = TRUE)
give_roo_wrapper = function(.it_features, .list_CT){
it_features = .it_features
list_CT = .list_CT
source("3_analysis/helper/load_ROO.R", local = TRUE)
return(objects_sigs_per_CT[[it_features]][[list_CT]])
}
ROO_object = give_roo_wrapper(type_feature, ct)
## Load (1) the posteriors and (2) the covariate matrix Z and the random effect matrix Z
posteriors_and_covariates = lapply(opt$files_posteriors,
function(f){
if(substr(f, nchar(f), nchar(f)) == "/" | basename(f) == "NA" ){
# no file
list(NA, NA)
}else{
print(f)
load(f)
fit = tryCatch(rstan::extract(fit_stan))
if(is.null(fit)){
## no samples
list(NA, NA)
}else{
list(fit, list(X=X, Z=Z))
}
}
})
posteriors = lapply(posteriors_and_covariates, function(i) i[[1]])
covariates = lapply(posteriors_and_covariates, function(i) i[[2]])
names(posteriors) = names(covariates) = model
## Simulate with the total number of mutations for DM
rowsums_toll = unlist(lapply(ROO_object, rowSums))
length(rowsums_toll) ## number of patients*2
bool_data_avilable = rep(TRUE, length(posteriors))
for(i in 1:length(posteriors)){
if(is.null(posteriors[[i]])){
## either no samples in rstan object, or no file
bool_data_avilable[i] = FALSE
}else if(length(posteriors[[i]]) == 1){
if(is.na(posteriors[[i]])){ bool_data_avilable[i] = FALSE }
}
}
names(bool_data_avilable) = model
## since not all have been run for the same number of iterations, subset the posteriors
lengths_beta_all = sapply(posteriors, function(i) if(length(i) == 1){if(is.na(i)){NA}} else{dim(i$beta)[3]})
## <posteriors_all> contains all posteriors. Whenever a posterior is not available we get an NA
## On the other hand, <posteriors > only contains valid posteriors
posteriors_all = posteriors
posteriors = posteriors[!is.na(lengths_beta_all)]
lengths_beta = lengths_beta_all[!is.na(lengths_beta_all)]
## if there are no posteriors to analyse, quit
if(length(lengths_beta) == 0){ quit() }
## if we are comparing models, we need at least two
if(length(lengths_beta) == 1){bool_comparison=FALSE}else{bool_comparison=TRUE}
####################################################################################################
##################################### Comparison of beta values ####################################
####################################################################################################
if(bool_comparison){
dim_beta = unique(lengths_beta); stopifnot(length(dim_beta) == 1)
selected_rows = lapply(posteriors, function(i) sample(dim(i$beta)[1], 1000, replace = FALSE))
selected_rows_all = rep(NA, length(posteriors_all)); selected_rows_all[!is.na(lengths_beta_all)] = selected_rows
posteriors_subset_beta = lapply(1:length(posteriors), function(idx_posterior) do.call('rbind', lapply(1:dim_beta, function(idx_feature) select_feature(df_with_slices = posteriors[[idx_posterior]]$beta, idx_select = idx_feature)[selected_rows[[idx_posterior]],])))
posteriors_subset_beta_all = rep(NA, length(posteriors_all)); posteriors_subset_beta_all[!is.na(lengths_beta_all)] = posteriors_subset_beta
posteriors_subset_beta_intercept = do.call('cbind', lapply(posteriors_subset_beta_all, function(i){if(is.na(i)){NA}else{i[,1]}}))
posteriors_subset_beta_slope = do.call('cbind', lapply(posteriors_subset_beta_all, function(i){if(is.na(i)){NA}else{i[,2]}}))
colnames(posteriors_subset_beta_intercept) = colnames(posteriors_subset_beta_slope) = model
pdf(paste0('../results/comparison_models/beta_pairs_', ct, '_', type_feature, '.pdf'))
if(sum(!(apply(posteriors_subset_beta_intercept, 2, function(i) all(is.na(i))))) == 1){
plot(0, 0, main='Only one model - no comparison')
}else{
par(mfrow=c(2,1))
pairs(posteriors_subset_beta_intercept, main='Beta intercept pairs plot')
pairs(posteriors_subset_beta_slope, main='Beta slope pairs plot')
}
dev.off()
}
name_model='LNM'
npatients = dim(posteriors_all[[name_model]]$u)[2]
npatientsx2 = npatients*2
patient_idx = 1
name_model
nfeatures = dim(posteriors_all[[name_model]]$beta)[3]
nfeatures
## We sample from the posterior several times. The posterior indices that we use are <sample_posterior_idx>.
## We only sample some individuals at each run of the posteriors. The selected individuals are stored in <sample_subset_idxs>
sample_posterior_idxs = sample(1: dim(posteriors_all[[name_model]]$beta)[1], 1e3)
sample_posterior_idxs
sample_posterior_idxs = sample(1: dim(posteriors_all[[name_model]]$beta)[1], 1e3)
sample_posterior_idxs
sample_posterior_idx=sample_posterior_idxs[1]
sample_subset_idxs = sample(1: dim(covariates[[name_model]]$X)[2], 10)
sample_subset_idxs
theta = softmax_mat(cbind(t(covariates[[name_model]]$X)[sample_subset_idxs,] %*% posteriors_all[[name_model]]$beta[sample_posterior_idx,,] +
do.call('cbind', replicate(nfeatures, t(covariates[[name_model]]$Z)[sample_subset_idxs,] %*% posteriors_all[[name_model]]$u[sample_posterior_idx,],
simplify = FALSE)),
rep(0, length(sample_subset_idxs))))
mu = softmax_mat(cbind(t(covariates[[name_model]]$X)[sample_subset_idxs,] %*% posteriors_all[[name_model]]$beta[sample_posterior_idx,,] +
do.call('cbind', replicate(nfeatures, t(covariates[[name_model]]$Z)[sample_subset_idxs,] %*% posteriors_all[[name_model]]$u[sample_posterior_idx,],
simplify = FALSE)),
rep(0, length(sample_subset_idxs))))
mu
t(covariates[[name_model]]$X)[sample_subset_idxs,] %*% posteriors_all[[name_model]]$beta[sample_posterior_idx,,]
mu = t(covariates[[name_model]]$X)[sample_subset_idxs,] %*% posteriors_all[[name_model]]$beta[sample_posterior_idx,,] +
do.call('cbind', replicate(nfeatures, t(covariates[[name_model]]$Z)[sample_subset_idxs,] %*% posteriors_all[[name_model]]$u[sample_posterior_idx,],
simplify = FALSE))
mu
dim(mu)
posteriors_all[[name_model]]$Sigma
dim(posteriors_all[[name_model]])
dim(posteriors_all[[name_model]]$Sigma)
posteriors_all[[name_model]]$Sigma[,,1]
posteriors_all[[name_model]]$Sigma[,,1]
dim(posteriors_all[[name_model]]$Sigma[,,1])
dim(posteriors_all[[name_model]]$Sigma[1,,])
posteriors_all[[name_model]]$Sigma[1,,]
posteriors_all[[name_model]]$Sigma[sample_posterior_idx,,]
v = apply(mu, mvrnorm, n = 1, Sigma = posteriors_all[[name_model]]$Sigma[sample_posterior_idx,,])
mu
v = apply(mu, 1, mvrnorm, n = 1, Sigma = posteriors_all[[name_model]]$Sigma[sample_posterior_idx,,])
v
v = t(apply(mu, 1, mvrnorm, n = 1, Sigma = posteriors_all[[name_model]]$Sigma[sample_posterior_idx,,]))
v
sample_subset_idxs
length(sample_subset_idxs)
theta = softmax(cbind(v, rep(0, length(sample_subset_idxs)));
list(theta, sample_subset_idxs)
}
}else{
stop('Not implemented yet')
}
cols = unlist(individuals_list) #rep(rep(sample_subset_idxs, length(sample_posterior_idxs)), ### need to change something here
print(cols)
# subset = unlist(lapply(unique(cols), function(i) sample(x = which(cols == i),
#                                                         size = 1000,
#                                                         replace = FALSE )))
sim_counts = lapply(1:length(theta_list), function(thetas_idx){
do.call('rbind', lapply(1:npatientsx2, function(patient_idx) normalise_cl(apply(theta_list[[thetas_idx]], 1, rmultinom, n=1, size=rowsums_toll[patient_idx]))))
})
sim_counts = do.call('rbind', sim_counts)
sim_counts = sim_counts[! (colSums(apply(sim_counts, 1, is.na)) > 0),]
# subset = unlist(lapply(unique(cols), function(i) sample(x = which(cols == i),
#                                                         size = 1000,
#                                                         replace = FALSE )))
subset = sample(1:nrow(sim_counts), 1e3, replace = FALSE)
par(mfrow=c(1,1))
## Moreover, we subset this further (I don't think this is necessary)
# sim_counts_subset = sim_counts[subset,]
# print(subset)
# cols = cols[subset]
# print(cols)
prcomp_all = prcomp(na.omit(sim_counts), scale. = FALSE, center=TRUE)
prcomp_res = prcomp_all$x[,c(1,2)]
projected_observed = (scale(normalise_rw(do.call('rbind', ROO_object)),
center = TRUE, scale = FALSE) %*% prcomp_all$rotation)[,1:2]
}else{
sim_counts = prcomp_all = prcomp_res = projected_observed = cols = npatientsx2 = NA
}
return(list(sim_counts=sim_counts, prcomp_all=prcomp_all, prcomp_res=prcomp_res,
projected_observed=projected_observed,
cols=cols,
npatientsx2=npatientsx2))
})
theta = softmax(cbind(v, rep(0, length(sample_subset_idxs))));
theta
theta = softmax_mat(cbind(v, rep(0, length(sample_subset_idxs))));
theta
