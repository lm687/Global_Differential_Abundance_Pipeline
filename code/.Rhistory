## or alpha themselves
list_for_model = lapply(model, function(name_model){
if(bool_data_avilable[name_model]){
npatients = dim(posteriors_all[[name_model]]$u)[2]
npatientsx2 = npatients*2
patient_idx = 1
if(name_model == 'DM'){
## For each model, patient and group, simulate data
nfeatures = dim(posteriors_all[[name_model]]$beta)[3]
sample_posterior_idx = 1 ### actually should do this wit many more draws from the posterior, to get a good representation
alpha = softmax_mat(cbind(t(covariates[[name_model]]$X) %*% posteriors_all[[name_model]]$beta[sample_posterior_idx,,] + do.call('cbind', replicate(nfeatures, t(covariates[[name_model]]$Z) %*% posteriors_all[[name_model]]$u[sample_posterior_idx,], simplify = FALSE)),
rep(0, dim(covariates[[name_model]]$Z)[2]))) * do.call('cbind', replicate(nfeatures+1, posteriors_all[[name_model]]$overdispersion_scalars[sample_posterior_idx,], simplify = FALSE))
theta = t(apply(alpha, 1, MCMCpack::rdirichlet, n=1))
}if(name_model == 'M'){
nfeatures = dim(posteriors_all[[name_model]]$beta)[3]
sample_posterior_idx = 1 ### actually should do this wit many more draws from the posterior, to get a good representation
theta = softmax_mat(cbind(t(covariates[[name_model]]$X) %*% posteriors_all[[name_model]]$beta[sample_posterior_idx,,] + do.call('cbind', replicate(nfeatures, t(covariates[[name_model]]$Z) %*% posteriors_all[[name_model]]$u[sample_posterior_idx,], simplify = FALSE)),
rep(0, dim(covariates[[name_model]]$Z)[2])))
}else{
stop('Not implemented yet')
}
sim_counts = lapply(1:npatientsx2, function(patient_idx) normalise_cl(apply(theta, 1, rmultinom, n=1, size=rowsums_toll[patient_idx])))
sim_counts = do.call('rbind', sim_counts)
sim_counts = sim_counts[! (colSums(apply(sim_counts, 1, is.na)) > 0),]
par(mfrow=c(1,1))
cols = rep(1:npatientsx2, each=dim(sim_counts)[1]/npatientsx2)
# subset = unlist(lapply(unique(cols), function(i) sample(x = which(cols == i),
#                                                         size = 1000,#round(0.1*sum(cols == i)),
#                                                         replace = FALSE )))
# sim_counts = sim_counts[subset,]
# cols = cols[subset]
prcomp_all = prcomp(na.omit(sim_counts), scale. = FALSE, center=TRUE)
prcomp_res = prcomp_all$x[,c(1,2)]
projected_observed = (scale(normalise_rw(do.call('rbind', ROO_object)),
center = TRUE, scale = FALSE) %*% prcomp_all$rotation)[,1:2]
}else{
sim_counts = prcomp_all = prcomp_res = projected_observed = cols = npatientsx2 = NA
}
return(list(sim_counts=sim_counts, prcomp_all=prcomp_all, prcomp_res=prcomp_res, projected_observed=projected_observed, cols=cols, npatientsx2=npatientsx2))
})
#########################################################################################################
############### Lower-dimensional representation of posteriors and of observed values [2] ###############
#########################################################################################################
## This time I am sampling from the model (coefficients beta, u) instead of from the posteriors of theta
## or alpha themselves
list_for_model = lapply(model, function(name_model){
if(bool_data_avilable[name_model]){
npatients = dim(posteriors_all[[name_model]]$u)[2]
npatientsx2 = npatients*2
patient_idx = 1
if(name_model == 'DM'){
## For each model, patient and group, simulate data
nfeatures = dim(posteriors_all[[name_model]]$beta)[3]
sample_posterior_idx = 1 ### actually should do this wit many more draws from the posterior, to get a good representation
alpha = softmax_mat(cbind(t(covariates[[name_model]]$X) %*% posteriors_all[[name_model]]$beta[sample_posterior_idx,,] + do.call('cbind', replicate(nfeatures, t(covariates[[name_model]]$Z) %*% posteriors_all[[name_model]]$u[sample_posterior_idx,], simplify = FALSE)),
rep(0, dim(covariates[[name_model]]$Z)[2]))) * do.call('cbind', replicate(nfeatures+1, posteriors_all[[name_model]]$overdispersion_scalars[sample_posterior_idx,], simplify = FALSE))
theta = t(apply(alpha, 1, MCMCpack::rdirichlet, n=1))
}else if(name_model == 'M'){
nfeatures = dim(posteriors_all[[name_model]]$beta)[3]
sample_posterior_idx = 1 ### actually should do this wit many more draws from the posterior, to get a good representation
theta = softmax_mat(cbind(t(covariates[[name_model]]$X) %*% posteriors_all[[name_model]]$beta[sample_posterior_idx,,] + do.call('cbind', replicate(nfeatures, t(covariates[[name_model]]$Z) %*% posteriors_all[[name_model]]$u[sample_posterior_idx,], simplify = FALSE)),
rep(0, dim(covariates[[name_model]]$Z)[2])))
}else{
stop('Not implemented yet')
}
sim_counts = lapply(1:npatientsx2, function(patient_idx) normalise_cl(apply(theta, 1, rmultinom, n=1, size=rowsums_toll[patient_idx])))
sim_counts = do.call('rbind', sim_counts)
sim_counts = sim_counts[! (colSums(apply(sim_counts, 1, is.na)) > 0),]
par(mfrow=c(1,1))
cols = rep(1:npatientsx2, each=dim(sim_counts)[1]/npatientsx2)
# subset = unlist(lapply(unique(cols), function(i) sample(x = which(cols == i),
#                                                         size = 1000,#round(0.1*sum(cols == i)),
#                                                         replace = FALSE )))
# sim_counts = sim_counts[subset,]
# cols = cols[subset]
prcomp_all = prcomp(na.omit(sim_counts), scale. = FALSE, center=TRUE)
prcomp_res = prcomp_all$x[,c(1,2)]
projected_observed = (scale(normalise_rw(do.call('rbind', ROO_object)),
center = TRUE, scale = FALSE) %*% prcomp_all$rotation)[,1:2]
}else{
sim_counts = prcomp_all = prcomp_res = projected_observed = cols = npatientsx2 = NA
}
return(list(sim_counts=sim_counts, prcomp_all=prcomp_all, prcomp_res=prcomp_res, projected_observed=projected_observed, cols=cols, npatientsx2=npatientsx2))
})
list_for_model
sim_counts = lapply(list_for_model, function(i) i$sim_counts)
prcomp_all = lapply(list_for_model, function(i) i$prcomp_all)
prcomp_all = lapply(list_for_model, function(i) i$prcomp_all)
prcomp_res = lapply(list_for_model, function(i) i$prcomp_res)
projected_observed = lapply(list_for_model, function(i) i$projected_observed)
cols = lapply(list_for_model, function(i) i$cols)
npatientsx2 = lapply(list_for_model, function(i) i$npatientsx2)
npatientsx2 = as.numeric(na.omit(unlist(unique(npatientsx2))))
if(length(npatientsx2) != 1){stop('The number of patients seems to be different across patients. Stopping.\n')}
npatients = npatientsx2/2
names(sim_counts) = names(prcomp_all) = names(prcomp_all) = names(prcomp_res) = names(projected_observed) = names(cols) = model
select_rows = function(df, colours){
if(is.na(colours)){ NA}else{lapply(unique(colours), function(i) df[colours == i,])}
}
## plotting the contours for all patients
splits_df = lapply(1:length(sim_counts), function(i) select_rows(sim_counts[[i]], cols[[i]]) )
names(splits_df) = model
par(mfrow=c(length(model),2))
sapply(model, function(model_idx){
plot_whole_contour(group_idx = 1, model_name = model_idx, true_contour = FALSE)
plot_whole_contour(group_idx = 2, model_name = model_idx, true_contour = FALSE)
})
sapply(model, function(model_idx){
plot_whole_contour(group_idx = 1, model_name = model_idx, true_contour = FALSE)
plot_whole_contour(group_idx = 2, model_name = model_idx, true_contour = FALSE)
})
dim(posteriors_all[[name_model]]$beta)[1]
sample_posterior_idx = sample(1: dim(posteriors_all[[name_model]]$beta)[1], 1e4) ### actually should do this wit many more draws from the posterior, to get a good representation
sample_posterior_idx
give_theta = function(sample_posterior_idx){
alpha = softmax_mat(cbind(t(covariates[[name_model]]$X) %*% posteriors_all[[name_model]]$beta[sample_posterior_idx,,] + do.call('cbind', replicate(nfeatures, t(covariates[[name_model]]$Z) %*% posteriors_all[[name_model]]$u[sample_posterior_idx,], simplify = FALSE)),
rep(0, dim(covariates[[name_model]]$Z)[2]))) * do.call('cbind', replicate(nfeatures+1, posteriors_all[[name_model]]$overdispersion_scalars[sample_posterior_idx,], simplify = FALSE))
theta = t(apply(alpha, 1, MCMCpack::rdirichlet, n=1))
theta
}
xxxxxx = lapply(sample_posterior_idx. give_theta)
xxxxxx = lapply(sample_posterior_idx, give_theta)
sample_posterior_idx
give_theta = function(sample_posterior_idx){
cat(sample_posterior_idx)
alpha = softmax_mat(cbind(t(covariates[[name_model]]$X) %*% posteriors_all[[name_model]]$beta[sample_posterior_idx,,] + do.call('cbind', replicate(nfeatures, t(covariates[[name_model]]$Z) %*% posteriors_all[[name_model]]$u[sample_posterior_idx,], simplify = FALSE)),
rep(0, dim(covariates[[name_model]]$Z)[2]))) * do.call('cbind', replicate(nfeatures+1, posteriors_all[[name_model]]$overdispersion_scalars[sample_posterior_idx,], simplify = FALSE))
theta = t(apply(alpha, 1, MCMCpack::rdirichlet, n=1))
theta
}
xxxxxx = lapply(sample_posterior_idx, give_theta)
sample_posterior_idx=8528
posteriors_all[[name_model]]$beta[sample_posterior_idx,,]
posteriors_all[[name_model]]$u[sample_posterior_idx,]
posteriors_all[[name_model]]$overdispersion_scalars[sample_posterior_idx,]
name_model='DM'
npatients = dim(posteriors_all[[name_model]]$u)[2]
npatientsx2 = npatients*2
patient_idx = 1
give_theta = function(sample_posterior_idx){
cat(sample_posterior_idx)
alpha = softmax_mat(cbind(t(covariates[[name_model]]$X) %*% posteriors_all[[name_model]]$beta[sample_posterior_idx,,] + do.call('cbind', replicate(nfeatures, t(covariates[[name_model]]$Z) %*% posteriors_all[[name_model]]$u[sample_posterior_idx,], simplify = FALSE)),
rep(0, dim(covariates[[name_model]]$Z)[2]))) * do.call('cbind', replicate(nfeatures+1, posteriors_all[[name_model]]$overdispersion_scalars[sample_posterior_idx,], simplify = FALSE))
theta = t(apply(alpha, 1, MCMCpack::rdirichlet, n=1))
theta
}
xxxxxx = lapply(sample_posterior_idx, give_theta)
sample_posterior_idx
sample_posterior_idx = sample(1: dim(posteriors_all[[name_model]]$beta)[1], 1e4) ### actually should do this wit many more draws from the posterior, to get a good representation
sample_posterior_idx
sample_posterior_idxs = sample(1: dim(posteriors_all[[name_model]]$beta)[1], 1e4) ### actually should do this wit many more draws from the posterior, to get a good representation
give_theta = function(sample_posterior_idx){
alpha = softmax_mat(cbind(t(covariates[[name_model]]$X) %*% posteriors_all[[name_model]]$beta[sample_posterior_idx,,] + do.call('cbind', replicate(nfeatures, t(covariates[[name_model]]$Z) %*% posteriors_all[[name_model]]$u[sample_posterior_idx,], simplify = FALSE)),
rep(0, dim(covariates[[name_model]]$Z)[2]))) * do.call('cbind', replicate(nfeatures+1, posteriors_all[[name_model]]$overdispersion_scalars[sample_posterior_idx,], simplify = FALSE))
theta = t(apply(alpha, 1, MCMCpack::rdirichlet, n=1))
theta
}
xxxxxx = lapply(sample_posterior_idxs, give_theta)
xxxxxx
theta = do.call('rbind', lapply(sample_posterior_idxs, give_theta))
theta
dim(theta)
cols = rep(1:npatientsx2, each=dim(sim_counts)[1]/npatientsx2)
npatientsx2
cols = rep(1:npatientsx2, each=dim(theta)[1]/npatientsx2)
cols
subset = unlist(lapply(unique(cols), function(i) sample(x = which(cols == i),
size = 1000,
replace = FALSE )))
subset
theta
theta
rowSums(theta)
rm(theta)
theta_list = lapply(sample_posterior_idxs, give_theta))
theta_list = lapply(sample_posterior_idxs, give_theta)
theta_list
cols
theta
length(theta)
sapply(theta_list)
sapply(theta_list, dim)
sapply(theta_list, function(i) dim(i)[1])
sum(sapply(theta_list, function(i) dim(i)[1]))
cols = rep(1:npatientsx2, each=sum(sapply(theta_list, function(i) dim(i)[1]))/npatientsx2)
cols
sim_counts = lapply(1:length(theta_list), function(thetas_idx){
lapply(1:npatientsx2, function(patient_idx) normalise_cl(apply(theta_list[[thetas_idx]], 1, rmultinom, n=1, size=rowsums_toll[patient_idx])))
})
sim_counts = do.call('rbind', sim_counts)
sim_counts = sim_counts[! (colSums(apply(sim_counts, 1, is.na)) > 0),]
subset = unlist(lapply(unique(cols), function(i) sample(x = which(cols == i),
size = 1000,
replace = FALSE )))
sim_counts_subset = sim_counts[subset,]
dim(sim_counts_subset)
dim(sim_counts)
subset
max(subset)
# subset = unlist(lapply(unique(cols), function(i) sample(x = which(cols == i),
#                                                         size = 1000,
#                                                         replace = FALSE )))
subset = sample(1:nrow(sim_counts), 1e3, replace = FALSE)
sim_counts_subset = sim_counts[subset,]
# cols = cols[subset]
prcomp_all = prcomp(na.omit(sim_counts_subset), scale. = FALSE, center=TRUE)
sim_counts_subset
sim_counts
thetas_idx=1
lapply(1:npatientsx2, function(patient_idx) normalise_cl(apply(theta_list[[thetas_idx]], 1, rmultinom, n=1, size=rowsums_toll[patient_idx])))
sim_counts = lapply(1:length(theta_list), function(thetas_idx){
do.call('rbind', lapply(1:npatientsx2, function(patient_idx) normalise_cl(apply(theta_list[[thetas_idx]], 1, rmultinom, n=1, size=rowsums_toll[patient_idx]))))
})
sim_counts = do.call('rbind', sim_counts)
sim_counts = sim_counts[! (colSums(apply(sim_counts, 1, is.na)) > 0),]
par(mfrow=c(1,1))
cols = rep(1:npatientsx2, each=dim(sim_counts)[1]/npatientsx2)
subset = unlist(lapply(unique(cols), function(i) sample(x = which(cols == i),
size = 1000,#round(0.1*sum(cols == i)),
replace = FALSE )))
sim_counts = sim_counts[subset,]
# cols = cols[subset]
prcomp_all = prcomp(na.omit(sim_counts_subset), scale. = FALSE, center=TRUE)
sim_counts
sim_counts_subset = sim_counts
sim_counts
# cols = cols[subset]
prcomp_all = prcomp(na.omit(sim_counts_subset), scale. = FALSE, center=TRUE)
prcomp_res = prcomp_all$x[,c(1,2)]
projected_observed = (scale(normalise_rw(do.call('rbind', ROO_object)),
center = TRUE, scale = FALSE) %*% prcomp_all$rotation)[,1:2]
#########################################################################################################
############### Lower-dimensional representation of posteriors and of observed values [2] ###############
#########################################################################################################
## This time I am sampling from the model (coefficients beta, u) instead of from the posteriors of theta
## or alpha themselves
list_for_model = lapply(model, function(name_model){
if(bool_data_avilable[name_model]){
npatients = dim(posteriors_all[[name_model]]$u)[2]
npatientsx2 = npatients*2
patient_idx = 1
if(name_model == 'DM'){
## For each model, patient and group, simulate data
nfeatures = dim(posteriors_all[[name_model]]$beta)[3]
sample_posterior_idxs = sample(1: dim(posteriors_all[[name_model]]$beta)[1], 1e4) ### actually should do this wit many more draws from the posterior, to get a good representation
give_theta = function(sample_posterior_idx){
alpha = softmax_mat(cbind(t(covariates[[name_model]]$X) %*% posteriors_all[[name_model]]$beta[sample_posterior_idx,,] + do.call('cbind', replicate(nfeatures, t(covariates[[name_model]]$Z) %*% posteriors_all[[name_model]]$u[sample_posterior_idx,], simplify = FALSE)),
rep(0, dim(covariates[[name_model]]$Z)[2]))) * do.call('cbind', replicate(nfeatures+1, posteriors_all[[name_model]]$overdispersion_scalars[sample_posterior_idx,], simplify = FALSE))
theta = t(apply(alpha, 1, MCMCpack::rdirichlet, n=1))
theta
}
theta_list = lapply(sample_posterior_idxs, give_theta)
}else if(name_model == 'M'){
nfeatures = dim(posteriors_all[[name_model]]$beta)[3]
sample_posterior_idx = 1 ### actually should do this wit many more draws from the posterior, to get a good representation
theta = softmax_mat(cbind(t(covariates[[name_model]]$X) %*% posteriors_all[[name_model]]$beta[sample_posterior_idx,,] + do.call('cbind', replicate(nfeatures, t(covariates[[name_model]]$Z) %*% posteriors_all[[name_model]]$u[sample_posterior_idx,], simplify = FALSE)),
rep(0, dim(covariates[[name_model]]$Z)[2])))
}else{
stop('Not implemented yet')
}
# cols = rep(1:npatientsx2, each=sum(sapply(theta_list, function(i) dim(i)[1]))/npatientsx2)
# subset = unlist(lapply(unique(cols), function(i) sample(x = which(cols == i),
#                                                         size = 1000,
#                                                         replace = FALSE )))
sim_counts = lapply(1:length(theta_list), function(thetas_idx){
do.call('rbind', lapply(1:npatientsx2, function(patient_idx) normalise_cl(apply(theta_list[[thetas_idx]], 1, rmultinom, n=1, size=rowsums_toll[patient_idx]))))
})
sim_counts = do.call('rbind', sim_counts)
sim_counts = sim_counts[! (colSums(apply(sim_counts, 1, is.na)) > 0),]
# subset = unlist(lapply(unique(cols), function(i) sample(x = which(cols == i),
#                                                         size = 1000,
#                                                         replace = FALSE )))
subset = sample(1:nrow(sim_counts), 1e3, replace = FALSE)
par(mfrow=c(1,1))
sim_counts_subset = sim_counts[subset,]
# cols = cols[subset]
prcomp_all = prcomp(na.omit(sim_counts_subset), scale. = FALSE, center=TRUE)
prcomp_res = prcomp_all$x[,c(1,2)]
projected_observed = (scale(normalise_rw(do.call('rbind', ROO_object)),
center = TRUE, scale = FALSE) %*% prcomp_all$rotation)[,1:2]
}else{
sim_counts = prcomp_all = prcomp_res = projected_observed = cols = npatientsx2 = NA
}
return(list(sim_counts=sim_counts, prcomp_all=prcomp_all, prcomp_res=prcomp_res, projected_observed=projected_observed, cols=cols, npatientsx2=npatientsx2))
})
alpha
sample_posterior_idxs
rm(sample_posterior_idx)
sample_posterior_idxs = sample(1: dim(posteriors_all[[name_model]]$beta)[1], 1e4) ### actually should do this wit many more draws from the posterior, to get a good representation
# give_theta = function(sample_posterior_idx){
alpha = softmax_mat(cbind(t(covariates[[name_model]]$X) %*% posteriors_all[[name_model]]$beta[sample_posterior_idxs,,] + do.call('cbind', replicate(nfeatures, t(covariates[[name_model]]$Z) %*% posteriors_all[[name_model]]$u[sample_posterior_idxs,], simplify = FALSE)),
rep(0, dim(covariates[[name_model]]$Z)[2]))) * do.call('cbind', replicate(nfeatures+1, posteriors_all[[name_model]]$overdispersion_scalars[sample_posterior_idxs,], simplify = FALSE))
t(covariates[[name_model]]$X) %*% posteriors_all[[name_model]]$beta[sample_posterior_idxs,,]
dim(t(covariates[[name_model]]$X))
#########################################################
################### Work in progress ####################
#########################################################
## Comparison of simulated results from the inferred parameters, for D-M vs simpler Multinomial
rm(list = ls())
library(optparse)
library(rstan)
library(ggplot2)
library(dplyr)
library(reshape2)
library(MCMCpack)
library(plyr)
library(CompSign)
library(scales)
library(optparse)
debug = TRUE
if(debug){
setwd("/Users/morril01/Documents/PhD/GlobalDA/code/")
opt = list(); opt$files_posteriors = c("../data/inference/Kidney-RCC.papillary_signatures_20000_MROO.RData", "../data/inference/Kidney-RCC.papillary_signatures_20000_DMROO.RData")
}else{
option_list = list(
make_option(c("--files_posteriors"), type="character", default=NA,
help="File with the posterior, with directory included", metavar="character")
);
opt_parser = OptionParser(option_list=option_list);
opt = parse_args(opt_parser);
opt$files_posteriors = strsplit(opt$files_posteriors, " ")[[1]]
print(opt$files_posteriors)
}
cat('Arguments read')
print(opt$files_posteriors)
source("3_analysis/helper/helper_analyse_posteriors.R")
source("3_analysis/helper/helper_simulation.R")
source("2_inference/helper/helper_DA_stan.R")
if(length(opt$files_posteriors) == 1){
files_posterior_split = sapply(opt$files_posteriors, function(i) strsplit(i, "_")[[1]])
}else if(length(opt$files_posteriors) == 2){
files_posterior_split = sapply(opt$files_posteriors, function(i) strsplit(i, "_")[[1]])
}else if(length(opt$files_posteriors) > 2){
files_posterior_split = do.call('cbind', sapply(opt$files_posteriors, function(i) strsplit(i, "_")[[1]]))
}
print(files_posterior_split)
ct = unique(basename(files_posterior_split[1,]))
type_feature = unique(files_posterior_split[2,])
nits =  as.numeric(files_posterior_split[3,])
model = gsub("ROO.RData", "",files_posterior_split[4,])
names(nits) = model
donors = read.table("../data/restricted/pcawg/icgc-dataset-1591612699408/donor.tsv",
stringsAsFactors = FALSE, sep = "\t", header = TRUE)
files_donors = read.table("../data/restricted/pcawg/repository_1567600367.tsv",
stringsAsFactors = FALSE, sep = "\t", header = TRUE)
give_roo_wrapper = function(.it_features, .list_CT){
it_features = .it_features
list_CT = .list_CT
source("3_analysis/helper/load_ROO.R", local = TRUE)
return(objects_sigs_per_CT[[it_features]][[list_CT]])
}
ROO_object = give_roo_wrapper(type_feature, ct)
## Load (1) the posteriors and (2) the covariate matrix Z and the random effect matrix Z
posteriors_and_covariates = lapply(opt$files_posteriors,
function(f){
if(substr(f, nchar(f), nchar(f)) == "/" | basename(f) == "NA" ){
# no file
list(NA, NA)
}else{
print(f)
load(f)
fit = tryCatch(rstan::extract(fit_stan))
if(is.null(fit)){
## no samples
list(NA, NA)
}else{
list(fit, list(X=X, Z=Z))
}
}
})
posteriors = lapply(posteriors_and_covariates, function(i) i[[1]])
covariates = lapply(posteriors_and_covariates, function(i) i[[2]])
names(posteriors) = names(covariates) = model
## Simulate with the total number of mutations for DM
rowsums_toll = unlist(lapply(ROO_object, rowSums))
length(rowsums_toll) ## number of patients*2
bool_data_avilable = rep(TRUE, length(posteriors))
for(i in 1:length(posteriors)){
if(is.null(posteriors[[i]])){
## either no samples in rstan object, or no file
bool_data_avilable[i] = FALSE
}else if(length(posteriors[[i]]) == 1){
if(is.na(posteriors[[i]])){ bool_data_avilable[i] = FALSE }
}
}
names(bool_data_avilable) = model
## since not all have been run for the same number of iterations, subset the posteriors
lengths_beta_all = sapply(posteriors, function(i) if(length(i) == 1){if(is.na(i)){NA}} else{dim(i$beta)[3]})
## <posteriors_all> contains all posteriors. Whenever a posterior is not available we get an NA
## On the other hand, <posteriors > only contains valid posteriors
posteriors_all = posteriors
posteriors = posteriors[!is.na(lengths_beta_all)]
lengths_beta = lengths_beta_all[!is.na(lengths_beta_all)]
## if there are no posteriors to analyse, quit
if(length(lengths_beta) == 0){ quit() }
## if we are comparing models, we need at least two
if(length(lengths_beta) == 1){bool_comparison=FALSE}else{bool_comparison=TRUE}
####################################################################################################
##################################### Comparison of beta values ####################################
####################################################################################################
if(bool_comparison){
dim_beta = unique(lengths_beta); stopifnot(length(dim_beta) == 1)
selected_rows = lapply(posteriors, function(i) sample(dim(i$beta)[1], 1000, replace = FALSE))
selected_rows_all = rep(NA, length(posteriors_all)); selected_rows_all[!is.na(lengths_beta_all)] = selected_rows
posteriors_subset_beta = lapply(1:length(posteriors), function(idx_posterior) do.call('rbind', lapply(1:dim_beta, function(idx_feature) select_feature(df_with_slices = posteriors[[idx_posterior]]$beta, idx_select = idx_feature)[selected_rows[[idx_posterior]],])))
posteriors_subset_beta_all = rep(NA, length(posteriors_all)); posteriors_subset_beta_all[!is.na(lengths_beta_all)] = posteriors_subset_beta
posteriors_subset_beta_intercept = do.call('cbind', lapply(posteriors_subset_beta_all, function(i){if(is.na(i)){NA}else{i[,1]}}))
posteriors_subset_beta_slope = do.call('cbind', lapply(posteriors_subset_beta_all, function(i){if(is.na(i)){NA}else{i[,2]}}))
colnames(posteriors_subset_beta_intercept) = colnames(posteriors_subset_beta_slope) = model
pdf(paste0('../results/comparison_models/beta_pairs_', ct, '_', type_feature, '.pdf'))
if(sum(!(apply(posteriors_subset_beta_intercept, 2, function(i) all(is.na(i))))) == 1){
plot(0, 0, main='Only one model - no comparison')
}else{
par(mfrow=c(2,1))
pairs(posteriors_subset_beta_intercept, main='Beta intercept pairs plot')
pairs(posteriors_subset_beta_slope, main='Beta slope pairs plot')
}
dev.off()
}
####################################################################################################
############################### Correlation of age with random effects #############################
####################################################################################################
dim(posteriors[[1]]$u) ## [nits, n, d-1]
dim(posteriors[[1]]$beta) ### [nits, 2, d-1]
dim(ROO_object[[1]]) ## [n,d]
match_file = match(gsub("_active", "", rownames(ROO_object[[1]])),
sapply(files_donors$File.Name, function(i) strsplit(i, '[.]')[[1]][1]))
rownames(ROO_object[[1]])
files_donors[match_file,c('ICGC.Donor','File.Name') ]
age_donors = donors[match(files_donors[match_file,]$ICGC.Donor, donors$icgc_donor_id),]
age_donors = age_donors[!is.na(age_donors$icgc_donor_id),c('icgc_donor_id', 'donor_age_at_last_followup')]
nfeatures = dim(posteriors[[1]]$u)[3]
png(paste0("../results/link_clinical/age_u_", ct, '_', type_feature, '.png'),
width = 3*1.7, height = 3*length(posteriors)*1.7, units = "in", res = 300)
par(mfrow=c(length(posteriors),1))
for(idx_model in 1:length(posteriors)){
if(length(rep(age_donors$donor_age_at_last_followup, each=dim(posteriors[[idx_model]]$u)[1])) != length(as.vector(posteriors[[idx_model]]$u))){stop()}
plt_age = cbind(rep(age_donors$donor_age_at_last_followup, each=dim(posteriors[[idx_model]]$u)[1]),
as.vector(posteriors[[idx_model]]$u))
plt_age = plt_age[!is.na(plt_age[,1]),]
if(dim(plt_age)[1] > 0){
plt_age = plt_age[sample(1:nrow(plt_age), 2000),]
plot(plt_age)
}else{
plot(0,0)
}
}
dev.off()
#########################################################################################################
################# Lower-dimensional representation of posteriors and of observed values #################
#########################################################################################################
list_for_model = lapply(model, function(name_model){
if(bool_data_avilable[name_model]){
npatients = dim(posteriors_all[[name_model]]$u)[2]
npatientsx2 = npatients*2
patient_idx = 1
if(name_model == 'DM'){
sim_counts = lapply(1:npatientsx2, function(patient_idx) normalise_cl(apply(t(apply(do.call('cbind', select_person(posteriors_all[[name_model]]$alpha, patient_idx)),
1, MCMCpack::rdirichlet, n=1)),
1, rmultinom, n=1, size=rowsums_toll[patient_idx])))
}else{
sim_counts = lapply(1:npatientsx2, function(patient_idx) normalise_cl(apply(do.call('cbind', select_person(posteriors[[name_model]]$theta, patient_idx)),
1, rmultinom, n=1, size=rowsums_toll[patient_idx])))
}
sim_counts = do.call('rbind', sim_counts)
sim_counts = sim_counts[! (colSums(apply(sim_counts, 1, is.na)) > 0),]
par(mfrow=c(1,1))
cols = rep(1:npatientsx2, each=dim(sim_counts)[1]/npatientsx2)
subset = unlist(lapply(unique(cols), function(i) sample(x = which(cols == i),
size = 1000,#round(0.1*sum(cols == i)),
replace = FALSE )))
sim_counts = sim_counts[subset,]
cols = cols[subset]
prcomp_all = prcomp(na.omit(sim_counts), scale. = FALSE, center=TRUE)
prcomp_res = prcomp_all$x[,c(1,2)]
projected_observed = (scale(normalise_rw(do.call('rbind', ROO_object)),
center = TRUE, scale = FALSE) %*% prcomp_all$rotation)[,1:2]
}else{
sim_counts = prcomp_all = prcomp_res = projected_observed = cols = npatientsx2 = NA
}
return(list(sim_counts=sim_counts, prcomp_all=prcomp_all, prcomp_res=prcomp_res, projected_observed=projected_observed, cols=cols, npatientsx2=npatientsx2))
})
sim_counts = lapply(list_for_model, function(i) i$sim_counts)
prcomp_all = lapply(list_for_model, function(i) i$prcomp_all)
prcomp_all = lapply(list_for_model, function(i) i$prcomp_all)
prcomp_res = lapply(list_for_model, function(i) i$prcomp_res)
projected_observed = lapply(list_for_model, function(i) i$projected_observed)
cols = lapply(list_for_model, function(i) i$cols)
npatientsx2 = lapply(list_for_model, function(i) i$npatientsx2)
npatientsx2 = as.numeric(na.omit(unlist(unique(npatientsx2))))
if(length(npatientsx2) != 1){stop('The number of patients seems to be different across patients. Stopping.\n')}
npatients = npatientsx2/2
names(sim_counts) = names(prcomp_all) = names(prcomp_all) = names(prcomp_res) = names(projected_observed) = names(cols) = model
select_rows = function(df, colours){
if(is.na(colours)){ NA}else{lapply(unique(colours), function(i) df[colours == i,])}
}
## plotting the contours for all patients
splits_df = lapply(1:length(sim_counts), function(i) select_rows(sim_counts[[i]], cols[[i]]) )
names(splits_df) = model
png(paste0("../results/simulation_from_params/contourplots_", type_feature, "_", ct, ".png"))
par(mfrow=c(length(model),2))
sapply(model, function(model_idx){
plot_whole_contour(group_idx = 1, model_name = model_idx, true_contour = FALSE)
plot_whole_contour(group_idx = 2, model_name = model_idx, true_contour = FALSE)
})
# plot_whole_contour(group_idx = 1, model_name = 'DM', true_contour = FALSE)
# plot_whole_contour(group_idx = 2, model_name = 'DM', true_contour = FALSE)
# plot_whole_contour(group_idx = 1, model_name = 'M', true_contour = FALSE)
# plot_whole_contour(group_idx = 2, model_name = 'M', true_contour = FALSE)
# plot_whole_contour(group_idx = 1, model_name = 'LNM', true_contour = FALSE)
# plot_whole_contour(group_idx = 2, model_name = 'LNM', true_contour = FALSE)
dev.off()
