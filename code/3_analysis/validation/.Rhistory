no_emitted_values <- length(visible_data)
no_hidden_values <- nrow(transition_matrix)
beta_hat<-matrix(NA,no_emitted_values,no_hidden_values)
N<-length(visible_data)
beta_hat[N,]<-(1/c_n[N])
for (n in (N-1):1){
# beta_hat[n,]<-(1/c_n[n])* emission_matrix[,visible_data[n+1]]* beta_hat[n+1,] %*% transition_matrix
beta_hat[n,]<-(1/c_n[n])* emission_matrix[,visible_data[n+1]] %*% transition_matrix  * beta_hat[n+1,]
}
beta_hat
beta_hat[N,]
c_n[N]
#Log likelihood of GC sequence under the model in (1)
forward_algorithm_scaled<-function(visible_data,transition_matrix,emission_matrix,initial_distribution){
no_emitted_values <- length(visible_data)
no_hidden_values <- nrow(transition_matrix)
alpha <-matrix(NA,no_emitted_values,no_hidden_values)
c_0<-sum(initial_distribution*emission_matrix[,visible_data[1]])
alpha[1,]<-(1/c_0)*initial_distribution*emission_matrix[,visible_data[1]]
log_L<-list()
log_L<-append(log_L,log(c_0))
for (n in 2:(no_emitted_values)){
transitted<-alpha[(n-1),] %*% transition_matrix
c_n<-sum(transitted*emission_matrix[,visible_data[n]])
alpha[n,]<-(1/c_n)*transitted*emission_matrix[,visible_data[n]]
log_L<-append(log_L,log(c_n))
}
return(unlist(log_L))
}
## WHAT ARE THESE TWO VALUES? LOG-LIKELIHOOD IS NA?
c_n<-forward_algorithm_scaled(visible_data = emitted_sequences, transition_matrix = matrix(as.numeric(A),nrow=2),
emission_matrix = matrix(as.numeric(B),nrow=2), initial_distribution = as.numeric(mu_naught))
c_n
no_emitted_values <- length(visible_data)
no_hidden_values <- nrow(transition_matrix)
alpha <-matrix(NA,no_emitted_values,no_hidden_values)
c_0<-sum(initial_distribution*emission_matrix[,visible_data[1]])
alpha[1,]<-(1/c_0)*initial_distribution*emission_matrix[,visible_data[1]]
log_L<-list()
log_L<-append(log_L,log(c_0))
n=2
transitted<-alpha[(n-1),] %*% transition_matrix
c_n<-sum(transitted*emission_matrix[,visible_data[n]])
c_n
#Log likelihood of GC sequence under the model in (1)
forward_algorithm_scaled<-function(visible_data,transition_matrix,emission_matrix,initial_distribution){
no_emitted_values <- length(visible_data)
no_hidden_values <- nrow(transition_matrix)
alpha <-matrix(NA,no_emitted_values,no_hidden_values)
c_0<-sum(initial_distribution*emission_matrix[,visible_data[1]])
alpha[1,]<-(1/c_0)*initial_distribution*emission_matrix[,visible_data[1]]
log_L<-list()
log_L<-append(log_L,log(c_0))
for (n in 2:(no_emitted_values)){
transitted<-alpha[(n-1),] %*% transition_matrix
c_n<-sum(transitted*emission_matrix[,visible_data[n]])
alpha[n,]<-(1/c_n)*transitted*emission_matrix[,visible_data[n]]
log_L<-append(log_L,log(c_n))
}
return(unlist(log_L))
}
## WHAT ARE THESE TWO VALUES? LOG-LIKELIHOOD IS NA?
c_n<-forward_algorithm_scaled(visible_data = emitted_sequences, transition_matrix = matrix(as.numeric(A),nrow=2),
emission_matrix = matrix(as.numeric(B),nrow=2), initial_distribution = as.numeric(mu_naught))
log_likelihood<-sum(c_n)
c_n
#Log likelihood of GC sequence under the model in (1)
forward_algorithm_scaled<-function(visible_data,transition_matrix,emission_matrix,initial_distribution){
no_emitted_values <- length(visible_data)
no_hidden_values <- nrow(transition_matrix)
alpha <-matrix(NA,no_emitted_values,no_hidden_values)
c_0<-sum(initial_distribution*emission_matrix[,visible_data[1]])
alpha[1,]<-(1/c_0)*initial_distribution*emission_matrix[,visible_data[1]]
log_L<-list()
log_L<-append(log_L,log(c_0))
for (n in 2:(no_emitted_values)){
transitted<-alpha[(n-1),] %*% transition_matrix
c_n<-sum(transitted*emission_matrix[,visible_data[n]])
alpha[n,]<-(1/c_n)*transitted*emission_matrix[,visible_data[n]]
log_L<-append(log_L,log(c_n))
}
return(unlist(log_L))
}
## WHAT ARE THESE TWO VALUES? LOG-LIKELIHOOD IS NA?
c_n<-forward_algorithm_scaled(visible_data = emitted_sequences, transition_matrix = matrix(as.numeric(A),nrow=2),
emission_matrix = matrix(as.numeric(B),nrow=2), initial_distribution = as.numeric(mu_naught))
log_likelihood<-sum(c_n)
no_emitted_values <- length(visible_data)
no_hidden_values <- nrow(transition_matrix)
beta_hat<-matrix(NA,no_emitted_values,no_hidden_values)
c_n<-exp(c_n)
c_n
## WHAT ARE THESE TWO VALUES? LOG-LIKELIHOOD IS NA?
c_n<-forward_algorithm_scaled(visible_data = emitted_sequences, transition_matrix = matrix(as.numeric(A),nrow=2),
emission_matrix = matrix(as.numeric(B),nrow=2), initial_distribution = as.numeric(mu_naught))
log_likelihood<-sum(c_n)
c_n_arg <- c_n
no_emitted_values <- length(visible_data)
no_hidden_values <- nrow(transition_matrix)
beta_hat<-matrix(NA,no_emitted_values,no_hidden_values)
c_n_arg<-exp(c_n_arg)
c_n_arg
c_n
N<-length(visible_data)
beta_hat[N,]<-(1/c_n_arg[N])
for (n in (N-1):1){
# beta_hat[n,]<-(1/c_n[n])* emission_matrix[,visible_data[n+1]]* beta_hat[n+1,] %*% transition_matrix
beta_hat[n,]<-(1/c_n_arg[n])* emission_matrix[,visible_data[n+1]] %*% transition_matrix  * beta_hat[n+1,]
}
beta_hat
N
#initialization
mu_0<-c(0.5,0.5)
trans_mat<-matrix(rep(0.5,4),nrow=2)
emission_mat<-matrix(rep(0.2,10),nrow=2)
N<-length(emitted_sequences)
t=1
alpha_hat<-forward_algorithm_scaled2(emitted_sequences,trans_mat,emission_mat,mu_0)
c_n<-forward_algorithm_scaled(emitted_sequences,trans_mat,emission_mat,mu_0)
beta_hat<-backward_algorithm_scaled(emitted_sequences,hidden_values,emission_mat,trans_mat,c_n)
log_likelihood<-sum(c_n)
mu_0<-alpha_hat[1,] * trans_mat %*% emission_mat[,visible_data[1],drop=FALSE]*beta_hat[1,]
mu_0
alpha_hat<-forward_algorithm_scaled2(emitted_sequences,trans_mat,emission_mat,mu_0)
c_n<-forward_algorithm_scaled(emitted_sequences,trans_mat,emission_mat,mu_0)
beta_hat<-backward_algorithm_scaled(emitted_sequences,hidden_values,emission_mat,trans_mat,c_n)
log_likelihood<-sum(c_n)
mu_0<-alpha_hat[1,] * trans_mat %*% emission_mat[,visible_data[1],drop=FALSE]*beta_hat[1,]
A <- matrix(c(0.8,  0.2, 0.1, 0.9), ncol=2, byrow=T)
mu_naught = c(0.5,0.5)
B=matrix(c(0.2 , 0.5 , 0.2 , 0.1 , 0,
0 , 0.1 , 0.4 , 0.4 , 0.1), nrow=2, byrow=T)
S <- 1:2
V <- 1:5
#Setting the seed for consistency and number of values
set.seed(99)
L<-115
#sequences of hidden states
s1<-sample(S,size=1,replace=TRUE,prob=mu_naught)
hidden_values<-rep(NA,L)
temp<-hidden_values[1]<-s1
for (i in 2:L){
hidden_values[i]<-sample(S,size=1,replace=TRUE,prob=A[temp,])
temp<-hidden_values[i]
}
hidden_values
## Emitted values
#sequences of emitted states
emitted_values<-rep(NA,L)
for (i in 1:L){
emitted_values[i]<-sample(V,size=1,replace=TRUE,prob=B[hidden_values[i],])
}
emitted_values
plot(emitted_values, type='h')
## Plot the resulting sequences of hidden and emitted states on the same graph.
#plots sequences of hidden and emitted states on the same graph
#pdf("Graph1.pdf")
opar <- par(no.readonly = TRUE)
par(mar = c(4, 4.1, 4.8, 2.1))
plot(emitted_values,type="h",xlim=c(0,115),xlab="",xaxt="n",ylab="",col='blue',lwd=1.5)
lines(hidden_values,col='red',lwd=2,type = "h")
axis(1, at = seq(0, 115, by = 10))
axis(1, at = seq(0, 115, 5), labels = NA)
title(xlab = "Index",font.lab=2,mgp = c(2.5, 1, 0))    # Add x-axis text
title(ylab = "Sequence of state",font.lab=2,mgp = c(2.5, 1, 0))    # Add y-axis text
legend(x="top", inset=c(0, -0.3),
legend = c("emitted state","hidden state"),col=c("blue","red"),lwd=c(1.5,2),xpd=TRUE, horiz = TRUE)
#creates a csv file for 115 sequences
data<-data.frame(cbind(hidden_values,emitted_values))
forward_algorithm<-function(visible_data,transition_matrix,emission_matrix,initial_distribution){
no_emitted_values <- length(visible_data)
no_hidden_values <- nrow(transition_matrix)
alpha <-matrix(NA,no_emitted_values,no_hidden_values)
alpha[1,]<-initial_distribution*emission_matrix[,visible_data[1]]
for (i in 2:(no_emitted_values)){
transitted<-alpha[(i-1),] %*% transition_matrix
alpha[i,]<-transitted*emission_matrix[,visible_data[i]]
}
return(alpha)
}
# forward_algorithm(values$emitted_values,matrix(as.numeric(A),nrow=2),matrix(as.numeric(B),nrow=2),as.numeric(mu_naught))
forward_algorithm(emitted_values,A,B,mu_naught)
#Log likelihood of GC sequence under the model in (1)
forward_algorithm_scaled<-function(visible_data,transition_matrix,emission_matrix,initial_distribution){
no_emitted_values <- length(visible_data)
no_hidden_values <- nrow(transition_matrix)
alpha <-matrix(NA,no_emitted_values,no_hidden_values)
c_0<-sum(initial_distribution*emission_matrix[,visible_data[1]])
alpha[1,]<-(1/c_0)*initial_distribution*emission_matrix[,visible_data[1]]
log_L<-list()
log_L<-append(log_L,log(c_0))
for (n in 2:(no_emitted_values)){
transitted<-alpha[(n-1),] %*% transition_matrix
c_n<-sum(transitted*emission_matrix[,visible_data[n]])
alpha[n,]<-(1/c_n)*transitted*emission_matrix[,visible_data[n]]
log_L<-append(log_L,log(c_n))
}
return(unlist(log_L))
}
## WHAT ARE THESE TWO VALUES? LOG-LIKELIHOOD IS NA?
c_n<-forward_algorithm_scaled(visible_data = emitted_sequences, transition_matrix = matrix(as.numeric(A),nrow=2),
emission_matrix = matrix(as.numeric(B),nrow=2), initial_distribution = as.numeric(mu_naught))
log_likelihood<-sum(c_n)
emitted_sequences <- c(1,1,2,4,5)
## WHAT ARE THESE TWO VALUES? LOG-LIKELIHOOD IS NA?
c_n<-forward_algorithm_scaled(visible_data = emitted_sequences, transition_matrix = matrix(as.numeric(A),nrow=2),
emission_matrix = matrix(as.numeric(B),nrow=2), initial_distribution = as.numeric(mu_naught))
log_likelihood<-sum(c_n)
c_n_arg <- c_n
backward_algorithm_scaled<-function(visible_data,hidden_states,emission_matrix,transition_matrix,c_n_arg){
no_emitted_values <- length(visible_data)
no_hidden_values <- nrow(transition_matrix)
beta_hat<-matrix(NA,no_emitted_values,no_hidden_values)
c_n_arg<-exp(c_n_arg)
N<-length(visible_data)
beta_hat[N,]<-(1/c_n_arg[N])
for (n in (N-1):1){
# beta_hat[n,]<-(1/c_n[n])* emission_matrix[,visible_data[n+1]]* beta_hat[n+1,] %*% transition_matrix
beta_hat[n,]<-(1/c_n_arg[n])* emission_matrix[,visible_data[n+1]] %*% transition_matrix  * beta_hat[n+1,]
}
return(beta_hat)
}
beta_hat<-backward_algorithm_scaled(visible_data = emitted_sequences,hidden_states = hidden_values,
emission_matrix = matrix(as.numeric(B),nrow=2), transition_matrix = matrix(as.numeric(A),nrow=2),c_n)
beta_hat
forward_algorithm_scaled2<-function(visible_data,transition_matrix,emission_matrix,initial_distribution){
no_emitted_values <- length(visible_data)+1
no_hidden_values <- nrow(transition_matrix)
alpha <-matrix(NA,no_emitted_values,no_hidden_values)
c_0<-sum(initial_distribution*emission_matrix[,visible_data[1]])
alpha[1,]<-(1/c_0)*initial_distribution*emission_matrix[,visible_data[1]]
log_L<-list()
log_L<-append(log_L,log(c_0))
for (n in 2:(no_emitted_values)){
transitted<-alpha[(n-1),] %*% transition_matrix
c_n<-sum(transitted*emission_matrix[,visible_data[n]])
alpha[n,]<-(1/c_n)*transitted*emission_matrix[,visible_data[n]]
log_L<-append(log_L,log(c_n))
}
return(alpha)
}
alpha_hat<-forward_algorithm_scaled2(emitted_sequences,matrix(as.numeric(A),nrow=2),matrix(as.numeric(B),nrow=2),as.numeric(mu_naught))
alpha_hat
backward_algorithm_scaled<-function(visible_data,hidden_states,emission_matrix,transition_matrix,c_n_arg){
no_emitted_values <- length(visible_data)
no_hidden_values <- nrow(transition_matrix)
beta_hat<-matrix(NA,no_emitted_values,no_hidden_values)
c_n_arg<-exp(c_n_arg)
N<-length(visible_data)
beta_hat[N,]<-(1/c_n_arg[N])
for (n in (N-1):1){
# beta_hat[n,]<-(1/c_n[n])* emission_matrix[,visible_data[n+1]]* beta_hat[n+1,] %*% transition_matrix
beta_hat[n,]<-(1/c_n_arg[n])* emission_matrix[,visible_data[n+1]] %*% transition_matrix  * beta_hat[n+1,]
}
return(beta_hat)
}
beta_hat<-backward_algorithm_scaled(visible_data = emitted_sequences,hidden_states = hidden_values,
emission_matrix = matrix(as.numeric(B),nrow=2), transition_matrix = matrix(as.numeric(A),nrow=2),c_n)
beta_hat
forward_algorithm_scaled2<-function(visible_data,transition_matrix,emission_matrix,initial_distribution){
no_emitted_values <- length(visible_data)
no_hidden_values <- nrow(transition_matrix)
alpha <-matrix(NA,no_emitted_values,no_hidden_values)
c_0<-sum(initial_distribution*emission_matrix[,visible_data[1]])
alpha[1,]<-(1/c_0)*initial_distribution*emission_matrix[,visible_data[1]]
log_L<-list()
log_L<-append(log_L,log(c_0))
for (n in 2:(no_emitted_values)){
transitted<-alpha[(n-1),] %*% transition_matrix
c_n<-sum(transitted*emission_matrix[,visible_data[n]])
alpha[n,]<-(1/c_n)*transitted*emission_matrix[,visible_data[n]]
log_L<-append(log_L,log(c_n))
}
return(alpha)
}
alpha_hat<-forward_algorithm_scaled2(emitted_sequences,matrix(as.numeric(A),nrow=2),matrix(as.numeric(B),nrow=2),as.numeric(mu_naught))
alpha_hat
alpha_hat
baum_welch<-function(emitted_sequences,hidden_values){
#initialization
mu_0<-c(0.5,0.5)
trans_mat<-matrix(rep(0.5,4),nrow=2)
emission_mat<-matrix(rep(0.2,10),nrow=2)
N<-1000 ## number of iterations
#iteration
for (t in 1:N){
alpha_hat<-forward_algorithm_scaled2(emitted_sequences,trans_mat,emission_mat,mu_0)
c_n<-forward_algorithm_scaled(emitted_sequences,trans_mat,emission_mat,mu_0)
beta_hat<-backward_algorithm_scaled(emitted_sequences,hidden_values,emission_mat,trans_mat,c_n)
log_likelihood<-sum(c_n)
mu_0<-alpha_hat[1,] * trans_mat %*% emission_mat[,visible_data[1],drop=FALSE]*beta_hat[1,]
E_nij<-matrix(0,2,2)
for (m in 1:N){
E_nij<-E_nij + apply(trans_mat %*% emission_mat[,visible_data[(m+1)],drop=FALSE]*beta_hat[m+1,],1, function(x) alpha_hat[m,]*x)
}
trans_mat<-apply(E_nij,1,function(x) x/colSums(E_nij))
emission_mat<-rep(NA,1)
}
#termination
}
# E_nij<-matrix(0,2,2)
# for (m in 1:N){
#   E_nij<-E_nij + apply(trans_mat %*% emission_mat[,visible_data[(m+1)],drop=FALSE]*beta_hat[m+1,],1, function(x) alpha_hat[m,]*x)
# }
A <- matrix(NA, ncol(alpha_hat), ncol(alpha_hat))
## sum the number of times that we see the transition from k to l in the observed data
sum_over_j_i <- matrix(NA, ncol=ncol(alpha_hat), nrow=length(emitted_sequences))
sum_over_j_i
sum(sapply(1:length(emitted_sequences)){
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
f[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[l,i+1]
}
}
})
sum(sapply(1:length(emitted_sequences)){
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[l,i+1]
}
}
})
alpha_hat
length(emitted_sequences)
sum(sapply(1:(length(emitted_sequences)-1)){
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[l,i+1]
}
}
})
alpha_hat
ncol(alpha_hat)
(length(emitted_sequences)-1)
sum(sapply(1:(length(emitted_sequences)-1), function(i)){
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[l,i+1]
}
}
})
sapply(1:(length(emitted_sequences)-1), function(i){
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[l,i+1]
}
}
})
trans_mat<-matrix(rep(0.5,4),nrow=2)
emission_mat<-matrix(rep(0.2,10),nrow=2)
N<-1000 ## number of iterations
sapply(1:(length(emitted_sequences)-1), function(i){
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[l,i+1]
}
}
})
visible_data=rep(1,5)
sapply(1:(length(emitted_sequences)-1), function(i){
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[l,i+1]
}
}
})
beta_hat
alpha_hat
sapply(1:(length(emitted_sequences)-1), function(i){
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[i+1,l]
}
}
})
sapply(1:(length(emitted_sequences)-1), function(i){
.x <- matrix(NA, ncol(alpha_hat), ncol(alpha_hat))
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
.x[k,l] <- alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[i+1,l]
}
}
.x
})
sapply(1:(length(emitted_sequences)-1), function(i){
.x <- matrix(NA, ncol(alpha_hat), ncol(alpha_hat))
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
.x[k,l] <- alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[i+1,l]
}
}
.x
})
A <- matrix(NA, ncol(alpha_hat), ncol(alpha_hat))
A <- matrix(NA, ncol(alpha_hat), ncol(alpha_hat))
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
A[k,l] <- sapply(1:(length(emitted_sequences)-1), function(i){ alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[i+1,l]})
}
}
sapply(1:(length(emitted_sequences)-1), function(i){ alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[i+1,l]})
}
sapply(1:(length(emitted_sequences)-1), function(i){ alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[i+1,l]})
A <- matrix(NA, ncol(alpha_hat), ncol(alpha_hat))
for(k in 1:ncol(alpha_hat)){
for(l in 1:ncol(alpha_hat)){
A[k,l] <- sum(sapply(1:(length(emitted_sequences)-1), function(i){ alpha_hat[i,k] * trans_mat[k,l]*emission_mat[l,visible_data[i+1]]*beta_hat[i+1,l]}))
}
}
A
alpha_hat
alpha_hat[length(emitted_sequences]
alpha_hat[length(emitted_sequences)]
alpha_hat[length(emitted_sequences),]
A
rm(list = ls())
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
flder <- "../../../data/restricted/pcawg/consensus_subclonal_reconstruction_mutccf_20170325/"
library(VariantAnnotation)
library(annotate)
library(org.Hs.eg.db)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
source("helper_load_vcf_and_clonal.R")
change_column_names <- function(i){
colnames(i)[colnames(i) == "startpos"] <- "start"
colnames(i)[colnames(i) == "endpos"] <- "end"
i
}
rm(list = ls())
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
library(reshape2)
library(ggplot2)
library(dplyr)
flder <- "../../../data/restricted/pcawg/consensus_subclonal_reconstruction_mutccf_20170325/"
metadata <- read.table("../../../data/restricted/pcawg/pcawg.wg11.final_sample_list_MARCH2019.txt", head=T)
enough_samples = read.table("../../../data/restricted/pcawg/CT_sufficient_samples.txt", comment.char='#')[,1]
input_files <- list.files(flder, full.names = T)
file_name <- input_files
a <- sapply(file_name, function(i) gsub(".txt", ".RDS", gsub(".consensus_subclonal_reconstruction_mutccf_20170325/", "/var_annotation_with_ccf", i)))
read_annotation <- lapply(a, function(j) try(readRDS(j)))
read_annotation <- read_annotation[sapply(read_annotation, typeof) != "character"]
# kegg_pathway_name <- 'KEGG HRD'
# kegg_pathway_name <- 'KEGG MMR'
# kegg_pathway_name <- 'KEGG BER'
# kegg_pathway_name <- 'KEGG NER'
kegg_pathway_name <- 'KEGG NHEJ'
for(kegg_pathway_name in c('POLD1')){
single_gene <- F
if(kegg_pathway_name == 'KEGG HRD'){
kegg <- read.table("../../../data/other/KEGG/KEGG_HOMOLOGOUS_RECOMBINATION.txt", sep = "\t")
}else if(kegg_pathway_name == 'KEGG MMR'){
kegg <- read.table("../../../data/other/KEGG/KEGG_MISMATCH_REPAIR.txt", sep = "\t")
}else if(kegg_pathway_name == 'KEGG BER'){
kegg <- read.table("../../../data/other/KEGG/KEGG_BASE_EXCISION_REPAIR.txt", sep = "\t")
}else if(kegg_pathway_name == 'KEGG NER'){
kegg <- read.table("../../../data/other/KEGG/KEGG_NUCLEOTIDE_EXCISION_REPAIR.txt", sep = "\t")
}else if(kegg_pathway_name == 'KEGG NHEJ'){
kegg <- read.table("../../../data/other/KEGG/KEGG_NON_HOMOLOGOUS_END_JOINING.txt", sep = "\t")
}else if(kegg_pathway_name %in% c('TP53', 'POLD1')){
kegg <- kegg_pathway_name
single_gene <- T
}else{
stop('Incorrect kegg/gene')
}
keggname_out <- gsub(" ", "", kegg_pathway_name)
# if(single_gene){
#   kegg <- 'CCNE1'
#   kegg_pathway_name <- kegg
#   keggname_out <- gsub(" ", "", kegg_pathway_name)
# }
if(!single_gene) kegg <- kegg$V1[-c(1:2)] ## first two lines are annotation
GOI <- lapply(read_annotation, function(i) i[i$gene_symbol %in% kegg,])
GOI_len <- sapply(GOI, length)
table(GOI_len)
GOI_muts <- GOI[GOI_len> 0]
GOI_muts_NS <- sapply(GOI_muts, function(i) i[i$CONSEQUENCE == "nonsynonymous",])
GOI_muts_NS_ccf <- lapply(GOI_muts_NS, function(i) data.frame(i)[,c('ccf', 'gene_symbol')])
# length(GOI_muts_NS_ccf)
# hist(unlist(GOI_muts_NS_ccf))
GOI_muts_NS_ccf_melt <- cbind.data.frame(sample=rep(basename(names(GOI_muts_NS_ccf)), sapply(GOI_muts_NS_ccf, nrow)),
ccf=do.call('rbind', GOI_muts_NS_ccf))
rownames(GOI_muts_NS_ccf_melt) <- NULL
GOI_muts_NS_ccf_melt$ct <- metadata$histology_detailed[match(gsub("_mutation_ccf.txt", "", GOI_muts_NS_ccf_melt$sample),
metadata$samplename)]
head(GOI_muts_NS_ccf_melt)
metadata
GOI_muts_NS_ccf_melt_dplyr <- GOI_muts_NS_ccf_melt %>% group_by(ct) %>% summarise(median(ccf.ccf))
GOI_muts_NS_ccf_melt <- GOI_muts_NS_ccf_melt[GOI_muts_NS_ccf_melt$ct %in% enough_samples,]
unique(GOI_muts_NS_ccf_melt$ct) %in% GOI_muts_NS_ccf_melt_dplyr$ct
GOI_muts_NS_ccf_melt <- GOI_muts_NS_ccf_melt[!(is.na(GOI_muts_NS_ccf_melt$ct)),]
ggplot(GOI_muts_NS_ccf_melt, aes(x=factor(ct, levels=GOI_muts_NS_ccf_melt_dplyr$ct[order(GOI_muts_NS_ccf_melt_dplyr$`median(ccf.ccf)`)]),
y=ccf.ccf,col=ccf.gene_symbol, group=ct))+geom_boxplot()+geom_jitter(alpha=0.2)+theme_bw()+
theme(axis.text.x=element_text(angle = 45, hjust = 1, vjust=1))+
labs(x='', y= paste0('CCF of non-synonymous ', kegg_pathway_name, ' mutation'), col='Gene')
ggsave(paste0("../../../results/validation/NS_", keggname_out, "_ccf.pdf"), height = 4.5)
GOI_muts_NS_ccf_melt$ccf_lim <- sapply(GOI_muts_NS_ccf_melt$ccf.ccf, function(i) min(i, 1))
GOI_muts_NS_ccf_melt_dplyr_lim <- GOI_muts_NS_ccf_melt %>% group_by(ct) %>% summarise(med=median(ccf_lim, na.rm = T),
mean=mean(ccf_lim, na.rm = T))
ggplot(GOI_muts_NS_ccf_melt, aes(x=factor(ct, levels=GOI_muts_NS_ccf_melt_dplyr$ct[order(GOI_muts_NS_ccf_melt_dplyr$`median(ccf.ccf)`)]),
y=ccf_lim, col=ccf.gene_symbol, group=ct))+geom_boxplot()+geom_jitter(alpha=0.2)+theme_bw()+
theme(axis.text.x=element_text(angle = 45, hjust = 1, vjust=1))+
labs(x='', y= paste0('CCF of non-synonymous ', kegg_pathway_name, ' mutation'), col='Gene')
ggsave(paste0("../../../results/validation/NS_",keggname_out, "_ccf_lim1.pdf"), height = 4.5)
ggplot(GOI_muts_NS_ccf_melt, aes(x=factor(ct, levels=GOI_muts_NS_ccf_melt_dplyr_lim$ct[order(GOI_muts_NS_ccf_melt_dplyr_lim$mean)]),
y=ccf_lim, group=ct))+geom_boxplot()+geom_jitter(alpha=0.2)+theme_bw()+
theme(axis.text.x=element_text(angle = 45, hjust = 1, vjust=1))+
labs(x='', y= paste0('CCF of non-synonymous\n', kegg_pathway_name, ' mutation'), col='Gene')
ggsave(paste0("../../../results/validation/NS_",keggname_out, "_ccf_lim1_nocolour.pdf"), height = 4.5)
saveRDS(list(GOI_muts_NS=GOI_muts_NS, GOI_muts_NS_ccf_melt=GOI_muts_NS_ccf_melt),
paste0("../../../data/other/KEGG/KEGG_", keggname_out, ".RDS"))
}
