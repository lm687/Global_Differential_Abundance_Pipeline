return(NA)
}else{
if(!(dataset_TMB[[idx_dataset]]$pdHess)){
# no good convergence
return(NA)
}else{
beta_coefs = python_like_select_name(dataset_TMB[[idx_dataset]]$par.fixed, 'beta')
RE_coefs = dataset_TMB[[idx_dataset]]$par.random
lambda = python_like_select_name(dataset_TMB[[idx_dataset]]$par.fixed, 'log_lambda')
if(model == 'DM'){
sim_thetas = replicate(1e3, simulate_from_DM_RE(beta_coefs, RE_coefs, lambda, coefficient_overdispersion))
}else if(model == 'DM_altpar'){
sim_thetas = replicate(1e3, simulate_from_DM_RE_altpar(beta_coefs, RE_coefs, lambda))
}else if(model == 'M'){
thetas_M = simulate_from_M_RE(beta_coefs, RE_coefs)
sim_thetas = replicate(1e3, thetas_M)
}else{
stop('Indicate a correct <model>')
}
## from observed
matrices = slot(count_objects[[idx_dataset]], 'count_matrices_active')
if(sum(sapply(matrices, length)) == 0){
matrices = slot(count_objects[[idx_dataset]], 'count_matrices_all')
}
matrices = do.call('rbind', lapply(matrices, round))
vec_observed = as.vector(matrices)
mut_toll = rowSums(matrices)
## simulate with multinomial from these thetas
idx_sim = 1
multinom_draws = sapply(1:dim(sim_thetas)[3], function(simulate){
as.vector(t(sapply(1:nrow(sim_thetas[,,idx_sim]), function(i) rmultinom( n = 1, size = mut_toll[i], prob = sim_thetas[i,,idx_sim]) )))
})
## check if real values fall in the confidence interval, for each of the thetas
multinom_draws[[1]]
multinom_draws[[2]]
in_conf_int = sapply(1:dim(multinom_draws)[1], function(i){
confint_bounds = quantile(multinom_draws[i,], probs = c(0.025, 0.975))
(vec_observed[i] >= confint_bounds[1]) & (vec_observed[i] <= confint_bounds[2])
})
## plotting with subsample
subset_pars = 1:length(vec_observed) #sample(1:length(vec_observed), size = 10)
ccccc=melt(multinom_draws[subset_pars,sample(1:1000, size = 100)])
plot(ccccc$Var1, ccccc$value)
points(1:length(subset_pars), vec_observed[subset_pars], col='red')
return(in_conf_int)
# ml_thetas = normalise_rw(do.call('rbind', matrices))
# ml_thetas = replicate(20, ml_thetas)
# dim(melt(sim_thetas))
# dim(melt(ml_thetas))
# plot(cbind(sim=melt(sim_thetas), ml=melt(ml_thetas))[,c('sim.value', 'ml.value')],
#      main=names(count_objects[idx_dataset]), cex.main=.7)
# abline(coef = c(0,1), col='blue', lty='dashed')
}
}
}
beta_coefs = python_like_select_name(dataset_TMB[[idx_dataset]]$par.fixed, 'beta')
RE_coefs = dataset_TMB[[idx_dataset]]$par.random
lambda = python_like_select_name(dataset_TMB[[idx_dataset]]$par.fixed, 'log_lambda')
if(model == 'DM'){
sim_thetas = replicate(1e3, simulate_from_DM_RE(beta_coefs, RE_coefs, lambda, coefficient_overdispersion))
}else if(model == 'DM_altpar'){
sim_thetas = replicate(1e3, simulate_from_DM_RE_altpar(beta_coefs, RE_coefs, lambda))
}else if(model == 'M'){
thetas_M = simulate_from_M_RE(beta_coefs, RE_coefs)
sim_thetas = replicate(1e3, thetas_M)
}else{
stop('Indicate a correct <model>')
}
## from observed
matrices = slot(count_objects[[idx_dataset]], 'count_matrices_active')
if(sum(sapply(matrices, length)) == 0){
matrices = slot(count_objects[[idx_dataset]], 'count_matrices_all')
}
matrices = do.call('rbind', lapply(matrices, round))
vec_observed = as.vector(matrices)
mut_toll = rowSums(matrices)
## simulate with multinomial from these thetas
idx_sim = 1
multinom_draws = sapply(1:dim(sim_thetas)[3], function(simulate){
as.vector(t(sapply(1:nrow(sim_thetas[,,idx_sim]), function(i) rmultinom( n = 1, size = mut_toll[i], prob = sim_thetas[i,,idx_sim]) )))
})
multinom_draws[[1]]
multinom_draws[[2]]
in_conf_int = sapply(1:dim(multinom_draws)[1], function(i){
confint_bounds = quantile(multinom_draws[i,], probs = c(0.025, 0.975))
(vec_observed[i] >= confint_bounds[1]) & (vec_observed[i] <= confint_bounds[2])
})
## plotting with subsample
subset_pars = 1:length(vec_observed) #sample(1:length(vec_observed), size = 10)
ccccc=melt(multinom_draws[subset_pars,sample(1:1000, size = 100)])
in_conf_int
sum(in_conf_int)/length(in_conf_int)
length(subset_pars)
length(in_conf_int)
in_conf_int
sum(in_conf_int)
vec_observed
ccccc=melt(multinom_draws[subset_pars,sample(1:1000, size = 100)][in_conf_int,])
plot(ccccc$Var1, ccccc$value)
points(1:sum(in_conf_int), vec_observed[subset_pars][in_conf_int], col='red')
## the ones that didn't work
ccccc=melt(multinom_draws[subset_pars,sample(1:1000, size = 100)][!in_conf_int,])
plot(ccccc$Var1, ccccc$value)
points(1:sum(!in_conf_int), vec_observed[subset_pars][!in_conf_int], col='red')
names(results_TMB_fullRE_DM)[55]
DM = readRDS("../../data/robjects_cache/tmb_results/fullRE_DM_Kidney-RCC.clearcell_nucleotidesubstitution1.RDS")
M = readRDS("../../data/robjects_cache/tmb_results/fullRE_M_Kidney-RCC.clearcell_nucleotidesubstitution1.RDS")
DM
M
dataset_TMB = list(M=M, DM=DM)
idx_dataset = 'DM'
beta_coefs = python_like_select_name(dataset_TMB[[idx_dataset]]$par.fixed, 'beta')
RE_coefs = dataset_TMB[[idx_dataset]]$par.random
lambda = python_like_select_name(dataset_TMB[[idx_dataset]]$par.fixed, 'log_lambda')
if(model == 'DM'){
sim_thetas = replicate(1e3, simulate_from_DM_RE(beta_coefs, RE_coefs, lambda, coefficient_overdispersion))
}else if(model == 'DM_altpar'){
sim_thetas = replicate(1e3, simulate_from_DM_RE_altpar(beta_coefs, RE_coefs, lambda))
}else if(model == 'M'){
thetas_M = simulate_from_M_RE(beta_coefs, RE_coefs)
sim_thetas = replicate(1e3, thetas_M)
}else{
stop('Indicate a correct <model>')
}
model = idx_dataset
res_sim
res_draws = lapply(c('M', 'DM'), function(idx_dataset){
beta_coefs = python_like_select_name(dataset_TMB[[idx_dataset]]$par.fixed, 'beta')
RE_coefs = dataset_TMB[[idx_dataset]]$par.random
lambda = python_like_select_name(dataset_TMB[[idx_dataset]]$par.fixed, 'log_lambda')
if(model == 'DM'){
sim_thetas = replicate(1e3, simulate_from_DM_RE(beta_coefs, RE_coefs, lambda, coefficient_overdispersion))
}else if(model == 'DM_altpar'){
sim_thetas = replicate(1e3, simulate_from_DM_RE_altpar(beta_coefs, RE_coefs, lambda))
}else if(model == 'M'){
thetas_M = simulate_from_M_RE(beta_coefs, RE_coefs)
sim_thetas = replicate(1e3, thetas_M)
}else{
stop('Indicate a correct <model>')
}
## from observed
matrices = slot(count_objects[[idx_dataset]], 'count_matrices_active')
if(sum(sapply(matrices, length)) == 0){
matrices = slot(count_objects[[idx_dataset]], 'count_matrices_all')
}
matrices = do.call('rbind', lapply(matrices, round))
vec_observed = as.vector(matrices)
mut_toll = rowSums(matrices)
## simulate with multinomial from these thetas
idx_sim = 1
multinom_draws = sapply(1:dim(sim_thetas)[3], function(simulate){
as.vector(t(sapply(1:nrow(sim_thetas[,,idx_sim]), function(i) rmultinom( n = 1, size = mut_toll[i], prob = sim_thetas[i,,idx_sim]) )))
})
## check if real values fall in the confidence interval, for each of the thetas
multinom_draws[[1]]
multinom_draws[[2]]
in_conf_int = sapply(1:dim(multinom_draws)[1], function(i){
confint_bounds = quantile(multinom_draws[i,], probs = c(0.025, 0.975))
(vec_observed[i] >= confint_bounds[1]) & (vec_observed[i] <= confint_bounds[2])
})
## plotting with subsample
subset_pars = 1:length(vec_observed) #sample(1:length(vec_observed), size = 10)
ccccc=melt(multinom_draws[subset_pars,sample(1:1000, size = 100)])
plot(ccccc$Var1, ccccc$value)
points(1:length(subset_pars), vec_observed[subset_pars], col='red')
## the ones that worked
ccccc_success=melt(multinom_draws[subset_pars,sample(1:1000, size = 100)][in_conf_int,])
plot(ccccc_success$Var1, ccccc_success$value)
points(1:sum(in_conf_int), vec_observed[subset_pars][in_conf_int], col='red')
## the ones that didn't work
ccccc_failed=melt(multinom_draws[subset_pars,sample(1:1000, size = 100)][!in_conf_int,])
plot(ccccc_failed$Var1, ccccc_failed$value)
points(1:sum(!in_conf_int), vec_observed[subset_pars][!in_conf_int], col='red')
return(list(draws=multinom_draws, in_conf_int=in_conf_int, melt_all=ccccc,
melt_success=ccccc_success, melt_failed=ccccc_failed))
})
res_draws = lapply(c('M', 'DM'), function(idx_dataset){
model = idx_dataset
beta_coefs = python_like_select_name(dataset_TMB[[idx_dataset]]$par.fixed, 'beta')
RE_coefs = dataset_TMB[[idx_dataset]]$par.random
lambda = python_like_select_name(dataset_TMB[[idx_dataset]]$par.fixed, 'log_lambda')
if(model == 'DM'){
sim_thetas = replicate(1e3, simulate_from_DM_RE(beta_coefs, RE_coefs, lambda, coefficient_overdispersion))
}else if(model == 'DM_altpar'){
sim_thetas = replicate(1e3, simulate_from_DM_RE_altpar(beta_coefs, RE_coefs, lambda))
}else if(model == 'M'){
thetas_M = simulate_from_M_RE(beta_coefs, RE_coefs)
sim_thetas = replicate(1e3, thetas_M)
}else{
stop('Indicate a correct <model>')
}
## from observed
matrices = slot(count_objects[[idx_dataset]], 'count_matrices_active')
if(sum(sapply(matrices, length)) == 0){
matrices = slot(count_objects[[idx_dataset]], 'count_matrices_all')
}
matrices = do.call('rbind', lapply(matrices, round))
vec_observed = as.vector(matrices)
mut_toll = rowSums(matrices)
## simulate with multinomial from these thetas
idx_sim = 1
multinom_draws = sapply(1:dim(sim_thetas)[3], function(simulate){
as.vector(t(sapply(1:nrow(sim_thetas[,,idx_sim]), function(i) rmultinom( n = 1, size = mut_toll[i], prob = sim_thetas[i,,idx_sim]) )))
})
## check if real values fall in the confidence interval, for each of the thetas
multinom_draws[[1]]
multinom_draws[[2]]
in_conf_int = sapply(1:dim(multinom_draws)[1], function(i){
confint_bounds = quantile(multinom_draws[i,], probs = c(0.025, 0.975))
(vec_observed[i] >= confint_bounds[1]) & (vec_observed[i] <= confint_bounds[2])
})
## plotting with subsample
subset_pars = 1:length(vec_observed) #sample(1:length(vec_observed), size = 10)
ccccc=melt(multinom_draws[subset_pars,sample(1:1000, size = 100)])
plot(ccccc$Var1, ccccc$value)
points(1:length(subset_pars), vec_observed[subset_pars], col='red')
## the ones that worked
ccccc_success=melt(multinom_draws[subset_pars,sample(1:1000, size = 100)][in_conf_int,])
plot(ccccc_success$Var1, ccccc_success$value)
points(1:sum(in_conf_int), vec_observed[subset_pars][in_conf_int], col='red')
## the ones that didn't work
ccccc_failed=melt(multinom_draws[subset_pars,sample(1:1000, size = 100)][!in_conf_int,])
plot(ccccc_failed$Var1, ccccc_failed$value)
points(1:sum(!in_conf_int), vec_observed[subset_pars][!in_conf_int], col='red')
return(list(draws=multinom_draws, in_conf_int=in_conf_int, melt_all=ccccc,
melt_success=ccccc_success, melt_failed=ccccc_failed))
})
count_objects
count_object = count_objects$`Kidney-RCC.clearcell_nucleotidesubstitution1`
count_object
res_draws = lapply(c('M', 'DM'), function(idx_dataset){
model = idx_dataset
beta_coefs = python_like_select_name(dataset_TMB[[idx_dataset]]$par.fixed, 'beta')
RE_coefs = dataset_TMB[[idx_dataset]]$par.random
lambda = python_like_select_name(dataset_TMB[[idx_dataset]]$par.fixed, 'log_lambda')
if(model == 'DM'){
sim_thetas = replicate(1e3, simulate_from_DM_RE(beta_coefs, RE_coefs, lambda, coefficient_overdispersion))
}else if(model == 'DM_altpar'){
sim_thetas = replicate(1e3, simulate_from_DM_RE_altpar(beta_coefs, RE_coefs, lambda))
}else if(model == 'M'){
thetas_M = simulate_from_M_RE(beta_coefs, RE_coefs)
sim_thetas = replicate(1e3, thetas_M)
}else{
stop('Indicate a correct <model>')
}
## from observed
matrices = slot(count_object, 'count_matrices_active')
if(sum(sapply(matrices, length)) == 0){
matrices = slot(count_object, 'count_matrices_all')
}
matrices = do.call('rbind', lapply(matrices, round))
vec_observed = as.vector(matrices)
mut_toll = rowSums(matrices)
## simulate with multinomial from these thetas
idx_sim = 1
multinom_draws = sapply(1:dim(sim_thetas)[3], function(simulate){
as.vector(t(sapply(1:nrow(sim_thetas[,,idx_sim]), function(i) rmultinom( n = 1, size = mut_toll[i], prob = sim_thetas[i,,idx_sim]) )))
})
## check if real values fall in the confidence interval, for each of the thetas
multinom_draws[[1]]
multinom_draws[[2]]
in_conf_int = sapply(1:dim(multinom_draws)[1], function(i){
confint_bounds = quantile(multinom_draws[i,], probs = c(0.025, 0.975))
(vec_observed[i] >= confint_bounds[1]) & (vec_observed[i] <= confint_bounds[2])
})
## plotting with subsample
subset_pars = 1:length(vec_observed) #sample(1:length(vec_observed), size = 10)
ccccc=melt(multinom_draws[subset_pars,sample(1:1000, size = 100)])
plot(ccccc$Var1, ccccc$value)
points(1:length(subset_pars), vec_observed[subset_pars], col='red')
## the ones that worked
ccccc_success=melt(multinom_draws[subset_pars,sample(1:1000, size = 100)][in_conf_int,])
plot(ccccc_success$Var1, ccccc_success$value)
points(1:sum(in_conf_int), vec_observed[subset_pars][in_conf_int], col='red')
## the ones that didn't work
ccccc_failed=melt(multinom_draws[subset_pars,sample(1:1000, size = 100)][!in_conf_int,])
plot(ccccc_failed$Var1, ccccc_failed$value)
points(1:sum(!in_conf_int), vec_observed[subset_pars][!in_conf_int], col='red')
return(list(draws=multinom_draws, in_conf_int=in_conf_int, melt_all=ccccc,
melt_success=ccccc_success, melt_failed=ccccc_failed))
})
names(res_draws) = c('M', 'DM')
res_draws = lapply(c('M', 'DM'), function(idx_dataset){
model = idx_dataset
beta_coefs = python_like_select_name(dataset_TMB[[idx_dataset]]$par.fixed, 'beta')
RE_coefs = dataset_TMB[[idx_dataset]]$par.random
lambda = python_like_select_name(dataset_TMB[[idx_dataset]]$par.fixed, 'log_lambda')
if(model == 'DM'){
sim_thetas = replicate(1e3, simulate_from_DM_RE(beta_coefs, RE_coefs, lambda, coefficient_overdispersion))
}else if(model == 'DM_altpar'){
sim_thetas = replicate(1e3, simulate_from_DM_RE_altpar(beta_coefs, RE_coefs, lambda))
}else if(model == 'M'){
thetas_M = simulate_from_M_RE(beta_coefs, RE_coefs)
sim_thetas = replicate(1e3, thetas_M)
}else{
stop('Indicate a correct <model>')
}
## from observed
matrices = slot(count_object, 'count_matrices_active')
if(sum(sapply(matrices, length)) == 0){
matrices = slot(count_object, 'count_matrices_all')
}
matrices = do.call('rbind', lapply(matrices, round))
vec_observed = as.vector(matrices)
mut_toll = rowSums(matrices)
## simulate with multinomial from these thetas
idx_sim = 1
multinom_draws = sapply(1:dim(sim_thetas)[3], function(simulate){
as.vector(t(sapply(1:nrow(sim_thetas[,,idx_sim]), function(i) rmultinom( n = 1, size = mut_toll[i], prob = sim_thetas[i,,idx_sim]) )))
})
## check if real values fall in the confidence interval, for each of the thetas
multinom_draws[[1]]
multinom_draws[[2]]
in_conf_int = sapply(1:dim(multinom_draws)[1], function(i){
confint_bounds = quantile(multinom_draws[i,], probs = c(0.025, 0.975))
(vec_observed[i] >= confint_bounds[1]) & (vec_observed[i] <= confint_bounds[2])
})
## plotting with subsample
subset_pars = 1:length(vec_observed) #sample(1:length(vec_observed), size = 10)
ccccc=melt(multinom_draws[subset_pars,sample(1:1000, size = 100)])
## the ones that worked
ccccc_success=melt(multinom_draws[subset_pars,sample(1:1000, size = 100)][in_conf_int,])
## the ones that didn't work
ccccc_failed=melt(multinom_draws[subset_pars,sample(1:1000, size = 100)][!in_conf_int,])
return(list(draws=multinom_draws, in_conf_int=in_conf_int, melt_all=ccccc,
melt_success=ccccc_success, melt_failed=ccccc_failed, vec_observed_subset=vec_observed[subset_pars]))
})
names(res_draws) = c('M', 'DM')
plot(res_draws$M$melt_all$Var1, ccccc$value)
res_draws$M$melt_all
res_draws$M$melt_all$Var1
plot(res_draws$M$melt_all$Var1, res_draws$M$melt_all$value)
points(1:length(subset_pars), res_draws$M$vec_observed_subset, col='red')
plot(ccccc_success$Var1, ccccc_success$value)
plot(res_draws$M$melt_success$Var1, res_draws$M$melt_success$value)
res_draws = lapply(c('M', 'DM'), function(idx_dataset){
model = idx_dataset
beta_coefs = python_like_select_name(dataset_TMB[[idx_dataset]]$par.fixed, 'beta')
RE_coefs = dataset_TMB[[idx_dataset]]$par.random
lambda = python_like_select_name(dataset_TMB[[idx_dataset]]$par.fixed, 'log_lambda')
if(model == 'DM'){
sim_thetas = replicate(1e3, simulate_from_DM_RE(beta_coefs, RE_coefs, lambda, coefficient_overdispersion))
}else if(model == 'DM_altpar'){
sim_thetas = replicate(1e3, simulate_from_DM_RE_altpar(beta_coefs, RE_coefs, lambda))
}else if(model == 'M'){
thetas_M = simulate_from_M_RE(beta_coefs, RE_coefs)
sim_thetas = replicate(1e3, thetas_M)
}else{
stop('Indicate a correct <model>')
}
## from observed
matrices = slot(count_object, 'count_matrices_active')
if(sum(sapply(matrices, length)) == 0){
matrices = slot(count_object, 'count_matrices_all')
}
matrices = do.call('rbind', lapply(matrices, round))
vec_observed = as.vector(matrices)
mut_toll = rowSums(matrices)
## simulate with multinomial from these thetas
idx_sim = 1
multinom_draws = sapply(1:dim(sim_thetas)[3], function(simulate){
as.vector(t(sapply(1:nrow(sim_thetas[,,idx_sim]), function(i) rmultinom( n = 1, size = mut_toll[i], prob = sim_thetas[i,,idx_sim]) )))
})
## check if real values fall in the confidence interval, for each of the thetas
multinom_draws[[1]]
multinom_draws[[2]]
in_conf_int = sapply(1:dim(multinom_draws)[1], function(i){
confint_bounds = quantile(multinom_draws[i,], probs = c(0.025, 0.975))
(vec_observed[i] >= confint_bounds[1]) & (vec_observed[i] <= confint_bounds[2])
})
## plotting with subsample
subset_pars = 1:length(vec_observed) #sample(1:length(vec_observed), size = 10)
ccccc=melt(multinom_draws[subset_pars,sample(1:1000, size = 100)])
## the ones that worked
ccccc_success=melt(multinom_draws[subset_pars,sample(1:1000, size = 100)][in_conf_int,])
## the ones that didn't work
ccccc_failed=melt(multinom_draws[subset_pars,sample(1:1000, size = 100)][!in_conf_int,])
return(list(draws=multinom_draws, in_conf_int=in_conf_int, melt_all=ccccc,
melt_success=ccccc_success, melt_failed=ccccc_failed, vec_observed_subset=vec_observed[subset_pars],
subset_pars_idx=subset_pars))
})
names(res_draws) = c('M', 'DM')
plot(res_draws$M$melt_all$Var1, res_draws$M$melt_all$value)
points(1:length(res_draws$M$subset_pars_idx), res_draws$M$vec_observed_subset, col='red')
length(res_draws$M$subset_pars_idx)
res_draws$M$in_conf_int
plot(res_draws$M$melt_success$Var1, res_draws$M$melt_success$value)
points(1:sum(res_draws$M$in_conf_int), res_draws$M$vec_observed_subset[res_draws$M$in_conf_int], col='red')
plot(res_draws$M$melt_failed$Var1, res_draws$M$melt_failed$value)
points(1:sum(!(res_draws$M$in_conf_int)), res_draws$M$vec_observed_subset[!(res_draws$M$in_conf_int)], col='red')
res_draws$M$melt_failed$Var1
head(res_draws$M$melt_failed)
plot(res_draws$M$melt_failed$Var1, log(res_draws$M$melt_failed$value))
points(1:sum(!(res_draws$M$in_conf_int)), log(res_draws$M$vec_observed_subset[!(res_draws$M$in_conf_int)]), col='red')
res_draws$M$melt_failed$Var1
length(res_draws$M$melt_failed$Var1)
length(res_draws$DM$melt_failed$Var1)
## why is there such a difference in the number of parameters to infer in either model?
length(res_draws$M$melt_all$Var1)
length(res_draws$DM$melt_all$Var1)
multinom_draws
dim(multinom_draws)
par(mfrow=c(1,2))
plot(res_draws$M$melt_all$Var1, res_draws$M$melt_all$value)
points(1:length(res_draws$M$subset_pars_idx), res_draws$M$vec_observed_subset, col='red')
plot(res_draws$DM$melt_all$Var1, res_draws$DM$melt_all$value)
points(1:length(res_draws$DM$subset_pars_idx), res_draws$DM$vec_observed_subset, col='red')
res_draws$M$melt_all
group_by(res_draws$M$melt_all, 'Var2')
group_by(res_draws$M$melt_all, 'Var2') %>% mean
group_by(res_draws$M$melt_all, 'Var2') %>% mean()
?group_by
group_by(res_draws$M$melt_all, 'Var2') %>% summarise("mean")
group_by(res_draws$M$melt_all, 'Var2') %>% summarise(mean)
group_by(res_draws$M$melt_all, 'Var2') %>% dplyr::summarise(mean(.))
group_by(res_draws$M$melt_all, 'Var2') %>% summarise(mean(value))
group_by(res_draws$M$melt_all, 'Var2') %>% summarise(a=mean(value))
res_draws$M$melt_all %>% group_by(Var2) %>% summarise(a=mean(value))
res_draws$M$melt_all %>% group_by(Var2) %>% summarise(a=mean())
res_draws$M$melt_all %>% group_by(Var2) %>% summarise(mean)
res_draws$M$melt_all %>% group_by(Var2) %>% summarise(mean(.))
res_draws$M$melt_all %>% group_by(Var2) %>% summarize_at(mean(.))
res_draws$M$melt_all %>% group_by(Var2) %>% summarize_at(mean
)
res_draws$M$melt_all %>% group_by(Var2) %>% dplyr::summarize(a=mean(value))
res_draws$M$melt_all %>% group_by(Var1) %>% dplyr::summarize(a=mean(value))
## sort them
ordered_pars = order(res_draws$M$melt_all %>% group_by(Var1) %>% dplyr::summarize(a=mean(value)))
ordered_pars
ordered_pars
res_draws$M$melt_all
res_draws$M$melt_all
res_draws$M$melt_all$Var1
res_draws$M$melt_all$Var1
ordered_pars
table(ordered_pars)
sapply(ordered_pars, function(sorted_idx) res_draws$M$melt_all[res_draws$M$melt_all$Var1 == sorted_idx,])
t(sapply(ordered_pars, function(sorted_idx) res_draws$M$melt_all[res_draws$M$melt_all$Var1 == sorted_idx,]))
lapply(ordered_pars, function(sorted_idx) res_draws$M$melt_all[res_draws$M$melt_all$Var1 == sorted_idx,])
unique(res_draws$M$melt_all$Var1)
## sort them
ordered_pars = unique(res_draws$M$melt_all$Var1)[order(res_draws$M$melt_all %>% group_by(Var1) %>% dplyr::summarize(a=mean(value)))]
ordered_pars
res_draws$M$melt_all %>% group_by(Var1) %>% dplyr::summarize(a=mean(value))
res_draws$M$melt_all %>% group_by(Var1) %>% dplyr::summarize(a=mean(value)) %>% select(a)
res_draws$M$melt_all %>% group_by(Var1) %>% dplyr::summarize(a=mean(value)) %>% select(a)
res_draws$M$melt_all %>% group_by(Var1) %>% dplyr::summarize(a=mean(value)) %>% select('a')
res_draws$M$melt_all %>% group_by(Var1) %>% dplyr::summarize(a=mean(value)) %>% dplyr::select(a)
order(res_draws$M$melt_all %>% group_by(Var1) %>% dplyr::summarize(a=mean(value)) %>% dplyr::select(a))
## sort them
ordered_pars = order(res_draws$M$melt_all %>% group_by(Var1) %>% dplyr::summarize(a=mean(value)) %>% dplyr::select(a))
t(sapply(ordered_pars, function(sorted_idx) res_draws$M$melt_all[res_draws$M$melt_all$Var1 == sorted_idx,]))
ordered_pars
unique(res_draws$M$melt_all$Var1)
length(ordered_pars)
length(unique(res_draws$M$melt_all$Var1))
t(sapply(ordered_pars, function(sorted_idx) res_draws$M$melt_all[res_draws$M$melt_all$Var1 == sorted_idx,]))
lapply(ordered_pars, function(sorted_idx) res_draws$M$melt_all[res_draws$M$melt_all$Var1 == sorted_idx,])
do.call('rbind', lapply(ordered_pars, function(sorted_idx) res_draws$M$melt_all[res_draws$M$melt_all$Var1 == sorted_idx,]))
sorted_M = do.call('rbind', lapply(ordered_pars, function(sorted_idx) res_draws$M$melt_all[res_draws$M$melt_all$Var1 == sorted_idx,]))
sorted_M = do.call('rbind', lapply(ordered_pars, function(sorted_idx) res_draws$M$melt_all[res_draws$M$melt_all$Var1 == sorted_idx,]))
res_draws$M$subset_pars_idx
res_draws$M$vec_observed_subset
length(res_draws$M$vec_observed_subset)
res_draws$M$vec_observed_subset[ordered_pars]
plot(sorted_M$Var1, sorted_M$value)
points(1:length(res_draws$M$subset_pars_idx), res_draws$M$vec_observed_subset[ordered_pars], col='red')
sorted_M = do.call('rbind', lapply(ordered_pars, function(sorted_idx) res_draws$M$melt_all[res_draws$M$melt_all$Var1 == sorted_idx,]))
plot(sorted_M$Var1, sorted_M$value)
points(1:length(res_draws$M$subset_pars_idx), res_draws$M$vec_observed_subset[ordered_pars], col='red')
sorted_M
sorted_M$Var1
table(sorted_M$Var1)
rep(ordered_pars, each=100)
# plot(sorted_M$Var1, sorted_M$value)
plot(rep(ordered_pars, each=100), sorted_M$value)
points(1:length(res_draws$M$subset_pars_idx), res_draws$M$vec_observed_subset[ordered_pars], col='red')
dev.off()
# plot(sorted_M$Var1, sorted_M$value)
plot(rep(ordered_pars, each=100), res_draws$M$melt_all$Var1)
points(1:length(res_draws$M$subset_pars_idx), res_draws$M$vec_observed_subset[ordered_pars], col='red')
# plot(sorted_M$Var1, sorted_M$value)
plot(rep(ordered_pars, each=100), res_draws$M$melt_all$value)
points(1:length(res_draws$M$subset_pars_idx), res_draws$M$vec_observed_subset[ordered_pars], col='red')
sorted_M
# plot(sorted_M$Var1, sorted_M$value)
plot(rep(ordered_pars, 100), res_draws$M$melt_all$value)
points(1:length(res_draws$M$subset_pars_idx), res_draws$M$vec_observed_subset[ordered_pars], col='red')
res_draws$M$melt_all$value
sorted_M
length(ordered_pars)
sorted_M
plot(rep(1:length(ordered_pars), each=100), sorted_M$value)
plot(rep(1:length(ordered_pars), each=100), sorted_M$value)
points(1:length(res_draws$M$subset_pars_idx), res_draws$M$vec_observed_subset[ordered_pars], col='red')
res_draws$M$in_conf_int
length(res_draws$M$in_conf_int)
length(ordered_pars)
res_draws$M$in_conf_int[ordered_pars]
as.factor()
as.factor(res_draws$M$in_conf_int[ordered_pars])
## colour by success/failure
plot(rep(1:length(ordered_pars), each=100), sorted_M$value, col=as.factor(res_draws$M$in_conf_int[ordered_pars]))
dev.off()
## colour by success/failure
plot(rep(1:length(ordered_pars), each=100), sorted_M$value, col=as.factor(res_draws$M$in_conf_int[ordered_pars]))
## colour by success/failure. it's not related to the absolute value of the parameter
plot(rep(1:length(ordered_pars), each=100), sorted_M$value, col=as.factor(res_draws$M$in_conf_int[ordered_pars]), cex=0.2)
length(as.factor(res_draws$M$in_conf_int[ordered_pars]))
length(rep(1:length(ordered_pars), each=100))
## colour by success/failure. it's not related to the absolute value of the parameter
plot(rep(1:length(ordered_pars), each=100), sorted_M$value, col=as.factor(rep(res_draws$M$in_conf_int[ordered_pars], each=100)), cex=0.2)
