Loading required package: StanHeaders
Loading required package: ggplot2
rstan (Version 2.19.3, GitRev: 2e1f913d3ca3)
For execution on a local, multicore CPU with excess RAM we recommend calling
options(mc.cores = parallel::detectCores()).
To avoid recompilation of unchanged Stan programs, we recommend calling
rstan_options(auto_write = TRUE)
Loading required package: MASS
$status
[1] TRUE

$model_cppname
[1] "model5ef6f701cc921_stan_LNM_ME"

$cppcode
[1] "// Code generated by Stan version 2.21.0\n\n#include <stan/model/model_header.hpp>\n\nnamespace model5ef6f701cc921_stan_LNM_ME_namespace {\n\nusing std::istream;\nusing std::string;\nusing std::stringstream;\nusing std::vector;\nusing stan::io::dump;\nusing stan::math::lgamma;\nusing stan::model::prob_grad;\nusing namespace stan::math;\n\nstatic int current_statement_begin__;\n\nstan::io::program_reader prog_reader__() {\n    stan::io::program_reader reader;\n    reader.add_event(0, 0, \"start\", \"model5ef6f701cc921_stan_LNM_ME\");\n    reader.add_event(60, 58, \"end\", \"model5ef6f701cc921_stan_LNM_ME\");\n    return reader;\n}\n\nclass model5ef6f701cc921_stan_LNM_ME\n  : public stan::model::model_base_crtp<model5ef6f701cc921_stan_LNM_ME> {\nprivate:\n        int d;\n        int n;\n        std::vector<std::vector<int> > w;\n        matrix_d x;\n        matrix_d Z;\npublic:\n    model5ef6f701cc921_stan_LNM_ME(stan::io::var_context& context__,\n        std::ostream* pstream__ = 0)\n        : model_base_crtp(0) {\n        ctor_body(context__, 0, pstream__);\n    }\n\n    model5ef6f701cc921_stan_LNM_ME(stan::io::var_context& context__,\n        unsigned int random_seed__,\n        std::ostream* pstream__ = 0)\n        : model_base_crtp(0) {\n        ctor_body(context__, random_seed__, pstream__);\n    }\n\n    void ctor_body(stan::io::var_context& context__,\n                   unsigned int random_seed__,\n                   std::ostream* pstream__) {\n        typedef double local_scalar_t__;\n\n        boost::ecuyer1988 base_rng__ =\n          stan::services::util::create_rng(random_seed__, 0);\n        (void) base_rng__;  // suppress unused var warning\n\n        current_statement_begin__ = -1;\n\n        static const char* function__ = \"model5ef6f701cc921_stan_LNM_ME_namespace::model5ef6f701cc921_stan_LNM_ME\";\n        (void) function__;  // dummy to suppress unused var warning\n        size_t pos__;\n        (void) pos__;  // dummy to suppress unused var warning\n        std::vector<int> vals_i__;\n        std::vector<double> vals_r__;\n        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());\n        (void) DUMMY_VAR__;  // suppress unused var warning\n\n        try {\n            // initialize data block variables from context__\n            current_statement_begin__ = 3;\n            context__.validate_dims(\"data initialization\", \"d\", \"int\", context__.to_vec());\n            d = int(0);\n            vals_i__ = context__.vals_i(\"d\");\n            pos__ = 0;\n            d = vals_i__[pos__++];\n            check_greater_or_equal(function__, \"d\", d, 1);\n\n            current_statement_begin__ = 4;\n            context__.validate_dims(\"data initialization\", \"n\", \"int\", context__.to_vec());\n            n = int(0);\n            vals_i__ = context__.vals_i(\"n\");\n            pos__ = 0;\n            n = vals_i__[pos__++];\n            check_greater_or_equal(function__, \"n\", n, 1);\n\n            current_statement_begin__ = 5;\n            validate_non_negative_index(\"w\", \"(2 * n)\", (2 * n));\n            validate_non_negative_index(\"w\", \"d\", d);\n            context__.validate_dims(\"data initialization\", \"w\", \"int\", context__.to_vec((2 * n),d));\n            w = std::vector<std::vector<int> >((2 * n), std::vector<int>(d, int(0)));\n            vals_i__ = context__.vals_i(\"w\");\n            pos__ = 0;\n            size_t w_k_0_max__ = (2 * n);\n            size_t w_k_1_max__ = d;\n            for (size_t k_1__ = 0; k_1__ < w_k_1_max__; ++k_1__) {\n                for (size_t k_0__ = 0; k_0__ < w_k_0_max__; ++k_0__) {\n                    w[k_0__][k_1__] = vals_i__[pos__++];\n                }\n            }\n\n            current_statement_begin__ = 6;\n            validate_non_negative_index(\"x\", \"2\", 2);\n            validate_non_negative_index(\"x\", \"(2 * n)\", (2 * n));\n            context__.validate_dims(\"data initialization\", \"x\", \"matrix_d\", context__.to_vec(2,(2 * n)));\n            x = Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>(2, (2 * n));\n            vals_r__ = context__.vals_r(\"x\");\n            pos__ = 0;\n            size_t x_j_2_max__ = (2 * n);\n            size_t x_j_1_max__ = 2;\n            for (size_t j_2__ = 0; j_2__ < x_j_2_max__; ++j_2__) {\n                for (size_t j_1__ = 0; j_1__ < x_j_1_max__; ++j_1__) {\n                    x(j_1__, j_2__) = vals_r__[pos__++];\n                }\n            }\n\n            current_statement_begin__ = 7;\n            validate_non_negative_index(\"Z\", \"n\", n);\n            validate_non_negative_index(\"Z\", \"(2 * n)\", (2 * n));\n            context__.validate_dims(\"data initialization\", \"Z\", \"matrix_d\", context__.to_vec(n,(2 * n)));\n            Z = Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>(n, (2 * n));\n            vals_r__ = context__.vals_r(\"Z\");\n            pos__ = 0;\n            size_t Z_j_2_max__ = (2 * n);\n            size_t Z_j_1_max__ = n;\n            for (size_t j_2__ = 0; j_2__ < Z_j_2_max__; ++j_2__) {\n                for (size_t j_1__ = 0; j_1__ < Z_j_1_max__; ++j_1__) {\n                    Z(j_1__, j_2__) = vals_r__[pos__++];\n                }\n            }\n\n\n            // initialize transformed data variables\n            // execute transformed data statements\n\n            // validate transformed data\n\n            // validate, set parameter ranges\n            num_params_r__ = 0U;\n            param_ranges_i__.clear();\n            current_statement_begin__ = 12;\n            validate_non_negative_index(\"Sigma\", \"(d - 1)\", (d - 1));\n            validate_non_negative_index(\"Sigma\", \"(d - 1)\", (d - 1));\n            num_params_r__ += ((d - 1) + (((d - 1) * ((d - 1) - 1)) / 2));\n            current_statement_begin__ = 13;\n            validate_non_negative_index(\"v\", \"(d - 1)\", (d - 1));\n            validate_non_negative_index(\"v\", \"(2 * n)\", (2 * n));\n            num_params_r__ += ((d - 1) * (2 * n));\n            current_statement_begin__ = 14;\n            num_params_r__ += 1;\n            current_statement_begin__ = 15;\n            validate_non_negative_index(\"beta\", \"2\", 2);\n            validate_non_negative_index(\"beta\", \"(d - 1)\", (d - 1));\n            num_params_r__ += (2 * (d - 1));\n            current_statement_begin__ = 16;\n            validate_non_negative_index(\"u\", \"n\", n);\n            num_params_r__ += n;\n        } catch (const std::exception& e) {\n            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());\n            // Next line prevents compiler griping about no return\n            throw std::runtime_error(\"*** IF YOU SEE THIS, PLEASE REPORT A BUG ***\");\n        }\n    }\n\n    ~model5ef6f701cc921_stan_LNM_ME() { }\n\n\n    void transform_inits(const stan::io::var_context& context__,\n                         std::vector<int>& params_i__,\n                         std::vector<double>& params_r__,\n                         std::ostream* pstream__) const {\n        typedef double local_scalar_t__;\n        stan::io::writer<double> writer__(params_r__, params_i__);\n        size_t pos__;\n        (void) pos__; // dummy call to supress warning\n        std::vector<double> vals_r__;\n        std::vector<int> vals_i__;\n\n        current_statement_begin__ = 12;\n        if (!(context__.contains_r(\"Sigma\")))\n            stan::lang::rethrow_located(std::runtime_error(std::string(\"Variable Sigma missing\")), current_statement_begin__, prog_reader__());\n        vals_r__ = context__.vals_r(\"Sigma\");\n        pos__ = 0U;\n        validate_non_negative_index(\"Sigma\", \"(d - 1)\", (d - 1));\n        validate_non_negative_index(\"Sigma\", \"(d - 1)\", (d - 1));\n        context__.validate_dims(\"parameter initialization\", \"Sigma\", \"matrix_d\", context__.to_vec((d - 1),(d - 1)));\n        Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> Sigma((d - 1), (d - 1));\n        size_t Sigma_j_2_max__ = (d - 1);\n        size_t Sigma_j_1_max__ = (d - 1);\n        for (size_t j_2__ = 0; j_2__ < Sigma_j_2_max__; ++j_2__) {\n            for (size_t j_1__ = 0; j_1__ < Sigma_j_1_max__; ++j_1__) {\n                Sigma(j_1__, j_2__) = vals_r__[pos__++];\n            }\n        }\n        try {\n            writer__.cov_matrix_unconstrain(Sigma);\n        } catch (const std::exception& e) {\n            stan::lang::rethrow_located(std::runtime_error(std::string(\"Error transforming variable Sigma: \") + e.what()), current_statement_begin__, prog_reader__());\n        }\n\n        current_statement_begin__ = 13;\n        if (!(context__.contains_r(\"v\")))\n            stan::lang::rethrow_located(std::runtime_error(std::string(\"Variable v missing\")), current_statement_begin__, prog_reader__());\n        vals_r__ = context__.vals_r(\"v\");\n        pos__ = 0U;\n        validate_non_negative_index(\"v\", \"(d - 1)\", (d - 1));\n        validate_non_negative_index(\"v\", \"(2 * n)\", (2 * n));\n        context__.validate_dims(\"parameter initialization\", \"v\", \"vector_d\", context__.to_vec((2 * n),(d - 1)));\n        std::vector<Eigen::Matrix<double, Eigen::Dynamic, 1> > v((2 * n), Eigen::Matrix<double, Eigen::Dynamic, 1>((d - 1)));\n        size_t v_j_1_max__ = (d - 1);\n        size_t v_k_0_max__ = (2 * n);\n        for (size_t j_1__ = 0; j_1__ < v_j_1_max__; ++j_1__) {\n            for (size_t k_0__ = 0; k_0__ < v_k_0_max__; ++k_0__) {\n                v[k_0__](j_1__) = vals_r__[pos__++];\n            }\n        }\n        size_t v_i_0_max__ = (2 * n);\n        for (size_t i_0__ = 0; i_0__ < v_i_0_max__; ++i_0__) {\n            try {\n                writer__.vector_unconstrain(v[i_0__]);\n            } catch (const std::exception& e) {\n                stan::lang::rethrow_located(std::runtime_error(std::string(\"Error transforming variable v: \") + e.what()), current_statement_begin__, prog_reader__());\n            }\n        }\n\n        current_statement_begin__ = 14;\n        if (!(context__.contains_r(\"sigma_u\")))\n            stan::lang::rethrow_located(std::runtime_error(std::string(\"Variable sigma_u missing\")), current_statement_begin__, prog_reader__());\n        vals_r__ = context__.vals_r(\"sigma_u\");\n        pos__ = 0U;\n        context__.validate_dims(\"parameter initialization\", \"sigma_u\", \"double\", context__.to_vec());\n        double sigma_u(0);\n        sigma_u = vals_r__[pos__++];\n        try {\n            writer__.scalar_lb_unconstrain(0, sigma_u);\n        } catch (const std::exception& e) {\n            stan::lang::rethrow_located(std::runtime_error(std::string(\"Error transforming variable sigma_u: \") + e.what()), current_statement_begin__, prog_reader__());\n        }\n\n        current_statement_begin__ = 15;\n        if (!(context__.contains_r(\"beta\")))\n            stan::lang::rethrow_located(std::runtime_error(std::string(\"Variable beta missing\")), current_statement_begin__, prog_reader__());\n        vals_r__ = context__.vals_r(\"beta\");\n        pos__ = 0U;\n        validate_non_negative_index(\"beta\", \"2\", 2);\n        validate_non_negative_index(\"beta\", \"(d - 1)\", (d - 1));\n        context__.validate_dims(\"parameter initialization\", \"beta\", \"matrix_d\", context__.to_vec(2,(d - 1)));\n        Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> beta(2, (d - 1));\n        size_t beta_j_2_max__ = (d - 1);\n        size_t beta_j_1_max__ = 2;\n        for (size_t j_2__ = 0; j_2__ < beta_j_2_max__; ++j_2__) {\n            for (size_t j_1__ = 0; j_1__ < beta_j_1_max__; ++j_1__) {\n                beta(j_1__, j_2__) = vals_r__[pos__++];\n            }\n        }\n        try {\n            writer__.matrix_unconstrain(beta);\n        } catch (const std::exception& e) {\n            stan::lang::rethrow_located(std::runtime_error(std::string(\"Error transforming variable beta: \") + e.what()), current_statement_begin__, prog_reader__());\n        }\n\n        current_statement_begin__ = 16;\n        if (!(context__.contains_r(\"u\")))\n            stan::lang::rethrow_located(std::runtime_error(std::string(\"Variable u missing\")), current_statement_begin__, prog_reader__());\n        vals_r__ = context__.vals_r(\"u\");\n        pos__ = 0U;\n        validate_non_negative_index(\"u\", \"n\", n);\n        context__.validate_dims(\"parameter initialization\", \"u\", \"vector_d\", context__.to_vec(n));\n        Eigen::Matrix<double, Eigen::Dynamic, 1> u(n);\n        size_t u_j_1_max__ = n;\n        for (size_t j_1__ = 0; j_1__ < u_j_1_max__; ++j_1__) {\n            u(j_1__) = vals_r__[pos__++];\n        }\n        try {\n            writer__.vector_unconstrain(u);\n        } catch (const std::exception& e) {\n            stan::lang::rethrow_located(std::runtime_error(std::string(\"Error transforming variable u: \") + e.what()), current_statement_begin__, prog_reader__());\n        }\n\n        params_r__ = writer__.data_r();\n        params_i__ = writer__.data_i();\n    }\n\n    void transform_inits(const stan::io::var_context& context,\n                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,\n                         std::ostream* pstream__) const {\n      std::vector<double> params_r_vec;\n      std::vector<int> params_i_vec;\n      transform_inits(context, params_i_vec, params_r_vec, pstream__);\n      params_r.resize(params_r_vec.size());\n      for (int i = 0; i < params_r.size(); ++i)\n        params_r(i) = params_r_vec[i];\n    }\n\n\n    template <bool propto__, bool jacobian__, typename T__>\n    T__ log_prob(std::vector<T__>& params_r__,\n                 std::vector<int>& params_i__,\n                 std::ostream* pstream__ = 0) const {\n\n        typedef T__ local_scalar_t__;\n\n        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());\n        (void) DUMMY_VAR__;  // dummy to suppress unused var warning\n\n        T__ lp__(0.0);\n        stan::math::accumulator<T__> lp_accum__;\n        try {\n            stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);\n\n            // model parameters\n            current_statement_begin__ = 12;\n            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Sigma;\n            (void) Sigma;  // dummy to suppress unused var warning\n            if (jacobian__)\n                Sigma = in__.cov_matrix_constrain((d - 1), lp__);\n            else\n                Sigma = in__.cov_matrix_constrain((d - 1));\n\n            current_statement_begin__ = 13;\n            std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> > v;\n            size_t v_d_0_max__ = (2 * n);\n            v.reserve(v_d_0_max__);\n            for (size_t d_0__ = 0; d_0__ < v_d_0_max__; ++d_0__) {\n                if (jacobian__)\n                    v.push_back(in__.vector_constrain((d - 1), lp__));\n                else\n                    v.push_back(in__.vector_constrain((d - 1)));\n            }\n\n            current_statement_begin__ = 14;\n            local_scalar_t__ sigma_u;\n            (void) sigma_u;  // dummy to suppress unused var warning\n            if (jacobian__)\n                sigma_u = in__.scalar_lb_constrain(0, lp__);\n            else\n                sigma_u = in__.scalar_lb_constrain(0);\n\n            current_statement_begin__ = 15;\n            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> beta;\n            (void) beta;  // dummy to suppress unused var warning\n            if (jacobian__)\n                beta = in__.matrix_constrain(2, (d - 1), lp__);\n            else\n                beta = in__.matrix_constrain(2, (d - 1));\n\n            current_statement_begin__ = 16;\n            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> u;\n            (void) u;  // dummy to suppress unused var warning\n            if (jacobian__)\n                u = in__.vector_constrain(n, lp__);\n            else\n                u = in__.vector_constrain(n);\n\n            // transformed parameters\n            current_statement_begin__ = 20;\n            validate_non_negative_index(\"mu\", \"(2 * n)\", (2 * n));\n            validate_non_negative_index(\"mu\", \"(d - 1)\", (d - 1));\n            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> mu((2 * n), (d - 1));\n            stan::math::initialize(mu, DUMMY_VAR__);\n            stan::math::fill(mu, DUMMY_VAR__);\n\n            current_statement_begin__ = 21;\n            validate_non_negative_index(\"theta\", \"d\", d);\n            validate_non_negative_index(\"theta\", \"(2 * n)\", (2 * n));\n            std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> > theta((2 * n), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(d));\n            stan::math::initialize(theta, DUMMY_VAR__);\n            stan::math::fill(theta, DUMMY_VAR__);\n\n            current_statement_begin__ = 22;\n            validate_non_negative_index(\"full_v\", \"d\", d);\n            validate_non_negative_index(\"full_v\", \"(2 * n)\", (2 * n));\n            std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> > full_v((2 * n), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(d));\n            stan::math::initialize(full_v, DUMMY_VAR__);\n            stan::math::fill(full_v, DUMMY_VAR__);\n\n            // transformed parameters block statements\n            current_statement_begin__ = 24;\n            for (int i = 1; i <= (2 * n); ++i) {\n\n                current_statement_begin__ = 25;\n                for (int j = 1; j <= (d - 1); ++j) {\n\n                    current_statement_begin__ = 26;\n                    stan::model::assign(full_v, \n                                stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), \n                                get_base1(get_base1(v, i, \"v\", 1), j, \"v\", 2), \n                                \"assigning variable full_v\");\n                }\n                current_statement_begin__ = 28;\n                stan::model::assign(full_v, \n                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(d), stan::model::nil_index_list())), \n                            0, \n                            \"assigning variable full_v\");\n            }\n            current_statement_begin__ = 31;\n            for (int i = 1; i <= (2 * n); ++i) {\n\n                current_statement_begin__ = 32;\n                stan::model::assign(theta, \n                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), \n                            softmax(stan::model::rvalue(full_v, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), \"full_v\")), \n                            \"assigning variable theta\");\n            }\n            current_statement_begin__ = 35;\n            stan::math::assign(mu, add(multiply(transpose(x), beta), multiply(transpose(Z), rep_matrix(u, (d - 1)))));\n\n            // validate transformed parameters\n            const char* function__ = \"validate transformed params\";\n            (void) function__;  // dummy to suppress unused var warning\n\n            current_statement_begin__ = 20;\n            size_t mu_j_1_max__ = (2 * n);\n            size_t mu_j_2_max__ = (d - 1);\n            for (size_t j_1__ = 0; j_1__ < mu_j_1_max__; ++j_1__) {\n                for (size_t j_2__ = 0; j_2__ < mu_j_2_max__; ++j_2__) {\n                    if (stan::math::is_uninitialized(mu(j_1__, j_2__))) {\n                        std::stringstream msg__;\n                        msg__ << \"Undefined transformed parameter: mu\" << \"(\" << j_1__ << \", \" << j_2__ << \")\";\n                        stan::lang::rethrow_located(std::runtime_error(std::string(\"Error initializing variable mu: \") + msg__.str()), current_statement_begin__, prog_reader__());\n                    }\n                }\n            }\n            current_statement_begin__ = 21;\n            size_t theta_k_0_max__ = (2 * n);\n            size_t theta_j_1_max__ = d;\n            for (size_t k_0__ = 0; k_0__ < theta_k_0_max__; ++k_0__) {\n                for (size_t j_1__ = 0; j_1__ < theta_j_1_max__; ++j_1__) {\n                    if (stan::math::is_uninitialized(theta[k_0__](j_1__))) {\n                        std::stringstream msg__;\n                        msg__ << \"Undefined transformed parameter: theta\" << \"[\" << k_0__ << \"]\" << \"(\" << j_1__ << \")\";\n                        stan::lang::rethrow_located(std::runtime_error(std::string(\"Error initializing variable theta: \") + msg__.str()), current_statement_begin__, prog_reader__());\n                    }\n                }\n            }\n            size_t theta_i_0_max__ = (2 * n);\n            for (size_t i_0__ = 0; i_0__ < theta_i_0_max__; ++i_0__) {\n                stan::math::check_simplex(function__, \"theta[i_0__]\", theta[i_0__]);\n            }\n\n            current_statement_begin__ = 22;\n            size_t full_v_k_0_max__ = (2 * n);\n            size_t full_v_j_1_max__ = d;\n            for (size_t k_0__ = 0; k_0__ < full_v_k_0_max__; ++k_0__) {\n                for (size_t j_1__ = 0; j_1__ < full_v_j_1_max__; ++j_1__) {\n                    if (stan::math::is_uninitialized(full_v[k_0__](j_1__))) {\n                        std::stringstream msg__;\n                        msg__ << \"Undefined transformed parameter: full_v\" << \"[\" << k_0__ << \"]\" << \"(\" << j_1__ << \")\";\n                        stan::lang::rethrow_located(std::runtime_error(std::string(\"Error initializing variable full_v: \") + msg__.str()), current_statement_begin__, prog_reader__());\n                    }\n                }\n            }\n\n            // model body\n\n            current_statement_begin__ = 41;\n            lp_accum__.add(gamma_log<propto__>(sigma_u, 5, 5));\n            current_statement_begin__ = 44;\n            lp_accum__.add(normal_log<propto__>(u, 0, stan::math::sqrt(sigma_u)));\n            current_statement_begin__ = 46;\n            for (int d_it = 1; d_it <= (d - 1); ++d_it) {\n\n                current_statement_begin__ = 47;\n                lp_accum__.add(uniform_log<propto__>(stan::model::rvalue(beta, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(d_it), stan::model::nil_index_list())), \"beta\"), -(5), 5));\n            }\n            current_statement_begin__ = 50;\n            for (int i = 1; i <= (2 * n); ++i) {\n\n                current_statement_begin__ = 51;\n                lp_accum__.add(multi_normal_log<propto__>(stan::model::rvalue(v, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), \"v\"), stan::model::rvalue(mu, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), \"mu\"), Sigma));\n            }\n            current_statement_begin__ = 54;\n            for (int i = 1; i <= (2 * n); ++i) {\n\n                current_statement_begin__ = 55;\n                lp_accum__.add(multinomial_log<propto__>(stan::model::rvalue(w, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), \"w\"), stan::model::rvalue(theta, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), \"theta\")));\n            }\n\n        } catch (const std::exception& e) {\n            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());\n            // Next line prevents compiler griping about no return\n            throw std::runtime_error(\"*** IF YOU SEE THIS, PLEASE REPORT A BUG ***\");\n        }\n\n        lp_accum__.add(lp__);\n        return lp_accum__.sum();\n\n    } // log_prob()\n\n    template <bool propto, bool jacobian, typename T_>\n    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,\n               std::ostream* pstream = 0) const {\n      std::vector<T_> vec_params_r;\n      vec_params_r.reserve(params_r.size());\n      for (int i = 0; i < params_r.size(); ++i)\n        vec_params_r.push_back(params_r(i));\n      std::vector<int> vec_params_i;\n      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);\n    }\n\n\n    void get_param_names(std::vector<std::string>& names__) const {\n        names__.resize(0);\n        names__.push_back(\"Sigma\");\n        names__.push_back(\"v\");\n        names__.push_back(\"sigma_u\");\n        names__.push_back(\"beta\");\n        names__.push_back(\"u\");\n        names__.push_back(\"mu\");\n        names__.push_back(\"theta\");\n        names__.push_back(\"full_v\");\n    }\n\n\n    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {\n        dimss__.resize(0);\n        std::vector<size_t> dims__;\n        dims__.resize(0);\n        dims__.push_back((d - 1));\n        dims__.push_back((d - 1));\n        dimss__.push_back(dims__);\n        dims__.resize(0);\n        dims__.push_back((2 * n));\n        dims__.push_back((d - 1));\n        dimss__.push_back(dims__);\n        dims__.resize(0);\n        dimss__.push_back(dims__);\n        dims__.resize(0);\n        dims__.push_back(2);\n        dims__.push_back((d - 1));\n        dimss__.push_back(dims__);\n        dims__.resize(0);\n        dims__.push_back(n);\n        dimss__.push_back(dims__);\n        dims__.resize(0);\n        dims__.push_back((2 * n));\n        dims__.push_back((d - 1));\n        dimss__.push_back(dims__);\n        dims__.resize(0);\n        dims__.push_back((2 * n));\n        dims__.push_back(d);\n        dimss__.push_back(dims__);\n        dims__.resize(0);\n        dims__.push_back((2 * n));\n        dims__.push_back(d);\n        dimss__.push_back(dims__);\n    }\n\n    template <typename RNG>\n    void write_array(RNG& base_rng__,\n                     std::vector<double>& params_r__,\n                     std::vector<int>& params_i__,\n                     std::vector<double>& vars__,\n                     bool include_tparams__ = true,\n                     bool include_gqs__ = true,\n                     std::ostream* pstream__ = 0) const {\n        typedef double local_scalar_t__;\n\n        vars__.resize(0);\n        stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);\n        static const char* function__ = \"model5ef6f701cc921_stan_LNM_ME_namespace::write_array\";\n        (void) function__;  // dummy to suppress unused var warning\n\n        // read-transform, write parameters\n        Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> Sigma = in__.cov_matrix_constrain((d - 1));\n        size_t Sigma_j_2_max__ = (d - 1);\n        size_t Sigma_j_1_max__ = (d - 1);\n        for (size_t j_2__ = 0; j_2__ < Sigma_j_2_max__; ++j_2__) {\n            for (size_t j_1__ = 0; j_1__ < Sigma_j_1_max__; ++j_1__) {\n                vars__.push_back(Sigma(j_1__, j_2__));\n            }\n        }\n\n        std::vector<Eigen::Matrix<double, Eigen::Dynamic, 1> > v;\n        size_t v_d_0_max__ = (2 * n);\n        v.reserve(v_d_0_max__);\n        for (size_t d_0__ = 0; d_0__ < v_d_0_max__; ++d_0__) {\n            v.push_back(in__.vector_constrain((d - 1)));\n        }\n        size_t v_j_1_max__ = (d - 1);\n        size_t v_k_0_max__ = (2 * n);\n        for (size_t j_1__ = 0; j_1__ < v_j_1_max__; ++j_1__) {\n            for (size_t k_0__ = 0; k_0__ < v_k_0_max__; ++k_0__) {\n                vars__.push_back(v[k_0__](j_1__));\n            }\n        }\n\n        double sigma_u = in__.scalar_lb_constrain(0);\n        vars__.push_back(sigma_u);\n\n        Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> beta = in__.matrix_constrain(2, (d - 1));\n        size_t beta_j_2_max__ = (d - 1);\n        size_t beta_j_1_max__ = 2;\n        for (size_t j_2__ = 0; j_2__ < beta_j_2_max__; ++j_2__) {\n            for (size_t j_1__ = 0; j_1__ < beta_j_1_max__; ++j_1__) {\n                vars__.push_back(beta(j_1__, j_2__));\n            }\n        }\n\n        Eigen::Matrix<double, Eigen::Dynamic, 1> u = in__.vector_constrain(n);\n        size_t u_j_1_max__ = n;\n        for (size_t j_1__ = 0; j_1__ < u_j_1_max__; ++j_1__) {\n            vars__.push_back(u(j_1__));\n        }\n\n        double lp__ = 0.0;\n        (void) lp__;  // dummy to suppress unused var warning\n        stan::math::accumulator<double> lp_accum__;\n\n        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());\n        (void) DUMMY_VAR__;  // suppress unused var warning\n\n        if (!include_tparams__ && !include_gqs__) return;\n\n        try {\n            // declare and define transformed parameters\n            current_statement_begin__ = 20;\n            validate_non_negative_index(\"mu\", \"(2 * n)\", (2 * n));\n            validate_non_negative_index(\"mu\", \"(d - 1)\", (d - 1));\n            Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> mu((2 * n), (d - 1));\n            stan::math::initialize(mu, DUMMY_VAR__);\n            stan::math::fill(mu, DUMMY_VAR__);\n\n            current_statement_begin__ = 21;\n            validate_non_negative_index(\"theta\", \"d\", d);\n            validate_non_negative_index(\"theta\", \"(2 * n)\", (2 * n));\n            std::vector<Eigen::Matrix<double, Eigen::Dynamic, 1> > theta((2 * n), Eigen::Matrix<double, Eigen::Dynamic, 1>(d));\n            stan::math::initialize(theta, DUMMY_VAR__);\n            stan::math::fill(theta, DUMMY_VAR__);\n\n            current_statement_begin__ = 22;\n            validate_non_negative_index(\"full_v\", \"d\", d);\n            validate_non_negative_index(\"full_v\", \"(2 * n)\", (2 * n));\n            std::vector<Eigen::Matrix<double, Eigen::Dynamic, 1> > full_v((2 * n), Eigen::Matrix<double, Eigen::Dynamic, 1>(d));\n            stan::math::initialize(full_v, DUMMY_VAR__);\n            stan::math::fill(full_v, DUMMY_VAR__);\n\n            // do transformed parameters statements\n            current_statement_begin__ = 24;\n            for (int i = 1; i <= (2 * n); ++i) {\n\n                current_statement_begin__ = 25;\n                for (int j = 1; j <= (d - 1); ++j) {\n\n                    current_statement_begin__ = 26;\n                    stan::model::assign(full_v, \n                                stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), \n                                get_base1(get_base1(v, i, \"v\", 1), j, \"v\", 2), \n                                \"assigning variable full_v\");\n                }\n                current_statement_begin__ = 28;\n                stan::model::assign(full_v, \n                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(d), stan::model::nil_index_list())), \n                            0, \n                            \"assigning variable full_v\");\n            }\n            current_statement_begin__ = 31;\n            for (int i = 1; i <= (2 * n); ++i) {\n\n                current_statement_begin__ = 32;\n                stan::model::assign(theta, \n                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), \n                            softmax(stan::model::rvalue(full_v, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), \"full_v\")), \n                            \"assigning variable theta\");\n            }\n            current_statement_begin__ = 35;\n            stan::math::assign(mu, add(multiply(transpose(x), beta), multiply(transpose(Z), rep_matrix(u, (d - 1)))));\n\n            if (!include_gqs__ && !include_tparams__) return;\n            // validate transformed parameters\n            const char* function__ = \"validate transformed params\";\n            (void) function__;  // dummy to suppress unused var warning\n\n            current_statement_begin__ = 21;\n            size_t theta_i_0_max__ = (2 * n);\n            for (size_t i_0__ = 0; i_0__ < theta_i_0_max__; ++i_0__) {\n                stan::math::check_simplex(function__, \"theta[i_0__]\", theta[i_0__]);\n            }\n\n            // write transformed parameters\n            if (include_tparams__) {\n                size_t mu_j_2_max__ = (d - 1);\n                size_t mu_j_1_max__ = (2 * n);\n                for (size_t j_2__ = 0; j_2__ < mu_j_2_max__; ++j_2__) {\n                    for (size_t j_1__ = 0; j_1__ < mu_j_1_max__; ++j_1__) {\n                        vars__.push_back(mu(j_1__, j_2__));\n                    }\n                }\n                size_t theta_j_1_max__ = d;\n                size_t theta_k_0_max__ = (2 * n);\n                for (size_t j_1__ = 0; j_1__ < theta_j_1_max__; ++j_1__) {\n                    for (size_t k_0__ = 0; k_0__ < theta_k_0_max__; ++k_0__) {\n                        vars__.push_back(theta[k_0__](j_1__));\n                    }\n                }\n                size_t full_v_j_1_max__ = d;\n                size_t full_v_k_0_max__ = (2 * n);\n                for (size_t j_1__ = 0; j_1__ < full_v_j_1_max__; ++j_1__) {\n                    for (size_t k_0__ = 0; k_0__ < full_v_k_0_max__; ++k_0__) {\n                        vars__.push_back(full_v[k_0__](j_1__));\n                    }\n                }\n            }\n            if (!include_gqs__) return;\n        } catch (const std::exception& e) {\n            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());\n            // Next line prevents compiler griping about no return\n            throw std::runtime_error(\"*** IF YOU SEE THIS, PLEASE REPORT A BUG ***\");\n        }\n    }\n\n    template <typename RNG>\n    void write_array(RNG& base_rng,\n                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,\n                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,\n                     bool include_tparams = true,\n                     bool include_gqs = true,\n                     std::ostream* pstream = 0) const {\n      std::vector<double> params_r_vec(params_r.size());\n      for (int i = 0; i < params_r.size(); ++i)\n        params_r_vec[i] = params_r(i);\n      std::vector<double> vars_vec;\n      std::vector<int> params_i_vec;\n      write_array(base_rng, params_r_vec, params_i_vec, vars_vec, include_tparams, include_gqs, pstream);\n      vars.resize(vars_vec.size());\n      for (int i = 0; i < vars.size(); ++i)\n        vars(i) = vars_vec[i];\n    }\n\n    std::string model_name() const {\n        return \"model5ef6f701cc921_stan_LNM_ME\";\n    }\n\n\n    void constrained_param_names(std::vector<std::string>& param_names__,\n                                 bool include_tparams__ = true,\n                                 bool include_gqs__ = true) const {\n        std::stringstream param_name_stream__;\n        size_t Sigma_j_2_max__ = (d - 1);\n        size_t Sigma_j_1_max__ = (d - 1);\n        for (size_t j_2__ = 0; j_2__ < Sigma_j_2_max__; ++j_2__) {\n            for (size_t j_1__ = 0; j_1__ < Sigma_j_1_max__; ++j_1__) {\n                param_name_stream__.str(std::string());\n                param_name_stream__ << \"Sigma\" << '.' << j_1__ + 1 << '.' << j_2__ + 1;\n                param_names__.push_back(param_name_stream__.str());\n            }\n        }\n        size_t v_j_1_max__ = (d - 1);\n        size_t v_k_0_max__ = (2 * n);\n        for (size_t j_1__ = 0; j_1__ < v_j_1_max__; ++j_1__) {\n            for (size_t k_0__ = 0; k_0__ < v_k_0_max__; ++k_0__) {\n                param_name_stream__.str(std::string());\n                param_name_stream__ << \"v\" << '.' << k_0__ + 1 << '.' << j_1__ + 1;\n                param_names__.push_back(param_name_stream__.str());\n            }\n        }\n        param_name_stream__.str(std::string());\n        param_name_stream__ << \"sigma_u\";\n        param_names__.push_back(param_name_stream__.str());\n        size_t beta_j_2_max__ = (d - 1);\n        size_t beta_j_1_max__ = 2;\n        for (size_t j_2__ = 0; j_2__ < beta_j_2_max__; ++j_2__) {\n            for (size_t j_1__ = 0; j_1__ < beta_j_1_max__; ++j_1__) {\n                param_name_stream__.str(std::string());\n                param_name_stream__ << \"beta\" << '.' << j_1__ + 1 << '.' << j_2__ + 1;\n                param_names__.push_back(param_name_stream__.str());\n            }\n        }\n        size_t u_j_1_max__ = n;\n        for (size_t j_1__ = 0; j_1__ < u_j_1_max__; ++j_1__) {\n            param_name_stream__.str(std::string());\n            param_name_stream__ << \"u\" << '.' << j_1__ + 1;\n            param_names__.push_back(param_name_stream__.str());\n        }\n\n        if (!include_gqs__ && !include_tparams__) return;\n\n        if (include_tparams__) {\n            size_t mu_j_2_max__ = (d - 1);\n            size_t mu_j_1_max__ = (2 * n);\n            for (size_t j_2__ = 0; j_2__ < mu_j_2_max__; ++j_2__) {\n                for (size_t j_1__ = 0; j_1__ < mu_j_1_max__; ++j_1__) {\n                    param_name_stream__.str(std::string());\n                    param_name_stream__ << \"mu\" << '.' << j_1__ + 1 << '.' << j_2__ + 1;\n                    param_names__.push_back(param_name_stream__.str());\n                }\n            }\n            size_t theta_j_1_max__ = d;\n            size_t theta_k_0_max__ = (2 * n);\n            for (size_t j_1__ = 0; j_1__ < theta_j_1_max__; ++j_1__) {\n                for (size_t k_0__ = 0; k_0__ < theta_k_0_max__; ++k_0__) {\n                    param_name_stream__.str(std::string());\n                    param_name_stream__ << \"theta\" << '.' << k_0__ + 1 << '.' << j_1__ + 1;\n                    param_names__.push_back(param_name_stream__.str());\n                }\n            }\n            size_t full_v_j_1_max__ = d;\n            size_t full_v_k_0_max__ = (2 * n);\n            for (size_t j_1__ = 0; j_1__ < full_v_j_1_max__; ++j_1__) {\n                for (size_t k_0__ = 0; k_0__ < full_v_k_0_max__; ++k_0__) {\n                    param_name_stream__.str(std::string());\n                    param_name_stream__ << \"full_v\" << '.' << k_0__ + 1 << '.' << j_1__ + 1;\n                    param_names__.push_back(param_name_stream__.str());\n                }\n            }\n        }\n\n        if (!include_gqs__) return;\n    }\n\n\n    void unconstrained_param_names(std::vector<std::string>& param_names__,\n                                   bool include_tparams__ = true,\n                                   bool include_gqs__ = true) const {\n        std::stringstream param_name_stream__;\n        size_t Sigma_j_1_max__ = ((d - 1) + (((d - 1) * ((d - 1) - 1)) / 2));\n        for (size_t j_1__ = 0; j_1__ < Sigma_j_1_max__; ++j_1__) {\n            param_name_stream__.str(std::string());\n            param_name_stream__ << \"Sigma\" << '.' << j_1__ + 1;\n            param_names__.push_back(param_name_stream__.str());\n        }\n        size_t v_j_1_max__ = (d - 1);\n        size_t v_k_0_max__ = (2 * n);\n        for (size_t j_1__ = 0; j_1__ < v_j_1_max__; ++j_1__) {\n            for (size_t k_0__ = 0; k_0__ < v_k_0_max__; ++k_0__) {\n                param_name_stream__.str(std::string());\n                param_name_stream__ << \"v\" << '.' << k_0__ + 1 << '.' << j_1__ + 1;\n                param_names__.push_back(param_name_stream__.str());\n            }\n        }\n        param_name_stream__.str(std::string());\n        param_name_stream__ << \"sigma_u\";\n        param_names__.push_back(param_name_stream__.str());\n        size_t beta_j_2_max__ = (d - 1);\n        size_t beta_j_1_max__ = 2;\n        for (size_t j_2__ = 0; j_2__ < beta_j_2_max__; ++j_2__) {\n            for (size_t j_1__ = 0; j_1__ < beta_j_1_max__; ++j_1__) {\n                param_name_stream__.str(std::string());\n                param_name_stream__ << \"beta\" << '.' << j_1__ + 1 << '.' << j_2__ + 1;\n                param_names__.push_back(param_name_stream__.str());\n            }\n        }\n        size_t u_j_1_max__ = n;\n        for (size_t j_1__ = 0; j_1__ < u_j_1_max__; ++j_1__) {\n            param_name_stream__.str(std::string());\n            param_name_stream__ << \"u\" << '.' << j_1__ + 1;\n            param_names__.push_back(param_name_stream__.str());\n        }\n\n        if (!include_gqs__ && !include_tparams__) return;\n\n        if (include_tparams__) {\n            size_t mu_j_2_max__ = (d - 1);\n            size_t mu_j_1_max__ = (2 * n);\n            for (size_t j_2__ = 0; j_2__ < mu_j_2_max__; ++j_2__) {\n                for (size_t j_1__ = 0; j_1__ < mu_j_1_max__; ++j_1__) {\n                    param_name_stream__.str(std::string());\n                    param_name_stream__ << \"mu\" << '.' << j_1__ + 1 << '.' << j_2__ + 1;\n                    param_names__.push_back(param_name_stream__.str());\n                }\n            }\n            size_t theta_j_1_max__ = (d - 1);\n            size_t theta_k_0_max__ = (2 * n);\n            for (size_t j_1__ = 0; j_1__ < theta_j_1_max__; ++j_1__) {\n                for (size_t k_0__ = 0; k_0__ < theta_k_0_max__; ++k_0__) {\n                    param_name_stream__.str(std::string());\n                    param_name_stream__ << \"theta\" << '.' << k_0__ + 1 << '.' << j_1__ + 1;\n                    param_names__.push_back(param_name_stream__.str());\n                }\n            }\n            size_t full_v_j_1_max__ = d;\n            size_t full_v_k_0_max__ = (2 * n);\n            for (size_t j_1__ = 0; j_1__ < full_v_j_1_max__; ++j_1__) {\n                for (size_t k_0__ = 0; k_0__ < full_v_k_0_max__; ++k_0__) {\n                    param_name_stream__.str(std::string());\n                    param_name_stream__ << \"full_v\" << '.' << k_0__ + 1 << '.' << j_1__ + 1;\n                    param_names__.push_back(param_name_stream__.str());\n                }\n            }\n        }\n\n        if (!include_gqs__) return;\n    }\n\n}; // model\n\n}  // namespace\n\ntypedef model5ef6f701cc921_stan_LNM_ME_namespace::model5ef6f701cc921_stan_LNM_ME stan_model;\n\n#ifndef USING_R\n\nstan::model::model_base& new_model(\n        stan::io::var_context& data_context,\n        unsigned int seed,\n        std::ostream* msg_stream) {\n  stan_model* m = new stan_model(data_context, seed, msg_stream);\n  return *m;\n}\n\n#endif\n\n"

$model_name
[1] "stan_LNM_ME"

$model_code
[1] "\ndata{\n  int<lower=1> d; // number of compositions\n  int<lower=1> n; // number of samples\n  int w[2*n,d]; // this is the matrix of observations, which are counts (or count-like)\n  matrix[2, 2*n] x; // predictor\n  matrix[n,2*n] Z; // random effects id\n}\n\n\nparameters{\n  cov_matrix[d-1] Sigma; // covariance matrix for the normal\n  vector[d-1] v[2*n]; // a realisation of the multivariate normal\n  real<lower=0> sigma_u; // variance for random effects\n  matrix[2,d-1] beta; // FE coefficients\n  vector[n] u; // RE coeffcicients\n}\n\ntransformed parameters{\n  matrix[2*n,d-1] mu; // parameter for the normal. Unconstrained as it's a logR of two parts\n  simplex[d] theta[2*n]; // this is the parameter in the simplex that is fed into the multinomial\n  vector[d] full_v[2*n]; // transformed version of v, with an extra 0 for the last column\n\n  for(i in 1:2*n){\n    for(j in 1:(d-1)){\n      full_v[i,j] = v[i,j];\n    }\n    full_v[i,d] = 0;\n  }\n\n  for(i in 1:2*n){\n    theta[i,] = softmax(full_v[i,]);\n  }\n\n  mu = x'*beta + Z'*rep_matrix(u, d-1);\n\n}\n\nmodel {\n  // prior for random effects\n    sigma_u ~ gamma(5, 5);\n  \n  // prior for random effects\n  u ~ normal(0, sqrt(sigma_u));\n\n  for(d_it in 1:(d-1)){\n    beta[,d_it] ~ uniform(-5, 5);\n  }\n\n  for(i in 1:2*n){\n    v[i,] ~ multi_normal(mu[i,], Sigma);\n  }\n  \n  for(i in 1:2*n){\n    w[i,] ~ multinomial(theta[i,]);\n  }\n  \n}"
attr(,"model_name2")
[1] "stan_LNM_ME"

[1] 6
code for methods in class “Rcpp_stan_fit4model5ef6f4eeac6fd_stan_LNM_ME” was not checked for suspicious field assignments (recommended package ‘codetools’ not available?)
code for methods in class “Rcpp_stan_fit4model5ef6f4eeac6fd_stan_LNM_ME” was not checked for suspicious field assignments (recommended package ‘codetools’ not available?)

SAMPLING FOR MODEL 'stan_LNM_ME' NOW (CHAIN 1).

SAMPLING FOR MODEL 'stan_LNM_ME' NOW (CHAIN 2).
Chain 1: 
Chain 1: Gradient evaluation took 0 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 1: Iteration:     1 / 20000 [  0%]  (Warmup)
Chain 2: 
Chain 2: Gradient evaluation took 0 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 2: Iteration:     1 / 20000 [  0%]  (Warmup)
Chain 2: Iteration:  2000 / 20000 [ 10%]  (Warmup)
Chain 1: Iteration:  2000 / 20000 [ 10%]  (Warmup)
Chain 2: Iteration:  4000 / 20000 [ 20%]  (Warmup)
Chain 1: Iteration:  4000 / 20000 [ 20%]  (Warmup)
Chain 2: Iteration:  6000 / 20000 [ 30%]  (Warmup)
Chain 1: Iteration:  6000 / 20000 [ 30%]  (Warmup)
Chain 2: Iteration:  8000 / 20000 [ 40%]  (Warmup)
Chain 1: Iteration:  8000 / 20000 [ 40%]  (Warmup)
Chain 2: Iteration: 10000 / 20000 [ 50%]  (Warmup)
Chain 2: Iteration: 10001 / 20000 [ 50%]  (Sampling)
Chain 1: Iteration: 10000 / 20000 [ 50%]  (Warmup)
Chain 1: Iteration: 10001 / 20000 [ 50%]  (Sampling)
Chain 2: Iteration: 12000 / 20000 [ 60%]  (Sampling)
Chain 1: Iteration: 12000 / 20000 [ 60%]  (Sampling)
Chain 2: Iteration: 14000 / 20000 [ 70%]  (Sampling)
Chain 1: Iteration: 14000 / 20000 [ 70%]  (Sampling)
Chain 2: Iteration: 16000 / 20000 [ 80%]  (Sampling)
Chain 1: Iteration: 16000 / 20000 [ 80%]  (Sampling)
Chain 2: Iteration: 18000 / 20000 [ 90%]  (Sampling)
Chain 1: Iteration: 18000 / 20000 [ 90%]  (Sampling)
Chain 2: Iteration: 20000 / 20000 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 22.35 seconds (Warm-up)
Chain 2:                32.47 seconds (Sampling)
Chain 2:                54.82 seconds (Total)
Chain 2: 

SAMPLING FOR MODEL 'stan_LNM_ME' NOW (CHAIN 3).
Chain 1: Iteration: 20000 / 20000 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 24.77 seconds (Warm-up)
Chain 1:                31.28 seconds (Sampling)
Chain 1:                56.05 seconds (Total)
Chain 1: 
Chain 3: 
Chain 3: Gradient evaluation took 0 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 3: Iteration:     1 / 20000 [  0%]  (Warmup)

SAMPLING FOR MODEL 'stan_LNM_ME' NOW (CHAIN 4).
Chain 4: 
Chain 4: Gradient evaluation took 0 seconds
Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 4: Adjust your expectations accordingly!
Chain 4: 
Chain 4: 
Chain 4: Iteration:     1 / 20000 [  0%]  (Warmup)
Chain 3: Iteration:  2000 / 20000 [ 10%]  (Warmup)
Chain 4: Iteration:  2000 / 20000 [ 10%]  (Warmup)
Chain 3: Iteration:  4000 / 20000 [ 20%]  (Warmup)
Chain 4: Iteration:  4000 / 20000 [ 20%]  (Warmup)
Chain 3: Iteration:  6000 / 20000 [ 30%]  (Warmup)
Chain 4: Iteration:  6000 / 20000 [ 30%]  (Warmup)
Chain 3: Iteration:  8000 / 20000 [ 40%]  (Warmup)
Chain 4: Iteration:  8000 / 20000 [ 40%]  (Warmup)
Chain 3: Iteration: 10000 / 20000 [ 50%]  (Warmup)
Chain 3: Iteration: 10001 / 20000 [ 50%]  (Sampling)
Chain 4: Iteration: 10000 / 20000 [ 50%]  (Warmup)
Chain 4: Iteration: 10001 / 20000 [ 50%]  (Sampling)
Chain 3: Iteration: 12000 / 20000 [ 60%]  (Sampling)
Chain 4: Iteration: 12000 / 20000 [ 60%]  (Sampling)
Chain 3: Iteration: 14000 / 20000 [ 70%]  (Sampling)
Chain 4: Iteration: 14000 / 20000 [ 70%]  (Sampling)
Chain 3: Iteration: 16000 / 20000 [ 80%]  (Sampling)
Chain 3: Iteration: 18000 / 20000 [ 90%]  (Sampling)
Chain 4: Iteration: 16000 / 20000 [ 80%]  (Sampling)
Chain 3: Iteration: 20000 / 20000 [100%]  (Sampling)
Chain 3: 
Chain 3:  Elapsed Time: 20.79 seconds (Warm-up)
Chain 3:                20.9 seconds (Sampling)
Chain 3:                41.69 seconds (Total)
Chain 3: 
Chain 4: Iteration: 18000 / 20000 [ 90%]  (Sampling)
Chain 4: Iteration: 20000 / 20000 [100%]  (Sampling)
Chain 4: 
Chain 4:  Elapsed Time: 22.33 seconds (Warm-up)
Chain 4:                24.14 seconds (Sampling)
Chain 4:                46.47 seconds (Total)
Chain 4: 
Warning messages:
1: There were 39956 divergent transitions after warmup. Increasing adapt_delta above 0.8 may help. See
http://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup 
2: Examine the pairs() plot to diagnose sampling problems
 
3: The largest R-hat is NA, indicating chains have not mixed.
Running the chains for more iterations may help. See
http://mc-stan.org/misc/warnings.html#r-hat 
4: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable.
Running the chains for more iterations may help. See
http://mc-stan.org/misc/warnings.html#bulk-ess 
5: Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable.
Running the chains for more iterations may help. See
http://mc-stan.org/misc/warnings.html#tail-ess 
